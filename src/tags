!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
APP_MANAGER_HPP	app_manager.hpp	2;"	d
ASSERT	log.h	81;"	d
ASSERTD	log.h	91;"	d
ASSERTS	log.h	87;"	d
ASSERTSD	log.h	92;"	d
AddNodesCommand	command.hpp	/^	AddNodesCommand(AppId id)$/;"	f	class:AddNodesCommand	access:public	signature:(AppId id)
AddNodesCommand	command.hpp	/^class AddNodesCommand : public ICommand$/;"	c	inherits:ICommand
AddNodesCommand::AddNodesCommand	command.hpp	/^	AddNodesCommand(AppId id)$/;"	f	class:AddNodesCommand	access:public	signature:(AppId id)
AddNodesCommand::Nodes	command.hpp	/^	typedef std::set<unsigned> Nodes;$/;"	t	class:AddNodesCommand	access:public
AddNodesCommand::add_target_node	command.hpp	/^	void add_target_node(unsigned node_id)$/;"	f	class:AddNodesCommand	access:public	signature:(unsigned node_id)
AddNodesCommand::app_id_	command.hpp	/^	AppId app_id_;$/;"	m	class:AddNodesCommand	access:private
AddNodesCommand::execute	command.cpp	/^void AddNodesCommand::execute()$/;"	f	class:AddNodesCommand	signature:()
AddNodesCommand::nodes_	command.hpp	/^	Nodes nodes_;$/;"	m	class:AddNodesCommand	access:private
AddNodesCommand::reply	command.cpp	/^void AddNodesCommand::reply()$/;"	f	class:AddNodesCommand	signature:()
AddNodesCommand::target_nodes	command.hpp	/^	const Nodes & target_nodes() { return nodes_; }$/;"	f	class:AddNodesCommand	access:public	signature:()
AppDomain	app_manager.cpp	/^AppDomain::AppDomain(DomainInfoPtr pd)$/;"	f	class:AppDomain	signature:(DomainInfoPtr pd)
AppDomain	app_manager.hpp	/^class AppDomain : public boost::noncopyable$/;"	c	inherits:boost::noncopyable
AppDomain::AppDomain	app_manager.cpp	/^AppDomain::AppDomain(DomainInfoPtr pd)$/;"	f	class:AppDomain	signature:(DomainInfoPtr pd)
AppDomain::add_section	app_manager.hpp	/^	void add_section(const MatchSection & sec) { sec_man_.add_section(sec); }$/;"	f	class:AppDomain	access:public	signature:(const MatchSection & sec)
AppDomain::add_testid	app_manager.hpp	/^	void add_testid(unsigned testid) { testid_set_.insert(testid); }$/;"	f	class:AppDomain	access:public	signature:(unsigned testid)
AppDomain::appid	app_manager.hpp	/^	const AppId appid() const { return appid_; }$/;"	f	class:AppDomain	access:public	signature:() const
AppDomain::appid_	app_manager.hpp	/^	AppId appid_;$/;"	m	class:AppDomain	access:private
AppDomain::bitfeature_loader	app_manager.hpp	/^	BitFeatureLoader * bitfeature_loader() { return loader_; }$/;"	f	class:AppDomain	access:public	signature:()
AppDomain::bitfeature_sender	app_manager.hpp	/^	BitFeatureSender * bitfeature_sender() { return sender_; }$/;"	f	class:AppDomain	access:public	signature:()
AppDomain::domain_info_ptr	app_manager.hpp	/^	DomainInfoPtr domain_info_ptr() { return domaininfo_; }$/;"	f	class:AppDomain	access:public	signature:()
AppDomain::domaininfo_	app_manager.hpp	/^	DomainInfoPtr domaininfo_;$/;"	m	class:AppDomain	access:private
AppDomain::increase_sent_frames	app_manager.hpp	/^	void increase_sent_frames(unsigned v) { sent_frames_ += v; }$/;"	f	class:AppDomain	access:public	signature:(unsigned v)
AppDomain::loader_	app_manager.hpp	/^	BitFeatureLoader * loader_;$/;"	m	class:AppDomain	access:private
AppDomain::match_source	app_manager.hpp	/^	const std::string match_source() const { return match_source_; }$/;"	f	class:AppDomain	access:public	signature:() const
AppDomain::match_source_	app_manager.hpp	/^	std::string match_source_;$/;"	m	class:AppDomain	access:private
AppDomain::output_result	app_manager.cpp	/^void AppDomain::output_result(const std::string & path)$/;"	f	class:AppDomain	signature:(const std::string & path)
AppDomain::output_result	app_manager.cpp	/^void AppDomain::output_result(std::ostream & out)$/;"	f	class:AppDomain	signature:(std::ostream & out)
AppDomain::sec_man_	app_manager.hpp	/^	SectionManagerSimp sec_man_;$/;"	m	class:AppDomain	access:private
AppDomain::sender_	app_manager.hpp	/^	BitFeatureSender * sender_;$/;"	m	class:AppDomain	access:private
AppDomain::sent_frames	app_manager.hpp	/^	unsigned sent_frames() const { return sent_frames_; }$/;"	f	class:AppDomain	access:public	signature:() const
AppDomain::sent_frames_	app_manager.hpp	/^	unsigned sent_frames_;$/;"	m	class:AppDomain	access:private
AppDomain::set_loader	app_manager.hpp	/^	void set_loader(BitFeatureLoader * p) { loader_ = p; }$/;"	f	class:AppDomain	access:private	signature:(BitFeatureLoader * p)
AppDomain::set_sender	app_manager.hpp	/^	void set_sender(BitFeatureSender * p) { sender_ = p; }$/;"	f	class:AppDomain	access:private	signature:(BitFeatureSender * p)
AppDomain::speed	app_manager.cpp	/^unsigned AppDomain::speed() const$/;"	f	class:AppDomain	signature:() const
AppDomain::testid_set_	app_manager.hpp	/^	std::set<unsigned> testid_set_;$/;"	m	class:AppDomain	access:private
AppDomain::unhandled_frames	app_manager.cpp	/^unsigned AppDomain::unhandled_frames() const$/;"	f	class:AppDomain	signature:() const
AppDomain::window	app_manager.hpp	/^	BitFeatureWindow * window() { return &window_; }$/;"	f	class:AppDomain	access:public	signature:()
AppDomain::window_	app_manager.hpp	/^	BitFeatureWindow window_;$/;"	m	class:AppDomain	access:private
AppDomainMap	app_manager.hpp	/^	typedef std::map<AppId, AppDomainPtr> AppDomainMap;$/;"	t	class:AppManager	access:public
AppDomainPtr	app_manager.hpp	/^typedef boost::shared_ptr<AppDomain> AppDomainPtr;$/;"	t
AppId	lib_load_service.hpp	/^	typedef DomainType AppId;$/;"	t	class:LibLoadService	access:public
AppId	matcher_manager.hpp	/^struct AppId$/;"	s
AppId::DomainId	matcher_manager.hpp	/^	U16 DomainId;$/;"	m	struct:AppId	access:public
AppId::TimeStamp	matcher_manager.hpp	/^	U64 TimeStamp;$/;"	m	struct:AppId	access:public
AppId::to_string	matcher_manager.hpp	/^	std::string to_string() const {$/;"	f	struct:AppId	access:public	signature:() const
AppManager	app_manager.hpp	/^	AppManager() {}$/;"	f	class:AppManager	access:private	signature:()
AppManager	app_manager.hpp	/^class AppManager : boost::noncopyable$/;"	c	inherits:boost::noncopyable
AppManager::AppDomainMap	app_manager.hpp	/^	typedef std::map<AppId, AppDomainPtr> AppDomainMap;$/;"	t	class:AppManager	access:public
AppManager::AppManager	app_manager.hpp	/^	AppManager() {}$/;"	f	class:AppManager	access:private	signature:()
AppManager::create_app	app_manager.cpp	/^bool AppManager::create_app(DomainInfoPtr pd)$/;"	f	class:AppManager	signature:(DomainInfoPtr pd)
AppManager::create_app_threads	app_manager.cpp	/^void AppManager::create_app_threads(AppDomainPtr pa)$/;"	f	class:AppManager	signature:(AppDomainPtr pa)
AppManager::domains_	app_manager.hpp	/^	AppDomainMap domains_;$/;"	m	class:AppManager	access:private
AppManager::get_domain_by_appid	app_manager.hpp	/^	AppDomainPtr get_domain_by_appid(AppId appid) {$/;"	f	class:AppManager	access:public	signature:(AppId appid)
AppManager::instance	app_manager.hpp	/^	static AppManager & instance() {$/;"	f	class:AppManager	access:public	signature:()
AppManager::report_all	app_manager.hpp	/^	void report_all(std::ostream & out) {$/;"	f	class:AppManager	access:public	signature:(std::ostream & out)
ApplicationId	matcher_manager.hpp	/^	AppId ApplicationId;$/;"	m	struct:DomainInfo	access:public
AssertionFail	log.h	/^	AssertionFail()  : std::runtime_error("Assertion failed, please check the log file for more information.") {}$/;"	f	struct:AssertionFail	access:public	signature:()
AssertionFail	log.h	/^struct AssertionFail : std::runtime_error {$/;"	s	inherits:std::runtime_error
AssertionFail::AssertionFail	log.h	/^	AssertionFail()  : std::runtime_error("Assertion failed, please check the log file for more information.") {}$/;"	f	struct:AssertionFail	access:public	signature:()
AssignOp	comm_box.hpp	/^struct AssignOp : public std::binary_function< T, T, void >$/;"	s	inherits:std::binary_function
AssignOp::operator ()	comm_box.hpp	/^	void operator () (T & lhs, const T & rhs)$/;"	f	struct:AssignOp	access:public	signature:(T & lhs, const T & rhs)
BITFEATURE_TYPE	comm_para.hpp	/^	const u_char      BITFEATURE_TYPE     = 0x04;$/;"	m	namespace:__anon4
BITS_HPP	bits.hpp	2;"	d
BUSY	matcher_manager.hpp	/^  		BUSY,							\/\/<! do match state$/;"	e	enum:Matcher::MATCHER_STATE
BalanceThreshold	matcher_manager.hpp	/^	U16 BalanceThreshold;$/;"	m	struct:DomainInfo	access:public
Basebox	comm_box.hpp	/^	Basebox()$/;"	f	class:Basebox	access:protected	signature:()
Basebox	comm_box.hpp	/^class Basebox$/;"	c
Basebox::Basebox	comm_box.hpp	/^	Basebox()$/;"	f	class:Basebox	access:protected	signature:()
Basebox::all_put	comm_box.cpp	/^bool Basebox::all_put() const { return all_put_; }$/;"	f	class:Basebox	signature:() const
Basebox::all_put_	comm_box.hpp	/^	bool all_put_;$/;"	m	class:Basebox	access:protected
Basebox::box_empty	comm_box.hpp	/^	bool box_empty() const { return num_elements() == 0; }$/;"	f	class:Basebox	access:public	signature:() const
Basebox::box_full	comm_box.hpp	/^	bool box_full()  const { return num_elements() == capacity(); }$/;"	f	class:Basebox	access:public	signature:() const
Basebox::c_get	comm_box.hpp	/^	boost::condition c_put, c_get;$/;"	m	class:Basebox	access:protected
Basebox::c_put	comm_box.hpp	/^	boost::condition c_put, c_get;$/;"	m	class:Basebox	access:protected
Basebox::end_condition_not_satisfied	comm_box.hpp	/^	virtual bool end_condition_not_satisfied() const { return !(all_put() && box_empty()); }$/;"	f	class:Basebox	access:public	signature:() const
Basebox::end_condition_satisfied	comm_box.hpp	/^	bool end_condition_satisfied() const { return !end_condition_not_satisfied(); }$/;"	f	class:Basebox	access:public	signature:() const
Basebox::get_condition_not_satisfied	comm_box.hpp	/^	virtual bool get_condition_not_satisfied() const { return box_empty(); }$/;"	f	class:Basebox	access:public	signature:() const
Basebox::lock	comm_box.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:Basebox	access:public
Basebox::monitor	comm_box.hpp	/^	boost::mutex monitor;$/;"	m	class:Basebox	access:protected
Basebox::notify_all_put	comm_box.cpp	/^void Basebox::notify_all_put()$/;"	f	class:Basebox	signature:()
Basebox::notify_wait_get	comm_box.cpp	/^void Basebox::notify_wait_get()$/;"	f	class:Basebox	signature:()
Basebox::notify_wait_put	comm_box.cpp	/^void Basebox::notify_wait_put()$/;"	f	class:Basebox	signature:()
Basebox::put_condition_not_satisfied	comm_box.hpp	/^	virtual bool put_condition_not_satisfied() const { return box_full(); }$/;"	f	class:Basebox	access:public	signature:() const
Basebox::wait_get_condition	comm_box.cpp	/^void Basebox::wait_get_condition()$/;"	f	class:Basebox	signature:()
Basebox::wait_put_condition	comm_box.cpp	/^void Basebox::wait_put_condition()$/;"	f	class:Basebox	signature:()
Basebox::wait_until_box_empty	comm_box.cpp	/^void Basebox::wait_until_box_empty()$/;"	f	class:Basebox	signature:()
BasicPacket	packet.hpp	/^	BasicPacket(int data_len = N - 2)$/;"	f	class:BasicPacket	access:protected	signature:(int data_len = N - 2)
BasicPacket	packet.hpp	/^	BasicPacket(int len, u_char type, u_char idx, const eth::address& src, const eth::address& snk, u_char ctrl)$/;"	f	class:BasicPacket	access:protected	signature:(int len, u_char type, u_char idx, const eth::address& src, const eth::address& snk, u_char ctrl)
BasicPacket	packet.hpp	/^	BasicPacket(int len, u_char type, u_char idx, u_char ctrl)$/;"	f	class:BasicPacket	access:protected	signature:(int len, u_char type, u_char idx, u_char ctrl)
BasicPacket	packet.hpp	/^class BasicPacket$/;"	c
BasicPacket::BasicPacket	packet.hpp	/^	BasicPacket(int data_len = N - 2)$/;"	f	class:BasicPacket	access:protected	signature:(int data_len = N - 2)
BasicPacket::BasicPacket	packet.hpp	/^	BasicPacket(int len, u_char type, u_char idx, const eth::address& src, const eth::address& snk, u_char ctrl)$/;"	f	class:BasicPacket	access:protected	signature:(int len, u_char type, u_char idx, const eth::address& src, const eth::address& snk, u_char ctrl)
BasicPacket::BasicPacket	packet.hpp	/^	BasicPacket(int len, u_char type, u_char idx, u_char ctrl)$/;"	f	class:BasicPacket	access:protected	signature:(int len, u_char type, u_char idx, u_char ctrl)
BasicPacket::bytes_	packet.hpp	/^	u_char bytes_[HEAD_SIZE + N];$/;"	m	class:BasicPacket	access:protected
BasicPacket::check_load_len	packet.hpp	/^	void check_load_len( unsigned n )$/;"	f	class:BasicPacket	access:protected	signature:( unsigned n )
BasicPacket::ctrl	packet.hpp	/^	u_char          ctrl() const   { return bytes_[HEAD_SIZE + 2]; }$/;"	f	class:BasicPacket	access:public	signature:() const
BasicPacket::data_len	packet.hpp	/^	int      data_len() const { return data_len_; }$/;"	f	class:BasicPacket	access:public	signature:() const
BasicPacket::data_len_	packet.hpp	/^	int data_len_;$/;"	m	class:BasicPacket	access:protected
BasicPacket::data_ptr	packet.hpp	/^    u_char * data_ptr()  { return bytes_ + HEAD_SIZE + 2; }$/;"	f	class:BasicPacket	access:public	signature:()
BasicPacket::index	packet.hpp	/^	u_char         index() const   { return bytes_[HEAD_SIZE + 1]; }$/;"	f	class:BasicPacket	access:public	signature:() const
BasicPacket::load_len	packet.hpp	/^	int      load_len() const { return data_len_ + 2; }$/;"	f	class:BasicPacket	access:public	signature:() const
BasicPacket::load_ptr	packet.hpp	/^    u_char * load_ptr()  { return bytes_ + HEAD_SIZE;     }	\/\/ from type$/;"	f	class:BasicPacket	access:public	signature:()
BasicPacket::set_ctrl	packet.hpp	/^	void        set_ctrl(u_char c) { bytes_[HEAD_SIZE + 2] = c; }$/;"	f	class:BasicPacket	access:public	signature:(u_char c)
BasicPacket::set_data_len	packet.hpp	/^	void set_data_len(unsigned l)$/;"	f	class:BasicPacket	access:public	signature:(unsigned l)
BasicPacket::set_index	packet.hpp	/^	void       set_index(u_char c) { bytes_[HEAD_SIZE + 1] = c; }$/;"	f	class:BasicPacket	access:public	signature:(u_char c)
BasicPacket::set_info	packet.hpp	/^	void       	set_info(u_char type, u_char idx) { set_type(type); set_index(idx); }$/;"	f	class:BasicPacket	access:public	signature:(u_char type, u_char idx)
BasicPacket::set_info	packet.hpp	/^	void       	set_info(u_char type, u_char idx, int len) { set_type(type); set_index(idx); set_data_len(len); }$/;"	f	class:BasicPacket	access:public	signature:(u_char type, u_char idx, int len)
BasicPacket::set_load_len	packet.hpp	/^	void set_load_len(unsigned l)  { set_data_len(l - 2); }$/;"	f	class:BasicPacket	access:public	signature:(unsigned l)
BasicPacket::set_snk_mac	packet.hpp	/^	void       set_snk_mac(const eth::address& addr) { memcpy(bytes_    , addr.to_bytes(), 6); }$/;"	f	class:BasicPacket	access:public	signature:(const eth::address& addr)
BasicPacket::set_src_mac	packet.hpp	/^	void       set_src_mac(const eth::address& addr) { memcpy(bytes_ + 6, addr.to_bytes(), 6); }$/;"	f	class:BasicPacket	access:public	signature:(const eth::address& addr)
BasicPacket::set_total_len	packet.hpp	/^	void set_total_len(unsigned l) {$/;"	f	class:BasicPacket	access:public	signature:(unsigned l)
BasicPacket::set_type	packet.hpp	/^	void        set_type(u_char c) { bytes_[HEAD_SIZE + 0] = c; }$/;"	f	class:BasicPacket	access:public	signature:(u_char c)
BasicPacket::snk_addr	packet.hpp	/^	eth::address snk_addr() const { return eth::address(bytes_    , 6); }$/;"	f	class:BasicPacket	access:public	signature:() const
BasicPacket::src_addr	packet.hpp	/^	eth::address src_addr() const { return eth::address(bytes_ + 6, 6); }$/;"	f	class:BasicPacket	access:public	signature:() const
BasicPacket::to_raw_buffer	packet.hpp	/^	boost::asio::mutable_buffers_1 to_raw_buffer() { return boost::asio::buffer(bytes_, total_len()); }$/;"	f	class:BasicPacket	access:public	signature:()
BasicPacket::to_udp_buffer	packet.hpp	/^	boost::asio::mutable_buffers_1 to_udp_buffer() { return boost::asio::buffer(bytes_ + UDP_HEAD_SIZE, total_len() - UDP_HEAD_SIZE ); }$/;"	f	class:BasicPacket	access:public	signature:()
BasicPacket::total_len	packet.hpp	/^	int     total_len() const { return load_len() + HEAD_SIZE; }$/;"	f	class:BasicPacket	access:public	signature:() const
BasicPacket::type	packet.hpp	/^	u_char          type() const   { return bytes_[HEAD_SIZE + 0]; }$/;"	f	class:BasicPacket	access:public	signature:() const
BasicPacket::update_len_bytes	packet.hpp	/^	virtual void update_len_bytes()$/;"	f	class:BasicPacket	access:public	signature:()
BasicPower	matcher_manager.hpp	/^	U16 BasicPower;$/;"	m	struct:DomainInfo	access:public
BitFeature	bit_feature.h	/^	explicit BitFeature(int nbits) { set_bits(nbits); }$/;"	f	class:BitFeature	access:public	signature:(int nbits)
BitFeature	bit_feature.h	/^class BitFeature {$/;"	c
BitFeature::BitFeature	bit_feature.h	/^	explicit BitFeature(int nbits) { set_bits(nbits); }$/;"	f	class:BitFeature	access:public	signature:(int nbits)
BitFeature::Byte	bit_feature.h	/^	typedef unsigned char Byte;			\/\/ 8 bit$/;"	t	class:BitFeature	access:public
BitFeature::DWord	bit_feature.h	/^	typedef unsigned long long DWord;	\/\/ 64 bit$/;"	t	class:BitFeature	access:public
BitFeature::Word	bit_feature.h	/^	typedef unsigned int  Word;			\/\/ 32 bit$/;"	t	class:BitFeature	access:public
BitFeature::__anon7::bytes	bit_feature.h	/^		Byte   bytes[MAX_FEATURE_BITS\/ 8];$/;"	m	union:BitFeature::__anon7	access:public
BitFeature::__anon7::dwords	bit_feature.h	/^		DWord dwords[MAX_FEATURE_BITS\/64];$/;"	m	union:BitFeature::__anon7	access:public
BitFeature::__anon7::words	bit_feature.h	/^		Word   words[MAX_FEATURE_BITS\/32];$/;"	m	union:BitFeature::__anon7	access:public
BitFeature::clear	bit_feature.h	/^	void clear() { dwords[0] = dwords[1] = 0; }$/;"	f	class:BitFeature	access:public	signature:()
BitFeature::nbytes	bit_feature.h	/^	int nbytes() const { return nwords_ * 4; }$/;"	f	class:BitFeature	access:public	signature:() const
BitFeature::nwords	bit_feature.h	/^	int nwords() const { return nwords_; }$/;"	f	class:BitFeature	access:public	signature:() const
BitFeature::nwords_	bit_feature.h	/^	int nwords_;$/;"	m	class:BitFeature	access:private
BitFeature::set_bits	bit_feature.h	/^	void set_bits(int n) {$/;"	f	class:BitFeature	access:public	signature:(int n)
BitFeatureLoader	match_stream.cpp	/^BitFeatureLoader::BitFeatureLoader (AppDomainPtr app)$/;"	f	class:BitFeatureLoader	signature:(AppDomainPtr app)
BitFeatureLoader	match_stream.hpp	/^class BitFeatureLoader : public StreamNode$/;"	c	inherits:StreamNode
BitFeatureLoader::BitFeatureLoader	match_stream.cpp	/^BitFeatureLoader::BitFeatureLoader (AppDomainPtr app)$/;"	f	class:BitFeatureLoader	signature:(AppDomainPtr app)
BitFeatureLoader::app_	match_stream.hpp	/^	AppDomainPtr app_;$/;"	m	class:BitFeatureLoader	access:private
BitFeatureLoader::do_end_task	match_stream.cpp	/^void BitFeatureLoader::do_end_task()$/;"	f	class:BitFeatureLoader	signature:()
BitFeatureLoader::do_run_task	match_stream.cpp	/^void BitFeatureLoader::do_run_task()$/;"	f	class:BitFeatureLoader	signature:()
BitFeatureLoader::image_cnt_	match_stream.hpp	/^	std::size_t image_cnt_;$/;"	m	class:BitFeatureLoader	access:private
BitFeatureLoader::load_loop	match_stream.cpp	/^void BitFeatureLoader::load_loop(const VideoLibVec & videos)$/;"	f	class:BitFeatureLoader	signature:(const VideoLibVec & videos)
BitFeatureLoader::load_section	match_stream.cpp	/^void BitFeatureLoader::load_section (unsigned short vid, unsigned short frompos, const BitFeature * bit_vec, unsigned size, MatcherPtr matcher, unsigned slice_idx)$/;"	f	class:BitFeatureLoader	signature:(unsigned short vid, unsigned short frompos, const BitFeature * bit_vec, unsigned size, MatcherPtr matcher, unsigned slice_idx)
BitFeatureLoader::vec_	match_stream.hpp	/^	VideoLibVec vec_;$/;"	m	class:BitFeatureLoader	access:private
BitFeatureSender	match_stream.cpp	/^BitFeatureSender::BitFeatureSender(AppDomainPtr app)$/;"	f	class:BitFeatureSender	signature:(AppDomainPtr app)
BitFeatureSender	match_stream.hpp	/^class BitFeatureSender : public StreamNode$/;"	c	inherits:StreamNode
BitFeatureSender::BitFeatureSender	match_stream.cpp	/^BitFeatureSender::BitFeatureSender(AppDomainPtr app)$/;"	f	class:BitFeatureSender	signature:(AppDomainPtr app)
BitFeatureSender::app_	match_stream.hpp	/^	AppDomainPtr app_;$/;"	m	class:BitFeatureSender	access:private
BitFeatureSender::dest_addr	match_stream.cpp	/^const endpoint BitFeatureSender::dest_addr() const $/;"	f	class:BitFeatureSender	signature:() const
BitFeatureSender::dest_addr_	match_stream.hpp	/^	endpoint dest_addr_;$/;"	m	class:BitFeatureSender	access:private
BitFeatureSender::do_end_task	match_stream.cpp	/^void BitFeatureSender::do_end_task()$/;"	f	class:BitFeatureSender	signature:()
BitFeatureSender::do_run_task	match_stream.cpp	/^void BitFeatureSender::do_run_task()$/;"	f	class:BitFeatureSender	signature:()
BitFeatureSender::pause_time	match_stream.hpp	/^	unsigned pause_time() const { return paused_time_; }$/;"	f	class:BitFeatureSender	access:public	signature:() const
BitFeatureSender::paused_time_	match_stream.hpp	/^	unsigned paused_time_;$/;"	m	class:BitFeatureSender	access:private
BitFeatureSender::send_packets_loop	match_stream.cpp	/^void BitFeatureSender::send_packets_loop()$/;"	f	class:BitFeatureSender	signature:()
BitFeatureSender::set_dest_addr	match_stream.cpp	/^void BitFeatureSender::set_dest_addr( const endpoint & addr )$/;"	f	class:BitFeatureSender	signature:( const endpoint & addr )
BitFeatureSender::update_pause_time	match_stream.cpp	/^void BitFeatureSender::update_pause_time(unsigned v)$/;"	f	class:BitFeatureSender	signature:(unsigned v)
BitFeatureWindow	comm_window.hpp	/^	explicit BitFeatureWindow(int timeout = 20)$/;"	f	class:BitFeatureWindow	access:public	signature:(int timeout = 20)
BitFeatureWindow	comm_window.hpp	/^class BitFeatureWindow : public bitfeature_window_base__$/;"	c	inherits:bitfeature_window_base__
BitFeatureWindow::BitFeatureWindow	comm_window.hpp	/^	explicit BitFeatureWindow(int timeout = 20)$/;"	f	class:BitFeatureWindow	access:public	signature:(int timeout = 20)
BitFeature_H	bit_feature.h	2;"	d
BoxIntegral	integral.h	/^	int BoxIntegral(int row, int col, int rows, int cols) const {$/;"	f	struct:IntImage	access:public	signature:(int row, int col, int rows, int cols) const
Byte	bit_feature.h	/^	typedef unsigned char Byte;			\/\/ 8 bit$/;"	t	class:BitFeature	access:public
CFA_UDP_HEAD_SIZE	packet.hpp	/^	CFA_UDP_HEAD_SIZE = UDP_HEAD_SIZE + 4,$/;"	e	enum:__anon9
CFA_UDP_MAX_DATA_LEN	packet.hpp	/^	CFA_UDP_MAX_DATA_LEN = CFA_UDP_MAX_LOAD_LEN - 2,	\/\/ 1466$/;"	e	enum:__anon9
CFA_UDP_MAX_LOAD_LEN	packet.hpp	/^	CFA_UDP_MAX_LOAD_LEN = ETH_MAX_LEN - CFA_UDP_HEAD_SIZE,	\/\/ 1468$/;"	e	enum:__anon9
CFA_UDP_MIN_DATA_LEN	packet.hpp	/^	CFA_UDP_MIN_DATA_LEN = CFA_UDP_MIN_LOAD_LEN - 2,	\/\/ 12$/;"	e	enum:__anon9
CFA_UDP_MIN_LOAD_LEN	packet.hpp	/^	CFA_UDP_MIN_LOAD_LEN = ETH_MIN_LEN - CFA_UDP_HEAD_SIZE,	\/\/ 14$/;"	e	enum:__anon9
CLIENT_SOCK_FILE	command_recv_service.cpp	6;"	d	file:
CLIENT_SOCK_FILE	dcsp_fifo.h	14;"	d
COLLECTED	matcher_manager.hpp	/^		COLLECTED,						\/\/<! collected, won't be target any more$/;"	e	enum:Matcher::MATCHER_STATE
COLOURS	utils.cpp	/^static const CvScalar COLOURS [] = {cvScalar(255,0,0), cvScalar(0,255,0), $/;"	v	file:
COMMAND_HPP	command.hpp	2;"	d
COMMAND_RECV_SERVICE_HPP	command_recv_service.hpp	2;"	d
COMM_ARG_HPP	comm_arg.hpp	2;"	d
COMM_BOX_HPP	comm_box.hpp	8;"	d
COMM_PARA_HPP	comm_para.hpp	2;"	d
COMM_WINDOW	comm_window.hpp	8;"	d
CONNECTION_BUILD_SERVICE_HPP	connection_build_service.hpp	2;"	d
CONN_BUILD	comm_para.hpp	/^	const u_char      CONN_BUILD          = 0x70;$/;"	m	namespace:__anon4
CTRL_PAUSE	comm_para.hpp	/^	const u_char      CTRL_PAUSE          = 0xFF;$/;"	m	namespace:__anon4
CTRL_RECOVER	comm_para.hpp	/^	const u_char      CTRL_RECOVER        = 0x00;$/;"	m	namespace:__anon4
CfaUdpPacket	packet.hpp	/^	CfaUdpPacket (int len = CFA_UDP_MAX_DATA_LEN)$/;"	f	class:CfaUdpPacket	access:public	signature:(int len = CFA_UDP_MAX_DATA_LEN)
CfaUdpPacket	packet.hpp	/^	CfaUdpPacket (int len, u_char type, u_char idx)$/;"	f	class:CfaUdpPacket	access:public	signature:(int len, u_char type, u_char idx)
CfaUdpPacket	packet.hpp	/^class CfaUdpPacket : public cfa_udp_packet_base__$/;"	c	inherits:cfa_udp_packet_base__
CfaUdpPacket::CfaUdpPacket	packet.hpp	/^	CfaUdpPacket (int len = CFA_UDP_MAX_DATA_LEN)$/;"	f	class:CfaUdpPacket	access:public	signature:(int len = CFA_UDP_MAX_DATA_LEN)
CfaUdpPacket::CfaUdpPacket	packet.hpp	/^	CfaUdpPacket (int len, u_char type, u_char idx)$/;"	f	class:CfaUdpPacket	access:public	signature:(int len, u_char type, u_char idx)
CfaUdpPacket::from_point	packet.hpp	/^	const udp::endpoint from_point() { return src_endpoint_; }$/;"	f	class:CfaUdpPacket	access:public	signature:()
CfaUdpPacket::make_shared_packet	packet.hpp	/^	static PacketPtr make_shared_packet(const Packet & pkt)$/;"	f	class:CfaUdpPacket	access:public	signature:(const Packet & pkt)
CfaUdpPacket::set_from_point	packet.hpp	/^	void set_from_point(const udp::endpoint & e)$/;"	f	class:CfaUdpPacket	access:public	signature:(const udp::endpoint & e)
CfaUdpPacket::src_endpoint_	packet.hpp	/^	udp::endpoint src_endpoint_;$/;"	m	class:CfaUdpPacket	access:private
CfaUdpPacket::update_len_bytes	packet.hpp	/^	virtual void update_len_bytes()$/;"	f	class:CfaUdpPacket	access:public	signature:()
CfaUdpResponPacket	packet.hpp	/^	CfaUdpResponPacket()$/;"	f	class:CfaUdpResponPacket	access:public	signature:()
CfaUdpResponPacket	packet.hpp	/^	CfaUdpResponPacket(u_char type, u_char idx, u_char ctrl = 0x00)$/;"	f	class:CfaUdpResponPacket	access:public	signature:(u_char type, u_char idx, u_char ctrl = 0x00)
CfaUdpResponPacket	packet.hpp	/^class CfaUdpResponPacket : public cfa_udp_response_packet_base__$/;"	c	inherits:cfa_udp_response_packet_base__
CfaUdpResponPacket::CfaUdpResponPacket	packet.hpp	/^	CfaUdpResponPacket()$/;"	f	class:CfaUdpResponPacket	access:public	signature:()
CfaUdpResponPacket::CfaUdpResponPacket	packet.hpp	/^	CfaUdpResponPacket(u_char type, u_char idx, u_char ctrl = 0x00)$/;"	f	class:CfaUdpResponPacket	access:public	signature:(u_char type, u_char idx, u_char ctrl = 0x00)
CfaUdpResponPacket::update_len_bytes	packet.hpp	/^	virtual void update_len_bytes()$/;"	f	class:CfaUdpResponPacket	access:public	signature:()
Chain	match_utils.h	/^	typedef std::list<MatchSection> Chain;		\/\/ ”––Ú¡¥±Ì$/;"	t	class:SectionManager	access:public
CommArg	comm_arg.hpp	/^	CommArg()$/;"	f	struct:CommArg	access:private	signature:()
CommArg	comm_arg.hpp	/^struct CommArg : boost::noncopyable$/;"	s	inherits:boost::noncopyable
CommArg::CommArg	comm_arg.hpp	/^	CommArg()$/;"	f	struct:CommArg	access:private	signature:()
CommArg::balance_threshold	comm_arg.hpp	/^	int balance_threshold;$/;"	m	struct:CommArg	access:public
CommArg::bind_ip	comm_arg.hpp	/^	std::string    bind_ip;$/;"	m	struct:CommArg	access:public
CommArg::client_addrs	comm_arg.hpp	/^	std::vector<std::string> client_addrs;$/;"	m	struct:CommArg	access:public
CommArg::comm_arg	comm_arg.hpp	/^	static CommArg & comm_arg()$/;"	f	struct:CommArg	access:public	signature:()
CommArg::command_bind_ip	comm_arg.hpp	/^	std::string command_bind_ip;$/;"	m	struct:CommArg	access:public
CommArg::command_bind_port	comm_arg.hpp	/^	unsigned short command_bind_port;$/;"	m	struct:CommArg	access:public
CommArg::conn_build_wait_time	comm_arg.hpp	/^	int conn_build_wait_time;$/;"	m	struct:CommArg	access:public
CommArg::consider_extract_mac	comm_arg.hpp	/^	int consider_extract_mac;$/;"	m	struct:CommArg	access:public
CommArg::debug	comm_arg.hpp	/^	int debug;$/;"	m	struct:CommArg	access:public
CommArg::device	comm_arg.hpp	/^	std::string    device;$/;"	m	struct:CommArg	access:public
CommArg::do_send_lib	comm_arg.hpp	/^	int do_send_lib;$/;"	m	struct:CommArg	access:public
CommArg::do_surf	comm_arg.hpp	/^	int do_surf;$/;"	m	struct:CommArg	access:public
CommArg::dump_matched_lib	comm_arg.hpp	/^	int dump_matched_lib;$/;"	m	struct:CommArg	access:public
CommArg::extract_addr	comm_arg.hpp	/^	std::string    extract_addr;$/;"	m	struct:CommArg	access:public
CommArg::file_to_match	comm_arg.hpp	/^	std::string file_to_match;$/;"	m	struct:CommArg	access:public
CommArg::fpga_port	comm_arg.hpp	/^	unsigned short fpga_port;$/;"	m	struct:CommArg	access:public
CommArg::framegroup_size	comm_arg.hpp	/^	int framegroup_size;$/;"	m	struct:CommArg	access:public
CommArg::group_pause	comm_arg.hpp	/^	unsigned group_pause;$/;"	m	struct:CommArg	access:public
CommArg::image_libs	comm_arg.hpp	/^	std::vector<std::string> image_libs;$/;"	m	struct:CommArg	access:public
CommArg::image_pause	comm_arg.hpp	/^	int image_pause;$/;"	m	struct:CommArg	access:public
CommArg::image_ratio	comm_arg.hpp	/^	int image_ratio;$/;"	m	struct:CommArg	access:public
CommArg::images	comm_arg.hpp	/^	std::vector<std::string> images;$/;"	m	struct:CommArg	access:public
CommArg::lib_id	comm_arg.hpp	/^	unsigned lib_id;$/;"	m	struct:CommArg	access:public
CommArg::libs	comm_arg.hpp	/^	std::vector<std::string> libs;$/;"	m	struct:CommArg	access:public
CommArg::log_file	comm_arg.hpp	/^	std::string    log_file;$/;"	m	struct:CommArg	access:public
CommArg::mainode_id	comm_arg.hpp	/^	unsigned mainode_id;$/;"	m	struct:CommArg	access:public
CommArg::manually_broadcast_points	comm_arg.hpp	/^	int manually_broadcast_points;$/;"	m	struct:CommArg	access:public
CommArg::match_threshold	comm_arg.hpp	/^	int match_threshold;$/;"	m	struct:CommArg	access:public
CommArg::match_timeout	comm_arg.hpp	/^	int match_timeout;$/;"	m	struct:CommArg	access:public
CommArg::match_width	comm_arg.hpp	/^	int match_width;$/;"	m	struct:CommArg	access:public
CommArg::max_conn_times_allowed	comm_arg.hpp	/^	int max_conn_times_allowed;$/;"	m	struct:CommArg	access:public
CommArg::max_num_node	comm_arg.hpp	/^	unsigned max_num_node;$/;"	m	struct:CommArg	access:public
CommArg::merge_threshold	comm_arg.hpp	/^	int merge_threshold;$/;"	m	struct:CommArg	access:public
CommArg::merge_unit	comm_arg.hpp	/^	int merge_unit;$/;"	m	struct:CommArg	access:public
CommArg::nbits	comm_arg.hpp	/^	int nbits;$/;"	m	struct:CommArg	access:public
CommArg::node_speed	comm_arg.hpp	/^	double node_speed;$/;"	m	struct:CommArg	access:public
CommArg::num_clients	comm_arg.hpp	/^	int num_clients;$/;"	m	struct:CommArg	access:public
CommArg::only_send_image	comm_arg.hpp	/^	int only_send_image;$/;"	m	struct:CommArg	access:public
CommArg::only_send_lib	comm_arg.hpp	/^	int only_send_lib;$/;"	m	struct:CommArg	access:public
CommArg::only_transform_lib	comm_arg.hpp	/^	int only_transform_lib;$/;"	m	struct:CommArg	access:public
CommArg::out_file	comm_arg.hpp	/^	std::string    out_file;$/;"	m	struct:CommArg	access:public
CommArg::packet_pause	comm_arg.hpp	/^	unsigned packet_pause;$/;"	m	struct:CommArg	access:public
CommArg::parse_host_file	comm_arg.cpp	/^bool CommArg::parse_host_file( const char * file )$/;"	f	class:CommArg	signature:( const char * file )
CommArg::parse_info_file	comm_arg.cpp	/^bool CommArg::parse_info_file( const char * file )$/;"	f	class:CommArg	signature:( const char * file )
CommArg::pdss_id	comm_arg.hpp	/^	unsigned pdss_id;$/;"	m	struct:CommArg	access:public
CommArg::random_loop	comm_arg.hpp	/^	int random_loop;$/;"	m	struct:CommArg	access:public
CommArg::send_port	comm_arg.hpp	/^	unsigned short send_port;$/;"	m	struct:CommArg	access:public
CommArg::server_port	comm_arg.hpp	/^	unsigned short server_port;$/;"	m	struct:CommArg	access:public
CommArg::sleep_time	comm_arg.hpp	/^  	int sleep_time;$/;"	m	struct:CommArg	access:public
CommArg::sources	comm_arg.hpp	/^	std::vector<std::string> sources;$/;"	m	struct:CommArg	access:public
CommArg::use_packet_pause	comm_arg.hpp	/^	int use_packet_pause;$/;"	m	struct:CommArg	access:public
CommArg::video_beg	comm_arg.hpp	/^	int video_beg;$/;"	m	struct:CommArg	access:public
CommArg::video_end	comm_arg.hpp	/^	int video_end;$/;"	m	struct:CommArg	access:public
CommArg::video_pause	comm_arg.hpp	/^	int video_pause;$/;"	m	struct:CommArg	access:public
CommArg::video_ratio	comm_arg.hpp	/^	int video_ratio;$/;"	m	struct:CommArg	access:public
CommArg::videos	comm_arg.hpp	/^	std::vector<std::string> videos;$/;"	m	struct:CommArg	access:public
CommBox	comm_box.hpp	/^	CommBox()$/;"	f	class:CommBox	access:public	signature:()
CommBox	comm_box.hpp	/^class CommBox : public Basebox$/;"	c	inherits:Basebox
CommBox::CommBox	comm_box.hpp	/^	CommBox()$/;"	f	class:CommBox	access:public	signature:()
CommBox::capacity	comm_box.hpp	/^	virtual std::size_t capacity()     const { return 1; }$/;"	f	class:CommBox	access:public	signature:() const
CommBox::data	comm_box.hpp	/^	T data;$/;"	m	class:CommBox	access:protected
CommBox::data_valid	comm_box.hpp	/^	bool data_valid;$/;"	m	class:CommBox	access:protected
CommBox::get	comm_box.hpp	/^	bool get(T & t)$/;"	f	class:CommBox	access:public	signature:(T & t)
CommBox::num_elements	comm_box.hpp	/^	virtual std::size_t num_elements() const { return data_valid ? 1 : 0; }$/;"	f	class:CommBox	access:public	signature:() const
CommBox::put	comm_box.hpp	/^	void put(const T & t)$/;"	f	class:CommBox	access:public	signature:(const T & t)
CommQueue	comm_box.hpp	/^class CommQueue : public Basebox$/;"	c	inherits:Basebox
CommQueue::Queue	comm_box.hpp	/^	typedef typename std::queue< T > Queue;$/;"	t	class:CommQueue	access:private
CommQueue::capacity	comm_box.hpp	/^	virtual std::size_t capacity()     const$/;"	f	class:CommQueue	access:public	signature:() const
CommQueue::get	comm_box.hpp	/^	T get()$/;"	f	class:CommQueue	access:public	signature:()
CommQueue::num_elements	comm_box.hpp	/^	virtual std::size_t num_elements() const$/;"	f	class:CommQueue	access:public	signature:() const
CommQueue::put	comm_box.hpp	/^	void put(T p)$/;"	f	class:CommQueue	access:public	signature:(T p)
CommQueue::queue_	comm_box.hpp	/^	Queue queue_;$/;"	m	class:CommQueue	access:private
CommTimeout	matcher_manager.hpp	/^	U16 CommTimeout;$/;"	m	struct:DomainInfo	access:public
CommandPtr	command.hpp	/^typedef boost::shared_ptr<ICommand> CommandPtr;$/;"	t
CommandQueue	comm_box.hpp	/^typedef CommQueue< CommandPtr > CommandQueue;$/;"	t
CommandRecvService	command_recv_service.cpp	/^CommandRecvService::CommandRecvService()$/;"	f	class:CommandRecvService	signature:()
CommandRecvService	command_recv_service.hpp	/^class CommandRecvService$/;"	c
CommandRecvService::CommandRecvService	command_recv_service.cpp	/^CommandRecvService::CommandRecvService()$/;"	f	class:CommandRecvService	signature:()
CommandRecvService::buffer_send_center	command_recv_service.cpp	/^void CommandRecvService::buffer_send_center()$/;"	f	class:CommandRecvService	signature:()
CommandRecvService::client_	command_recv_service.hpp	/^	datagram_protocol::endpoint client_;$/;"	m	class:CommandRecvService	access:private
CommandRecvService::command_execute_loop	command_recv_service.cpp	/^void CommandRecvService::command_execute_loop()$/;"	f	class:CommandRecvService	signature:()
CommandRecvService::end	command_recv_service.cpp	/^bool CommandRecvService::end()$/;"	f	class:CommandRecvService	signature:()
CommandRecvService::instance	command_recv_service.cpp	/^CommandRecvService & CommandRecvService::instance()$/;"	f	class:CommandRecvService	signature:()
CommandRecvService::io_	command_recv_service.hpp	/^	boost::asio::io_service io_;$/;"	m	class:CommandRecvService	access:private
CommandRecvService::make_command	command_recv_service.cpp	/^CommandPtr CommandRecvService::make_command(u_char * msg, unsigned length, unsigned msg_id)$/;"	f	class:CommandRecvService	signature:(u_char * msg, unsigned length, unsigned msg_id)
CommandRecvService::run	command_recv_service.cpp	/^void CommandRecvService::run()$/;"	f	class:CommandRecvService	signature:()
CommandRecvService::send	command_recv_service.cpp	/^void CommandRecvService::send( const boost::asio::mutable_buffers_1 & buffer )$/;"	f	class:CommandRecvService	signature:( const boost::asio::mutable_buffers_1 & buffer )
CommandRecvService::send_packets_loop	command_recv_service.cpp	/^void CommandRecvService::send_packets_loop()$/;"	f	class:CommandRecvService	signature:()
CommandRecvService::sender_	command_recv_service.hpp	/^	datagram_protocol::endpoint sender_;$/;"	m	class:CommandRecvService	access:private
CommandRecvService::server_	command_recv_service.hpp	/^	datagram_protocol::endpoint server_;$/;"	m	class:CommandRecvService	access:private
CommandRecvService::sock_	command_recv_service.hpp	/^	datagram_protocol::socket sock_;$/;"	m	class:CommandRecvService	access:private
CommandRecvService::stop_io_service	command_recv_service.hpp	/^	void stop_io_service() { io_.stop(); }$/;"	f	class:CommandRecvService	access:public	signature:()
CommandWindow	comm_window.hpp	/^	explicit CommandWindow(int timeout = 100)$/;"	f	class:CommandWindow	access:public	signature:(int timeout = 100)
CommandWindow	comm_window.hpp	/^class CommandWindow : public command_window_base__$/;"	c	inherits:command_window_base__
CommandWindow::CommandWindow	comm_window.hpp	/^	explicit CommandWindow(int timeout = 100)$/;"	f	class:CommandWindow	access:public	signature:(int timeout = 100)
ConnectionBuilder	match_stream.cpp	/^ConnectionBuilder::ConnectionBuilder ( MatcherPtr m )$/;"	f	class:ConnectionBuilder	signature:( MatcherPtr m )
ConnectionBuilder	match_stream.hpp	/^class ConnectionBuilder : public StreamNode$/;"	c	inherits:StreamNode
ConnectionBuilder::ConnectionBuilder	match_stream.cpp	/^ConnectionBuilder::ConnectionBuilder ( MatcherPtr m )$/;"	f	class:ConnectionBuilder	signature:( MatcherPtr m )
ConnectionBuilder::built_	match_stream.hpp	/^	bool built_;$/;"	m	class:ConnectionBuilder	access:private
ConnectionBuilder::c_wait_	match_stream.hpp	/^	boost::condition c_wait_;$/;"	m	class:ConnectionBuilder	access:private
ConnectionBuilder::conn_task_	match_stream.cpp	/^std::map<endpoint, ConnectionBuilder *> ConnectionBuilder::conn_task_;$/;"	m	class:ConnectionBuilder	file:
ConnectionBuilder::conn_task_	match_stream.hpp	/^	static std::map<endpoint, ConnectionBuilder *> conn_task_;$/;"	m	class:ConnectionBuilder	access:private
ConnectionBuilder::dest_	match_stream.hpp	/^	const endpoint dest_;$/;"	m	class:ConnectionBuilder	access:private
ConnectionBuilder::do_build_connection	match_stream.cpp	/^void ConnectionBuilder::do_build_connection( const endpoint & dest )$/;"	f	class:ConnectionBuilder	signature:( const endpoint & dest )
ConnectionBuilder::do_end_task	match_stream.cpp	/^void ConnectionBuilder::do_end_task()$/;"	f	class:ConnectionBuilder	signature:()
ConnectionBuilder::do_run_task	match_stream.cpp	/^void ConnectionBuilder::do_run_task()$/;"	f	class:ConnectionBuilder	signature:()
ConnectionBuilder::get_build_task	match_stream.hpp	/^	static ConnectionBuilder * get_build_task(const endpoint & e )$/;"	f	class:ConnectionBuilder	access:public	signature:(const endpoint & e )
ConnectionBuilder::lock	match_stream.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:ConnectionBuilder	access:public
ConnectionBuilder::monitor_	match_stream.hpp	/^	boost::mutex monitor_;$/;"	m	class:ConnectionBuilder	access:private
ConnectionBuilder::num_timeout_	match_stream.hpp	/^	int num_timeout_;$/;"	m	class:ConnectionBuilder	access:private
ConnectionBuilder::pkt_	match_stream.hpp	/^	Packet pkt_;$/;"	m	class:ConnectionBuilder	access:private
ConnectionBuilder::set_built	match_stream.cpp	/^void ConnectionBuilder::set_built(bool b)$/;"	f	class:ConnectionBuilder	signature:(bool b)
ConnectionBuilder::~ConnectionBuilder	match_stream.cpp	/^ConnectionBuilder::~ConnectionBuilder()$/;"	f	class:ConnectionBuilder	signature:()
ConnectionBuilderService	connection_build_service.hpp	/^class ConnectionBuilderService$/;"	c
ConnectionBuilderService::c_wait_	connection_build_service.hpp	/^	boost::condition c_wait_;$/;"	m	class:ConnectionBuilderService	access:private
ConnectionBuilderService::connect_matcher	connection_build_service.cpp	/^void ConnectionBuilderService::connect_matcher( MatcherPtr m )$/;"	f	class:ConnectionBuilderService	signature:( MatcherPtr m )
ConnectionBuilderService::end	connection_build_service.cpp	/^bool ConnectionBuilderService::end()$/;"	f	class:ConnectionBuilderService	signature:()
ConnectionBuilderService::instance	connection_build_service.hpp	/^	static ConnectionBuilderService & instance()$/;"	f	class:ConnectionBuilderService	access:public	signature:()
ConnectionBuilderService::lock	connection_build_service.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:ConnectionBuilderService	access:public
ConnectionBuilderService::monitor_	connection_build_service.hpp	/^	boost::mutex monitor_;$/;"	m	class:ConnectionBuilderService	access:private
ConnectionBuilderService::notify_wait_matcher	connection_build_service.cpp	/^void ConnectionBuilderService::notify_wait_matcher()$/;"	f	class:ConnectionBuilderService	signature:()
ConnectionBuilderService::run	connection_build_service.cpp	/^void ConnectionBuilderService::run()$/;"	f	class:ConnectionBuilderService	signature:()
DCSP	command.hpp	/^namespace DCSP {$/;"	n
DCSP::MSG_ADD_NODES	command.hpp	/^	const unsigned MSG_ADD_NODES        = 0x00010010;$/;"	m	namespace:DCSP
DCSP::MSG_CREATE_DOMAIN	command.hpp	/^	const unsigned MSG_CREATE_DOMAIN    = 0x00010005;$/;"	m	namespace:DCSP
DCSP::MSG_DEL_NODES	command.hpp	/^	const unsigned MSG_DEL_NODES        = 0x00010011;$/;"	m	namespace:DCSP
DCSP::MSG_OMC_REQ	command.hpp	/^	const unsigned MSG_OMC_REQ          = 0x00010002;$/;"	m	namespace:DCSP
DCSP::MSG_QUERY_LOADS	command.hpp	/^	const unsigned MSG_QUERY_LOADS      = 0x00020042;$/;"	m	namespace:DCSP
DCSP::MSG_REPLY	command.hpp	/^	const unsigned MSG_REPLY            = 0x0001006F;$/;"	m	namespace:DCSP
DCSP::MSG_REPORT_LOADS	command.hpp	/^	const unsigned MSG_REPORT_LOADS     = 0x00020043;$/;"	m	namespace:DCSP
DCSP::MSG_TELL_LOADS	command.hpp	/^	const unsigned MSG_TELL_LOADS       = 0x00010024;$/;"	m	namespace:DCSP
DCSPPacket	command.hpp	/^struct DCSPPacket$/;"	s
DCSPPacket::do_hton	command.hpp	/^	void do_hton() {$/;"	f	struct:DCSPPacket	access:public	signature:()
DCSPPacket::do_ntoh	command.hpp	/^	void do_ntoh() {$/;"	f	struct:DCSPPacket	access:public	signature:()
DCSPPacket::msg	command.hpp	/^	u_char msg[1500];$/;"	m	struct:DCSPPacket	access:public
DCSPPacket::msg_id	command.hpp	/^	U32 msg_id;$/;"	m	struct:DCSPPacket	access:public
DCSPPacket::msg_len	command.hpp	/^	U16 msg_len;$/;"	m	struct:DCSPPacket	access:public
DCSPPacket::snk_id	command.hpp	/^	U32 snk_id;$/;"	m	struct:DCSPPacket	access:public
DCSPPacket::src_id	command.hpp	/^	U32 src_id;$/;"	m	struct:DCSPPacket	access:public
DCSPPacket::to_buffer	command.hpp	/^	const boost::asio::mutable_buffers_1 to_buffer()$/;"	f	struct:DCSPPacket	access:public	signature:()
DCSPTimeout	matcher_manager.hpp	/^	U16 DCSPTimeout;$/;"	m	struct:DomainInfo	access:public
DEBUG	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
DESC	newlib.h	/^	enum State { SYNC, NUM, DESC };$/;"	e	enum:VideoLibVec::State
DOMAIN__h	dcsp_fifo.h	2;"	d
DWord	bit_feature.h	/^	typedef unsigned long long DWord;	\/\/ 64 bit$/;"	t	class:BitFeature	access:public
DomainCreateCommand	command.cpp	/^DomainCreateCommand::DomainCreateCommand(DomainInfoPtr pd)$/;"	f	class:DomainCreateCommand	signature:(DomainInfoPtr pd)
DomainCreateCommand	command.hpp	/^class DomainCreateCommand : public ICommand$/;"	c	inherits:ICommand
DomainCreateCommand::DomainCreateCommand	command.cpp	/^DomainCreateCommand::DomainCreateCommand(DomainInfoPtr pd)$/;"	f	class:DomainCreateCommand	signature:(DomainInfoPtr pd)
DomainCreateCommand::domain_	command.hpp	/^	DomainInfoPtr domain_;$/;"	m	class:DomainCreateCommand	access:private
DomainCreateCommand::execute	command.cpp	/^void DomainCreateCommand::execute()$/;"	f	class:DomainCreateCommand	signature:()
DomainCreateCommand::reply	command.cpp	/^void DomainCreateCommand::reply()$/;"	f	class:DomainCreateCommand	signature:()
DomainId	matcher_manager.hpp	/^	U16 DomainId;$/;"	m	struct:AppId	access:public
DomainInfo	matcher_manager.hpp	/^struct DomainInfo$/;"	s
DomainInfo::ApplicationId	matcher_manager.hpp	/^	AppId ApplicationId;$/;"	m	struct:DomainInfo	access:public
DomainInfo::BalanceThreshold	matcher_manager.hpp	/^	U16 BalanceThreshold;$/;"	m	struct:DomainInfo	access:public
DomainInfo::BasicPower	matcher_manager.hpp	/^	U16 BasicPower;$/;"	m	struct:DomainInfo	access:public
DomainInfo::CommTimeout	matcher_manager.hpp	/^	U16 CommTimeout;$/;"	m	struct:DomainInfo	access:public
DomainInfo::DCSPTimeout	matcher_manager.hpp	/^	U16 DCSPTimeout;$/;"	m	struct:DomainInfo	access:public
DomainInfo::HighLoadThreshold	matcher_manager.hpp	/^	U32 HighLoadThreshold;$/;"	m	struct:DomainInfo	access:public
DomainInfo::LeftNeighborId	matcher_manager.hpp	/^	U32 LeftNeighborId;$/;"	m	struct:DomainInfo	access:public
DomainInfo::LibId	matcher_manager.hpp	/^	U16 LibId;$/;"	m	struct:DomainInfo	access:public
DomainInfo::LoadBalanceId	matcher_manager.hpp	/^	U32 LoadBalanceId;$/;"	m	struct:DomainInfo	access:public
DomainInfo::LowLoadThreshold	matcher_manager.hpp	/^	U16 LowLoadThreshold;$/;"	m	struct:DomainInfo	access:public
DomainInfo::MatchThreshold	matcher_manager.hpp	/^	U08 MatchThreshold;$/;"	m	struct:DomainInfo	access:public
DomainInfo::MergeThreshold	matcher_manager.hpp	/^	U08 MergeThreshold;$/;"	m	struct:DomainInfo	access:public
DomainInfo::MergeUnit	matcher_manager.hpp	/^	U08 MergeUnit;$/;"	m	struct:DomainInfo	access:public
DomainInfo::MonitorId	matcher_manager.hpp	/^	U32 MonitorId;$/;"	m	struct:DomainInfo	access:public
DomainInfo::NBits	matcher_manager.hpp	/^	U08 NBits;$/;"	m	struct:DomainInfo	access:public
DomainInfo::NodeFrequency	matcher_manager.hpp	/^	U16 NodeFrequency;$/;"	m	struct:DomainInfo	access:public
DomainInfo::NodeVersion	matcher_manager.hpp	/^	U16 NodeVersion;$/;"	m	struct:DomainInfo	access:public
DomainInfo::NumTotalPipe	matcher_manager.hpp	/^	U08 NumTotalPipe;$/;"	m	struct:DomainInfo	access:public
DomainInfo::OutputTimeout	matcher_manager.hpp	/^	U08 OutputTimeout;$/;"	m	struct:DomainInfo	access:public
DomainInfo::PacketIndex	matcher_manager.hpp	/^	U08 PacketIndex;$/;"	m	struct:DomainInfo	access:public
DomainInfo::PacketLength	matcher_manager.hpp	/^	U16 PacketLength;$/;"	m	struct:DomainInfo	access:public
DomainInfo::PacketType	matcher_manager.hpp	/^	U08 PacketType;$/;"	m	struct:DomainInfo	access:public
DomainInfo::PowerPerPipe	matcher_manager.hpp	/^	U08 PowerPerPipe;$/;"	m	struct:DomainInfo	access:public
DomainInfo::PresentationId	matcher_manager.hpp	/^	U32 PresentationId;$/;"	m	struct:DomainInfo	access:public
DomainInfo::ReMergeThrehold	matcher_manager.hpp	/^	U08 ReMergeThrehold;$/;"	m	struct:DomainInfo	access:public
DomainInfo::ReportCycle	matcher_manager.hpp	/^	U08 ReportCycle;$/;"	m	struct:DomainInfo	access:public
DomainInfo::RightNeighborId	matcher_manager.hpp	/^	U32 RightNeighborId;$/;"	m	struct:DomainInfo	access:public
DomainInfo::SliceLen	matcher_manager.hpp	/^	U08 SliceLen;$/;"	m	struct:DomainInfo	access:public
DomainInfo::SpeedPerPipe	matcher_manager.hpp	/^	U32 SpeedPerPipe;$/;"	m	struct:DomainInfo	access:public
DomainInfo::StructInfo	matcher_manager.hpp	/^	U16 StructInfo;$/;"	m	struct:DomainInfo	access:public
DomainInfo::TerminalId	matcher_manager.hpp	/^	U32 TerminalId;$/;"	m	struct:DomainInfo	access:public
DomainInfo::add_domain	matcher_manager.hpp	/^	static bool add_domain(DomainInfoPtr pd)$/;"	f	struct:DomainInfo	access:public	signature:(DomainInfoPtr pd)
DomainInfo::domains	matcher_manager.hpp	/^	static DomainMap domains;	\/\/ public$/;"	m	struct:DomainInfo	access:public
DomainInfo::find_domain_by_id	matcher_manager.hpp	/^	static DomainInfoPtr find_domain_by_id(DomainType id)$/;"	f	struct:DomainInfo	access:public	signature:(DomainType id)
DomainInfo::make_domain	matcher_manager.hpp	/^	static DomainInfoPtr make_domain(char * pc)$/;"	f	struct:DomainInfo	access:public	signature:(char * pc)
DomainInfoPtr	matcher_manager.hpp	/^typedef boost::shared_ptr<DomainInfo> DomainInfoPtr;$/;"	t
DomainMap	matcher_manager.hpp	/^typedef std::map<DomainType, DomainInfoPtr> DomainMap;$/;"	t
DomainType	matcher_manager.hpp	/^typedef AppId DomainType;$/;"	t
EDist	ipoint.h	/^struct EDist {		\/\/ Euclidean distance$/;"	s
EDist::operator ()	ipoint.h	/^	float operator () (const Ipoint& lhs, const I& rhs) const {$/;"	f	struct:EDist	access:public	signature:(const Ipoint& lhs, const I& rhs) const
EDist::threshold	ipoint.h	/^	float threshold() const { return 0.42; }$/;"	f	struct:EDist	access:public	signature:() const
END_KEY	match_analyser.cpp	/^static const unsigned int END_KEY = 0xFFFFFFFF;$/;"	v	file:
ERR	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
ETH_MAX_LEN	packet.hpp	/^	ETH_MAX_LEN  = 1514,$/;"	e	enum:__anon9
ETH_MIN_LEN	packet.hpp	/^	ETH_MIN_LEN  = 60,$/;"	e	enum:__anon9
EXCEPTION_HANDLE	main.cpp	6;"	d	file:
EXTRACT_END	comm_para.hpp	/^	const u_char      EXTRACT_END         = 0x2C;$/;"	m	namespace:__anon4
EXTRACT_RECVING	comm_para.hpp	/^	const u_char      EXTRACT_RECVING     = 0x0C;$/;"	m	namespace:__anon4
EnumStringMap	fdutils.h	/^	explicit EnumStringMap(const SA& st, E default_value = (E)0)$/;"	f	class:EnumStringMap	access:public	signature:(const SA& st, E default_value = (E)0)
EnumStringMap	fdutils.h	/^class EnumStringMap {$/;"	c
EnumStringMap::EnumStringMap	fdutils.h	/^	explicit EnumStringMap(const SA& st, E default_value = (E)0)$/;"	f	class:EnumStringMap	access:public	signature:(const SA& st, E default_value = (E)0)
EnumStringMap::_def	fdutils.h	/^	const E   _def;$/;"	m	class:EnumStringMap	access:private
EnumStringMap::_size	fdutils.h	/^	const int _size;$/;"	m	class:EnumStringMap	access:private
EnumStringMap::_str_table	fdutils.h	/^	const char * const * _str_table;$/;"	m	class:EnumStringMap	access:private
EnumStringMap::getEnum	fdutils.h	/^	E getEnum(const string& str) const {$/;"	f	class:EnumStringMap	access:public	signature:(const string& str) const
EnumStringMap::getString	fdutils.h	/^	const char* getString(E val) const {$/;"	f	class:EnumStringMap	access:public	signature:(E val) const
EnumStringMap::readEnum	fdutils.h	/^	E readEnum(std::istream& s) const {$/;"	f	class:EnumStringMap	access:public	signature:(std::istream& s) const
EnumStringMap::writeEnum	fdutils.h	/^	std::ostream& writeEnum(std::ostream& s, E val) { return s << getString(val); }$/;"	f	class:EnumStringMap	access:public	signature:(std::ostream& s, E val)
FAIL_CONNECT	matcher_manager.hpp	/^		FAIL_CONNECT,					\/\/<! fail connect$/;"	e	enum:Matcher::MATCHER_STATE
FDU_DEBUG	log.h	90;"	d
FDU_LOG	log.h	78;"	d
FDU_LOGGING_H_	log.h	2;"	d
FDU_LOGV	log.h	79;"	d
FILLWORD	newlib.h	13;"	d
FUDANFPGA_UTILS_H_	fdutils.h	2;"	d
GrayImage	integral.h	/^	GrayImage() {}$/;"	f	class:GrayImage	access:public	signature:()
GrayImage	integral.h	/^	GrayImage(const IplImage* img) { init(img); }$/;"	f	class:GrayImage	access:public	signature:(const IplImage* img)
GrayImage	integral.h	/^	GrayImage(const char* file_name) { load(file_name); }$/;"	f	class:GrayImage	access:public	signature:(const char* file_name)
GrayImage	integral.h	/^class GrayImage : public Image<unsigned char> {$/;"	c	inherits:Image
GrayImage::GrayImage	integral.h	/^	GrayImage() {}$/;"	f	class:GrayImage	access:public	signature:()
GrayImage::GrayImage	integral.h	/^	GrayImage(const IplImage* img) { init(img); }$/;"	f	class:GrayImage	access:public	signature:(const IplImage* img)
GrayImage::GrayImage	integral.h	/^	GrayImage(const char* file_name) { load(file_name); }$/;"	f	class:GrayImage	access:public	signature:(const char* file_name)
GrayImage::init	integral.cpp	/^void GrayImage::init(const IplImage* img) {$/;"	f	class:GrayImage	signature:(const IplImage* img)
GrayImage::load	integral.cpp	/^void GrayImage::load(const char* file_name) {$/;"	f	class:GrayImage	signature:(const char* file_name)
HighLoadThreshold	matcher_manager.hpp	/^	U32 HighLoadThreshold;$/;"	m	struct:DomainInfo	access:public
ICommand	command.hpp	/^class ICommand$/;"	c
ICommand::reply	command.cpp	/^void ICommand::reply(unsigned msg_key)$/;"	f	class:ICommand	signature:(unsigned msg_key)
ICommand::unsigned_to_string	command.cpp	/^const std::string ICommand::unsigned_to_string(unsigned ip)$/;"	f	class:ICommand	signature:(unsigned ip)
IMG_ALL_END	comm_para.hpp	/^	const u_char      IMG_ALL_END         = 0x66;$/;"	m	namespace:__anon4
IMG_END	comm_para.hpp	/^	const u_char      IMG_END             = 0x26;$/;"	m	namespace:__anon4
IMG_SENDING	comm_para.hpp	/^	const u_char      IMG_SENDING         = 0x06;$/;"	m	namespace:__anon4
IMG_START	comm_para.hpp	/^	const u_char      IMG_START           = 0x16;$/;"	m	namespace:__anon4
INFINITE_CAPACITY	comm_box.hpp	/^const std::size_t INFINITE_CAPACITY = std::size_t(-1);$/;"	v
INFO	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
INTEGRAL_H	integral.h	13;"	d
INTSCALE	integral.h	/^static const int INTSCALE = 256;$/;"	v
INVALID_MATCHER_STATE	matcher_manager.hpp	/^		INVALID_MATCHER_STATE = -2,		\/\/<! invalid state$/;"	e	enum:Matcher::MATCHER_STATE
IPOINT_H	ipoint.h	13;"	d
Image	integral.h	/^	Image() : width_(0), height_(0), data_(0) {}$/;"	f	class:Image	access:public	signature:()
Image	integral.h	/^	Image(int w, int h) : width_(w), height_(h), data_(new T[w*h]) {}$/;"	f	class:Image	access:public	signature:(int w, int h)
Image	integral.h	/^template<typename T> class Image {$/;"	c
Image::Image	integral.h	/^	Image() : width_(0), height_(0), data_(0) {}$/;"	f	class:Image	access:public	signature:()
Image::Image	integral.h	/^	Image(int w, int h) : width_(w), height_(h), data_(new T[w*h]) {}$/;"	f	class:Image	access:public	signature:(int w, int h)
Image::data_	integral.h	/^	T*  data_;              \/\/ Pointer to image data$/;"	m	class:Image	access:protected
Image::height	integral.h	/^	int height() const { return height_; }$/;"	f	class:Image	access:public	signature:() const
Image::height_	integral.h	/^	int height_;            \/\/ Image height in pixels$/;"	m	class:Image	access:private
Image::operator !	integral.h	/^	bool operator!() const { return size() == 0;  }		\/\/ test image validation$/;"	f	class:Image	access:public	signature:() const
Image::operator ()	integral.h	/^	T  operator()(int row, int col) const { return pixel(row, col); }	\/\/ get the pixel$/;"	f	class:Image	access:public	signature:(int row, int col) const
Image::operator ()	integral.h	/^	T& operator()(int row, int col)       { return pixel(row, col); }	\/\/ get\/set the pixel$/;"	f	class:Image	access:public	signature:(int row, int col)
Image::pixel	integral.h	/^	T  pixel(int row, int col) const { return data_[row * width_ + col]; }	\/\/ get the pixel$/;"	f	class:Image	access:protected	signature:(int row, int col) const
Image::pixel	integral.h	/^	T& pixel(int row, int col)       { return data_[row * width_ + col]; }	\/\/ get\/set the pixel$/;"	f	class:Image	access:protected	signature:(int row, int col)
Image::reset	integral.h	/^	void reset(int w, int h) { width_ = w; height_ = h; delete[] data_; data_ = new T[w*h]; }$/;"	f	class:Image	access:public	signature:(int w, int h)
Image::size	integral.h	/^	int size()   const { return width_ * height_; }$/;"	f	class:Image	access:public	signature:() const
Image::width	integral.h	/^	int width()  const { return width_;  }$/;"	f	class:Image	access:public	signature:() const
Image::width_	integral.h	/^	int width_;             \/\/ Image width in pixels$/;"	m	class:Image	access:private
Image::~Image	integral.h	/^	~Image() { delete[] data_; }$/;"	f	class:Image	access:public	signature:()
IntImage	integral.h	/^	IntImage() {}$/;"	f	struct:IntImage	access:public	signature:()
IntImage	integral.h	/^	IntImage(const GrayImage& src) { init(src); }$/;"	f	struct:IntImage	access:public	signature:(const GrayImage& src)
IntImage	integral.h	/^struct IntImage : Image<int> {				\/\/ Integral image$/;"	s	inherits:Image
IntImage::BoxIntegral	integral.h	/^	int BoxIntegral(int row, int col, int rows, int cols) const {$/;"	f	struct:IntImage	access:public	signature:(int row, int col, int rows, int cols) const
IntImage::IntImage	integral.h	/^	IntImage() {}$/;"	f	struct:IntImage	access:public	signature:()
IntImage::IntImage	integral.h	/^	IntImage(const GrayImage& src) { init(src); }$/;"	f	struct:IntImage	access:public	signature:(const GrayImage& src)
IntImage::at	integral.h	/^	int at(int r, int c) const {	\/\/ get the pixel with bound check$/;"	f	struct:IntImage	access:public	signature:(int r, int c) const
IntImage::init	integral.cpp	/^void IntImage::init(const GrayImage& img) {$/;"	f	class:IntImage	signature:(const GrayImage& img)
IpVec	ipoint.h	/^typedef std::vector<Ipoint> IpVec;$/;"	t
IpVec2	ipoint.h	/^	typedef std::vector<I> IpVec2;$/;"	t	class:Matches	access:public
IplImage	integral.h	/^typedef struct _IplImage IplImage;$/;"	t	typeref:struct:_IplImage
IplImage	utils.h	/^typedef struct _IplImage IplImage;$/;"	t	typeref:struct:_IplImage
Ipoint	ipoint.h	/^	Ipoint() : orientation(0), clusterIndex(0), match(0) {};$/;"	f	struct:Ipoint	access:public	signature:()
Ipoint	ipoint.h	/^	Ipoint(float xx, float yy, float ss, int ll)$/;"	f	struct:Ipoint	access:public	signature:(float xx, float yy, float ss, int ll)
Ipoint	ipoint.h	/^struct Ipoint {$/;"	s
Ipoint::Ipoint	ipoint.h	/^	Ipoint() : orientation(0), clusterIndex(0), match(0) {};$/;"	f	struct:Ipoint	access:public	signature:()
Ipoint::Ipoint	ipoint.h	/^	Ipoint(float xx, float yy, float ss, int ll)$/;"	f	struct:Ipoint	access:public	signature:(float xx, float yy, float ss, int ll)
Ipoint::clusterIndex	ipoint.h	/^	int clusterIndex;		\/\/! Used to store cluster index$/;"	m	struct:Ipoint	access:public
Ipoint::cos_ori	ipoint.h	/^	float sin_ori, cos_ori;	\/\/! sin(orientation) and cos(orientation)$/;"	m	struct:Ipoint	access:public
Ipoint::descriptor	ipoint.h	/^	float descriptor[64];	\/\/! Vector of descriptor components$/;"	m	struct:Ipoint	access:public
Ipoint::dx	ipoint.h	/^	float dx, dy;			\/\/! Placeholders for point motion$/;"	m	struct:Ipoint	access:public
Ipoint::dy	ipoint.h	/^	float dx, dy;			\/\/! Placeholders for point motion$/;"	m	struct:Ipoint	access:public
Ipoint::laplacian	ipoint.h	/^	int laplacian;			\/\/! Sign of laplacian for fast matching purposes$/;"	m	struct:Ipoint	access:public
Ipoint::match	ipoint.h	/^	const void* match;		\/\/! matched ipoint$/;"	m	struct:Ipoint	access:public
Ipoint::orientation	ipoint.h	/^	float orientation;		\/\/! Orientation measured anti-clockwise from +ve x-axis$/;"	m	struct:Ipoint	access:public
Ipoint::scale	ipoint.h	/^	float scale;			\/\/! Detected scale$/;"	m	struct:Ipoint	access:public
Ipoint::sin_ori	ipoint.h	/^	float sin_ori, cos_ori;	\/\/! sin(orientation) and cos(orientation)$/;"	m	struct:Ipoint	access:public
Ipoint::x	ipoint.h	/^	float x, y;				\/\/! Coordinates of the detected interest point$/;"	m	struct:Ipoint	access:public
Ipoint::y	ipoint.h	/^	float x, y;				\/\/! Coordinates of the detected interest point$/;"	m	struct:Ipoint	access:public
LIB_END	comm_para.hpp	/^	const u_char      LIB_END             = 0x22;$/;"	m	namespace:__anon4
LIB_LOADING	matcher_manager.hpp	/^		LIB_LOADING,					\/\/<! lib loading$/;"	e	enum:Matcher::MATCHER_STATE
LIB_LOAD_SERVICE_HPP	lib_load_service.hpp	2;"	d
LIB_SENDING	comm_para.hpp	/^	const u_char      LIB_SENDING         = 0x02;$/;"	m	namespace:__anon4
LIB_START	comm_para.hpp	/^	const u_char      LIB_START           = 0x12;$/;"	m	namespace:__anon4
LOG	log.cpp	/^namespace LOG {$/;"	n	file:
LOG	log.h	/^namespace LOG {$/;"	n
LOG::DEBUG	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
LOG::ERR	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
LOG::INFO	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
LOG::Log	log.h	/^	class Log : boost::noncopyable {$/;"	c	namespace:LOG	inherits:boost::noncopyable
LOG::Log::Log	log.cpp	/^Log::Log() : core_(logging::core::get()) {$/;"	f	class:LOG::Log	signature:()
LOG::Log::con_sink	log.h	/^		sp_stream_sink con_sink()  { return sink_con_;  }$/;"	f	class:LOG::Log	access:public	signature:()
LOG::Log::core_	log.h	/^		sp_log_core    core_;$/;"	m	class:LOG::Log	access:private
LOG::Log::file_sink	log.h	/^		sp_file_sink   file_sink() { return sink_file_; }$/;"	f	class:LOG::Log	access:public	signature:()
LOG::Log::get	log.cpp	/^Log& Log::get() {$/;"	f	class:LOG::Log	signature:()
LOG::Log::init_log_file	log.cpp	/^void Log::init_log_file(const std::string& log_file, const std::string& prog_name) {$/;"	f	class:LOG::Log	signature:(const std::string& log_file, const std::string& prog_name)
LOG::Log::logger	log.h	/^		sev_logger&    logger()    { return slg_;       }$/;"	f	class:LOG::Log	access:public	signature:()
LOG::Log::sink_con_	log.h	/^		sp_stream_sink sink_con_;$/;"	m	class:LOG::Log	access:private
LOG::Log::sink_file_	log.h	/^		sp_file_sink   sink_file_;$/;"	m	class:LOG::Log	access:private
LOG::Log::slg_	log.h	/^		sev_logger     slg_;$/;"	m	class:LOG::Log	access:private
LOG::VERBOSE	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
LOG::WARN	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
LOG::get_logger	log.h	/^	inline sev_logger& get_logger() { return Log::get().logger(); }$/;"	f	namespace:LOG	signature:()
LOG::init_log_file	log.h	/^	inline void init_log_file(const std::string& log_file, const std::string& prog_name = "")$/;"	f	namespace:LOG	signature:(const std::string& log_file, const std::string& prog_name = ”)
LOG::operator <<	log.cpp	/^std::ostream& operator << (std::ostream& s, severity_level level) { return levelmap.writeEnum(s, level); }$/;"	f	namespace:LOG	signature:(std::ostream& s, severity_level level)
LOG::set_console_filter	log.h	/^	template<typename F> inline void set_console_filter(F const& flt)$/;"	f	namespace:LOG	signature:(F const& flt)
LOG::set_console_format	log.h	/^	template<typename F> inline void set_console_format(F const& fmt)$/;"	f	namespace:LOG	signature:(F const& fmt)
LOG::set_file_filter	log.h	/^	template<typename F> inline void set_file_filter(F const& flt)$/;"	f	namespace:LOG	signature:(F const& flt)
LOG::set_file_format	log.h	/^	template<typename F> inline void set_file_format(F const& fmt)$/;"	f	namespace:LOG	signature:(F const& fmt)
LOG::set_filter	log.h	/^	template<typename SP, typename FLT> inline void set_filter(SP sink, FLT const& flt)$/;"	f	namespace:LOG	signature:(SP sink, FLT const& flt)
LOG::set_format	log.h	/^	template<typename SP, typename FMT> inline void set_format(SP sink, FMT const& fmt)$/;"	f	namespace:LOG	signature:(SP sink, FMT const& fmt)
LOG::sev_levels	log.cpp	/^static const char* sev_levels[] = { "DEBUG", "VERBOSE", "INFO ", "WARN ", "ERROR" };$/;"	m	namespace:LOG	file:
LOG::sev_logger	log.h	/^	typedef src::severity_logger<severity_level> sev_logger;$/;"	t	namespace:LOG
LOG::severity_level	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	g	namespace:LOG
LOG::sp_file_sink	log.h	/^	typedef boost::shared_ptr<sinks::synchronous_sink<sinks::text_file_backend> >    sp_file_sink;$/;"	t	namespace:LOG
LOG::sp_log_core	log.h	/^	typedef boost::shared_ptr<logging::core>     sp_log_core;$/;"	t	namespace:LOG
LOG::sp_stream_sink	log.h	/^	typedef boost::shared_ptr<sinks::synchronous_sink<sinks::text_ostream_backend> > sp_stream_sink;$/;"	t	namespace:LOG
LeftNeighborId	matcher_manager.hpp	/^	U32 LeftNeighborId;$/;"	m	struct:DomainInfo	access:public
LibId	matcher_manager.hpp	/^	U16 LibId;$/;"	m	struct:DomainInfo	access:public
LibIpVec	ipoint.h	/^typedef std::vector<LibIpt> LibIpVec;$/;"	t
LibIpt	ipoint.h	/^struct LibIpt {				\/\/ Simplified ipoint for surf library$/;"	s
LibIpt::descriptor	ipoint.h	/^	float descriptor[64];	\/\/! Vector of descriptor components$/;"	m	struct:LibIpt	access:public
LibLoadService	lib_load_service.cpp	/^LibLoadService::LibLoadService()$/;"	f	class:LibLoadService	signature:()
LibLoadService	lib_load_service.cpp	/^LibLoadService::LibLoadService(const LibLoadService & l)$/;"	f	class:LibLoadService	signature:(const LibLoadService & l)
LibLoadService	lib_load_service.hpp	/^class LibLoadService$/;"	c
LibLoadService::AppId	lib_load_service.hpp	/^	typedef DomainType AppId;$/;"	t	class:LibLoadService	access:public
LibLoadService::LibLoadService	lib_load_service.cpp	/^LibLoadService::LibLoadService()$/;"	f	class:LibLoadService	signature:()
LibLoadService::LibLoadService	lib_load_service.cpp	/^LibLoadService::LibLoadService(const LibLoadService & l)$/;"	f	class:LibLoadService	signature:(const LibLoadService & l)
LibLoadService::LibMap	lib_load_service.hpp	/^	typedef std::map<DomainType, VideoLibVec> LibMap;$/;"	t	class:LibLoadService	access:public
LibLoadService::c_wait_	lib_load_service.hpp	/^	boost::condition c_wait_;$/;"	m	class:LibLoadService	access:private
LibLoadService::end	lib_load_service.cpp	/^bool LibLoadService::end()$/;"	f	class:LibLoadService	signature:()
LibLoadService::instance	lib_load_service.hpp	/^	static LibLoadService & instance()$/;"	f	class:LibLoadService	access:public	signature:()
LibLoadService::lib_valid_	lib_load_service.hpp	/^	bool lib_valid_;$/;"	m	class:LibLoadService	access:private
LibLoadService::libmap_	lib_load_service.hpp	/^	LibMap libmap_;$/;"	m	class:LibLoadService	access:private
LibLoadService::load_domain_lib_to_mem	lib_load_service.cpp	/^void LibLoadService::load_domain_lib_to_mem(DomainType d)$/;"	f	class:LibLoadService	signature:(DomainType d)
LibLoadService::load_lib_to_matcher	lib_load_service.cpp	/^void LibLoadService::load_lib_to_matcher( MatcherPtr m, const VideoLibVec & lib )$/;"	f	class:LibLoadService	signature:( MatcherPtr m, const VideoLibVec & lib )
LibLoadService::load_lib_to_mem	lib_load_service.cpp	/^void LibLoadService::load_lib_to_mem(const std::string & path, VideoLibVec & lib)$/;"	f	class:LibLoadService	signature:(const std::string & path, VideoLibVec & lib)
LibLoadService::lock	lib_load_service.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:LibLoadService	access:public
LibLoadService::monitor_	lib_load_service.hpp	/^	boost::mutex monitor_;$/;"	m	class:LibLoadService	access:private
LibLoadService::notify_wait_matcher	lib_load_service.cpp	/^void LibLoadService::notify_wait_matcher()$/;"	f	class:LibLoadService	signature:()
LibLoadService::run	lib_load_service.cpp	/^void LibLoadService::run()$/;"	f	class:LibLoadService	signature:()
LibMap	lib_load_service.hpp	/^	typedef std::map<DomainType, VideoLibVec> LibMap;$/;"	t	class:LibLoadService	access:public
LibPointVec	newlib.h	/^typedef std::vector<BitFeature> LibPointVec;$/;"	t
LoadBalanceId	matcher_manager.hpp	/^	U32 LoadBalanceId;$/;"	m	struct:DomainInfo	access:public
Log	log.cpp	/^Log::Log() : core_(logging::core::get()) {$/;"	f	class:LOG::Log	signature:()
Log	log.h	/^	class Log : boost::noncopyable {$/;"	c	namespace:LOG	inherits:boost::noncopyable
LowLoadThreshold	matcher_manager.hpp	/^	U16 LowLoadThreshold;$/;"	m	struct:DomainInfo	access:public
MASK	bits.hpp	/^	static const unsigned char MASK = 0x07;$/;"	m	struct:bits	access:public
MATCHER_MANAGER_HPP	matcher_manager.hpp	2;"	d
MATCHER_STATE	matcher_manager.hpp	/^	enum MATCHER_STATE {$/;"	g	class:Matcher	access:public
MATCH_ANALYSER	match_analyser.hpp	2;"	d
MATCH_CHAIN_HPP	match_stream.hpp	20;"	d
MATCH_END	comm_para.hpp	/^	const u_char      MATCH_END           = 0x28;$/;"	m	namespace:__anon4
MATCH_RECVING	comm_para.hpp	/^	const u_char      MATCH_RECVING       = 0x08;$/;"	m	namespace:__anon4
MATCH_UTILS_HPP	match_utils.h	2;"	d
MATCH_WIDTH	comm_para.hpp	/^	const int         MATCH_WIDTH         = 128;$/;"	m	namespace:__anon4
MAX_FEATURE_BITS	bit_feature.h	12;"	d
MDist	ipoint.h	/^struct MDist {		\/\/ Manhattan distance$/;"	s
MDist::operator ()	ipoint.h	/^	float operator () (const Ipoint& lhs, const I& rhs) const {$/;"	f	struct:MDist	access:public	signature:(const Ipoint& lhs, const I& rhs) const
MDist::threshold	ipoint.h	/^	float threshold() const { return 0.6; }$/;"	f	struct:MDist	access:public	signature:() const
MIN_FEATURE_BITS	bit_feature.h	11;"	d
MSG_ADD_NODES	command.hpp	/^	const unsigned MSG_ADD_NODES        = 0x00010010;$/;"	m	namespace:DCSP
MSG_CREATE_DOMAIN	command.hpp	/^	const unsigned MSG_CREATE_DOMAIN    = 0x00010005;$/;"	m	namespace:DCSP
MSG_DEL_NODES	command.hpp	/^	const unsigned MSG_DEL_NODES        = 0x00010011;$/;"	m	namespace:DCSP
MSG_OMC_REQ	command.hpp	/^	const unsigned MSG_OMC_REQ          = 0x00010002;$/;"	m	namespace:DCSP
MSG_QUERY_LOADS	command.hpp	/^	const unsigned MSG_QUERY_LOADS      = 0x00020042;$/;"	m	namespace:DCSP
MSG_REPLY	command.hpp	/^	const unsigned MSG_REPLY            = 0x0001006F;$/;"	m	namespace:DCSP
MSG_REPORT_LOADS	command.hpp	/^	const unsigned MSG_REPORT_LOADS     = 0x00020043;$/;"	m	namespace:DCSP
MSG_SHOW_APP_RESULT	command_recv_service.cpp	/^const unsigned MSG_SHOW_APP_RESULT = 0x00000070;$/;"	v
MSG_TELL_LOADS	command.hpp	/^	const unsigned MSG_TELL_LOADS       = 0x00010024;$/;"	m	namespace:DCSP
MatchAnalyser	match_analyser.hpp	/^	MatchAnalyser () {}$/;"	f	class:MatchAnalyser	access:private	signature:()
MatchAnalyser	match_analyser.hpp	/^class MatchAnalyser$/;"	c
MatchAnalyser::MatchAnalyser	match_analyser.hpp	/^	MatchAnalyser () {}$/;"	f	class:MatchAnalyser	access:private	signature:()
MatchAnalyser::handle_packet	match_analyser.cpp	/^void MatchAnalyser::handle_packet( Packet & pkt, const udp::endpoint & from_addr )$/;"	f	class:MatchAnalyser	signature:( Packet & pkt, const udp::endpoint & from_addr )
MatchAnalyser::instance	match_analyser.hpp	/^	static MatchAnalyser & instance() {$/;"	f	class:MatchAnalyser	access:public	signature:()
MatchAnalyser::output_result	match_analyser.cpp	/^void MatchAnalyser::output_result(std::ostream & out)$/;"	f	class:MatchAnalyser	signature:(std::ostream & out)
MatchAnalyser::sec_man_	match_analyser.hpp	/^	SectionManager sec_man_;$/;"	m	class:MatchAnalyser	access:private
MatchArgs	match_utils.h	/^struct MatchArgs {$/;"	s
MatchArgs::batch_len	match_utils.h	/^	int batch_len;			\/\/ √ø◊È∆•≈‰÷° ˝$/;"	m	struct:MatchArgs	access:public
MatchArgs::diag_test_thres	match_utils.h	/^	int diag_test_thres;	\/\/ √ø◊È∆•≈‰Ω·π˚≈–∂œ„–÷µ$/;"	m	struct:MatchArgs	access:public
MatchArgs::feature_bits	match_utils.h	/^	int feature_bits;		\/\/ Ãÿ’˜æ´∂»$/;"	m	struct:MatchArgs	access:public
MatchArgs::frame_thres	match_utils.h	/^	int frame_thres;		\/\/ µ•÷°∆•≈‰„–÷µ$/;"	m	struct:MatchArgs	access:public
MatchArgs::load	match_utils.cpp	/^void MatchArgs::load(const string& arg_file) {$/;"	f	class:MatchArgs	signature:(const string& arg_file)
MatchArgs::min_match_len	match_utils.h	/^	int min_match_len;		\/\/ ◊Ó–°¡¨–¯∆•≈‰÷° ˝„–÷µ$/;"	m	struct:MatchArgs	access:public
MatchArgs::overlap_len	match_utils.h	/^	int overlap_len;		\/\/ œ‡¡⁄¡Ω◊Èº‰÷ÿµ˛÷° ˝$/;"	m	struct:MatchArgs	access:public
MatchArgs::set_accuracy	match_utils.cpp	/^void MatchArgs::set_accuracy(int a) {$/;"	f	class:MatchArgs	signature:(int a)
MatchArgs::set_converge	match_utils.cpp	/^void MatchArgs::set_converge(int c) {$/;"	f	class:MatchArgs	signature:(int c)
MatchArgs::slice_len	match_utils.h	/^	int slice_len;			\/\/ ‘Ÿæ€∫œ ”∆µ≥§∂»$/;"	m	struct:MatchArgs	access:public
MatchArgs::slice_thres	match_utils.h	/^	int slice_thres;		\/\/ ‘Ÿæ€∫œ„–÷µ$/;"	m	struct:MatchArgs	access:public
MatchResult	match_utils.h	/^typedef std::pair<int, int> MatchResult;		\/\/ ºÚªØµƒ∆•≈‰Ω·π˚£∫(¥˝≤‚ ”∆µ±‡∫≈, ø‚ ”∆µ±‡∫≈)$/;"	t
MatchResults	match_utils.h	/^typedef std::set<MatchResult> MatchResults;$/;"	t
MatchSection	match_utils.h	/^	MatchSection(int tb = 0, int lb = 0, int ln = 0) :$/;"	f	struct:MatchSection	access:public	signature:(int tb = 0, int lb = 0, int ln = 0)
MatchSection	match_utils.h	/^struct MatchSection {$/;"	s
MatchSection::MatchSection	match_utils.h	/^	MatchSection(int tb = 0, int lb = 0, int ln = 0) :$/;"	f	struct:MatchSection	access:public	signature:(int tb = 0, int lb = 0, int ln = 0)
MatchSection::len	match_utils.h	/^	int len;$/;"	m	struct:MatchSection	access:public
MatchSection::lib_begin	match_utils.h	/^	int test_begin, lib_begin;$/;"	m	struct:MatchSection	access:public
MatchSection::lib_id	match_utils.h	/^	int lib_id()   const { return (lib_begin >> 16) & 0xffff;  }$/;"	f	struct:MatchSection	access:public	signature:() const
MatchSection::lib_pos	match_utils.h	/^	int lib_pos()  const { return lib_begin  & 0xffff; }$/;"	f	struct:MatchSection	access:public	signature:() const
MatchSection::merge	match_utils.cpp	/^void MatchSection::merge(const MatchSection& rhs) {$/;"	f	class:MatchSection	signature:(const MatchSection& rhs)
MatchSection::offset_id	match_utils.h	/^	long long offset_id()  const {$/;"	f	struct:MatchSection	access:public	signature:() const
MatchSection::slice_id	match_utils.h	/^	int slice_id() const { return test_id()  & 0x3ff; }$/;"	f	struct:MatchSection	access:public	signature:() const
MatchSection::test_begin	match_utils.h	/^	int test_begin, lib_begin;$/;"	m	struct:MatchSection	access:public
MatchSection::test_id	match_utils.h	/^	int test_id()  const { return (test_begin >> 12) & 0xfffff; }	\/\/ ∫¨ ”∆µ∫≈∫Õ∆¨∂Œ∫≈$/;"	f	struct:MatchSection	access:public	signature:() const
MatchSection::test_pos	match_utils.h	/^	int test_pos() const { return test_begin & 0xfff;  }$/;"	f	struct:MatchSection	access:public	signature:() const
MatchSection::video_id	match_utils.h	/^	int video_id() const { return test_id()  >> 10; }$/;"	f	struct:MatchSection	access:public	signature:() const
MatchThreshold	matcher_manager.hpp	/^	U08 MatchThreshold;$/;"	m	struct:DomainInfo	access:public
Matcher	matcher_manager.cpp	/^Matcher::Matcher ( const endpoint_type & e )$/;"	f	class:Matcher	signature:( const endpoint_type & e )
Matcher	matcher_manager.cpp	/^Matcher::Matcher ( const endpoint_type & e, DomainType d )$/;"	f	class:Matcher	signature:( const endpoint_type & e, DomainType d )
Matcher	matcher_manager.hpp	/^class Matcher$/;"	c
Matcher::BUSY	matcher_manager.hpp	/^  		BUSY,							\/\/<! do match state$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::COLLECTED	matcher_manager.hpp	/^		COLLECTED,						\/\/<! collected, won't be target any more$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::FAIL_CONNECT	matcher_manager.hpp	/^		FAIL_CONNECT,					\/\/<! fail connect$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::INVALID_MATCHER_STATE	matcher_manager.hpp	/^		INVALID_MATCHER_STATE = -2,		\/\/<! invalid state$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::LIB_LOADING	matcher_manager.hpp	/^		LIB_LOADING,					\/\/<! lib loading$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::MATCHER_STATE	matcher_manager.hpp	/^	enum MATCHER_STATE {$/;"	g	class:Matcher	access:public
Matcher::Matcher	matcher_manager.cpp	/^Matcher::Matcher ( const endpoint_type & e )$/;"	f	class:Matcher	signature:( const endpoint_type & e )
Matcher::Matcher	matcher_manager.cpp	/^Matcher::Matcher ( const endpoint_type & e, DomainType d )$/;"	f	class:Matcher	signature:( const endpoint_type & e, DomainType d )
Matcher::READY	matcher_manager.hpp	/^		READY,							\/\/<! ready waiting data$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::RECEIVING	matcher_manager.hpp	/^  		RECEIVING,						\/\/<! receiving data$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::SENDING	matcher_manager.hpp	/^  		SENDING							\/\/<! sending match result$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::TO_BE_COLLECTED	matcher_manager.hpp	/^		TO_BE_COLLECTED,				\/\/<! to be collected, won't be target any more$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::UNCONNECTED	matcher_manager.hpp	/^		UNCONNECTED,					\/\/<! unconnected default state$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::WAIT_LIB_LOAD	matcher_manager.hpp	/^		WAIT_LIB_LOAD,					\/\/<! connected but lib not loaded$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::address	matcher_manager.hpp	/^	const ip_address    address() const { return endpoint_.address(); }$/;"	f	class:Matcher	access:public	signature:() const
Matcher::clear_result_count	matcher_manager.hpp	/^	void clear_result_count() { result_count_ = 0; }$/;"	f	class:Matcher	access:public	signature:()
Matcher::demark_first_flag	matcher_manager.hpp	/^	void demark_first_flag() { first_flag_ = false; }$/;"	f	class:Matcher	access:public	signature:()
Matcher::domain_id	matcher_manager.hpp	/^	DomainType domain_id() const { return domain_id_; }$/;"	f	class:Matcher	access:public	signature:() const
Matcher::domain_id_	matcher_manager.hpp	/^	DomainType domain_id_;$/;"	m	class:Matcher	access:private
Matcher::endpoint_	matcher_manager.hpp	/^	endpoint_type endpoint_;$/;"	m	class:Matcher	access:private
Matcher::endpoint_type	matcher_manager.hpp	/^	typedef boost::asio::ip::udp::endpoint endpoint_type;$/;"	t	class:Matcher	access:public
Matcher::first_flag	matcher_manager.hpp	/^	bool first_flag() const { return first_flag_; }$/;"	f	class:Matcher	access:public	signature:() const
Matcher::first_flag_	matcher_manager.hpp	/^	bool first_flag_;$/;"	m	class:Matcher	access:private
Matcher::increase_load	matcher_manager.hpp	/^	void increase_load(unsigned n) { num_load_ += n; } $/;"	f	class:Matcher	access:public	signature:(unsigned n)
Matcher::increse_result_count	matcher_manager.hpp	/^	void increse_result_count() { ++result_count_; }$/;"	f	class:Matcher	access:public	signature:()
Matcher::lock	matcher_manager.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:Matcher	access:public
Matcher::match_threshold	matcher_manager.hpp	/^	unsigned match_threshold() const { return match_threshold_; }$/;"	f	class:Matcher	access:public	signature:() const
Matcher::match_threshold_	matcher_manager.hpp	/^	unsigned match_threshold_;$/;"	m	class:Matcher	access:private
Matcher::merge_threshold	matcher_manager.hpp	/^	unsigned merge_threshold() const { return merge_threshold_; }$/;"	f	class:Matcher	access:public	signature:() const
Matcher::merge_threshold_	matcher_manager.hpp	/^	unsigned merge_threshold_;$/;"	m	class:Matcher	access:private
Matcher::merge_unit	matcher_manager.hpp	/^	unsigned merge_unit() const { return merge_unit_; }$/;"	f	class:Matcher	access:public	signature:() const
Matcher::merge_unit_	matcher_manager.hpp	/^	unsigned merge_unit_;$/;"	m	class:Matcher	access:private
Matcher::monitor_	matcher_manager.hpp	/^	boost::mutex monitor_;$/;"	m	class:Matcher	access:private
Matcher::nbits	matcher_manager.hpp	/^	unsigned nbits() const { return nbits_; }$/;"	f	class:Matcher	access:public	signature:() const
Matcher::nbits_	matcher_manager.hpp	/^	unsigned nbits_;$/;"	m	class:Matcher	access:private
Matcher::num_load	matcher_manager.hpp	/^	unsigned num_load() const { return num_load_; }$/;"	f	class:Matcher	access:public	signature:() const
Matcher::num_load_	matcher_manager.hpp	/^	unsigned num_load_;$/;"	m	class:Matcher	access:private
Matcher::port	matcher_manager.hpp	/^	unsigned            port   () const { return endpoint_.port(); }$/;"	f	class:Matcher	access:public	signature:() const
Matcher::ready_receive	matcher_manager.hpp	/^	bool ready_receive() const { return (state_ == READY); }$/;"	f	class:Matcher	access:public	signature:() const
Matcher::result_count	matcher_manager.hpp	/^	U08 result_count() const { return result_count_; }$/;"	f	class:Matcher	access:public	signature:() const
Matcher::result_count_	matcher_manager.hpp	/^	U08 result_count_;$/;"	m	class:Matcher	access:private
Matcher::set_domain_id	matcher_manager.hpp	/^	void set_domain_id(DomainType d) { domain_id_ = d; }$/;"	f	class:Matcher	access:public	signature:(DomainType d)
Matcher::set_match_threshold	matcher_manager.cpp	/^void Matcher::set_match_threshold( unsigned n )$/;"	f	class:Matcher	signature:( unsigned n )
Matcher::set_merge_threshold	matcher_manager.cpp	/^void Matcher::set_merge_threshold( unsigned n )$/;"	f	class:Matcher	signature:( unsigned n )
Matcher::set_merge_unit	matcher_manager.cpp	/^void Matcher::set_merge_unit(unsigned m)$/;"	f	class:Matcher	signature:(unsigned m)
Matcher::set_nbits	matcher_manager.cpp	/^void Matcher::set_nbits( unsigned n )$/;"	f	class:Matcher	signature:( unsigned n )
Matcher::set_num_load	matcher_manager.cpp	/^void Matcher::set_num_load(unsigned num)$/;"	f	class:Matcher	signature:(unsigned num)
Matcher::set_state	matcher_manager.hpp	/^	void set_state(MATCHER_STATE s) { lock lk(monitor_); state_ = s; }$/;"	f	class:Matcher	access:public	signature:(MATCHER_STATE s)
Matcher::state	matcher_manager.hpp	/^	MATCHER_STATE state() const { return state_; }$/;"	f	class:Matcher	access:public	signature:() const
Matcher::state_	matcher_manager.hpp	/^	MATCHER_STATE state_;$/;"	m	class:Matcher	access:private
Matcher::to_endpoint	matcher_manager.hpp	/^	const endpoint_type to_endpoint() const { return endpoint_; }$/;"	f	class:Matcher	access:public	signature:() const
MatcherManager	matcher_manager.hpp	/^	MatcherManager()$/;"	f	class:MatcherManager	access:private	signature:()
MatcherManager	matcher_manager.hpp	/^class MatcherManager$/;"	c
MatcherManager::MatcherManager	matcher_manager.hpp	/^	MatcherManager()$/;"	f	class:MatcherManager	access:private	signature:()
MatcherManager::Matchers	matcher_manager.hpp	/^	typedef std::vector< MatcherPtr > Matchers;$/;"	t	class:MatcherManager	access:public
MatcherManager::add_matcher	matcher_manager.cpp	/^void MatcherManager::add_matcher( MatcherPtr m )$/;"	f	class:MatcherManager	signature:( MatcherPtr m )
MatcherManager::add_matcher	matcher_manager.cpp	/^void MatcherManager::add_matcher( MatcherPtr m, Matchers & ms )$/;"	f	class:MatcherManager	signature:( MatcherPtr m, Matchers & ms )
MatcherManager::c_wait_	matcher_manager.hpp	/^	boost::condition c_wait_;$/;"	m	class:MatcherManager	access:private
MatcherManager::choose_next_matcher	matcher_manager.cpp	/^MatcherPtr MatcherManager::choose_next_matcher()$/;"	f	class:MatcherManager	signature:()
MatcherManager::choose_next_matcher_for_domain	matcher_manager.cpp	/^MatcherPtr MatcherManager::choose_next_matcher_for_domain(DomainType domain)$/;"	f	class:MatcherManager	signature:(DomainType domain)
MatcherManager::connect_matcher	matcher_manager.cpp	/^void MatcherManager::connect_matcher( const Matcher & m )$/;"	f	class:MatcherManager	signature:( const Matcher & m )
MatcherManager::exists	matcher_manager.hpp	/^	bool exists( const Matcher & m ) { return find(m); }$/;"	f	class:MatcherManager	access:public	signature:( const Matcher & m )
MatcherManager::find	matcher_manager.cpp	/^MatcherPtr MatcherManager::find( const Matcher & m ) const$/;"	f	class:MatcherManager	signature:( const Matcher & m ) const
MatcherManager::find_in	matcher_manager.hpp	/^	static MatcherPtr find_in( const Matcher & m, const Matchers & ms )$/;"	f	class:MatcherManager	access:public	signature:( const Matcher & m, const Matchers & ms )
MatcherManager::find_matchers_at_domain	matcher_manager.cpp	/^MatcherManager::Matchers MatcherManager::find_matchers_at_domain( DomainType d )$/;"	f	class:MatcherManager	signature:( DomainType d )
MatcherManager::find_matchers_at_domain_and_state	matcher_manager.cpp	/^MatcherManager::Matchers MatcherManager::find_matchers_at_domain_and_state( DomainType d, Matcher::MATCHER_STATE s )$/;"	f	class:MatcherManager	signature:( DomainType d, Matcher::MATCHER_STATE s )
MatcherManager::find_matchers_at_state	matcher_manager.cpp	/^MatcherManager::Matchers MatcherManager::find_matchers_at_state( Matcher::MATCHER_STATE s )$/;"	f	class:MatcherManager	signature:( Matcher::MATCHER_STATE s )
MatcherManager::find_one_matcher_at_domain_and_state	matcher_manager.cpp	/^MatcherPtr MatcherManager::find_one_matcher_at_domain_and_state( const Matcher::MATCHER_STATE s, DomainType d )$/;"	f	class:MatcherManager	signature:( const Matcher::MATCHER_STATE s, DomainType d )
MatcherManager::find_one_matcher_at_state	matcher_manager.cpp	/^MatcherPtr MatcherManager::find_one_matcher_at_state( const Matcher::MATCHER_STATE s )$/;"	f	class:MatcherManager	signature:( const Matcher::MATCHER_STATE s )
MatcherManager::get_matcher_state	matcher_manager.cpp	/^Matcher::MATCHER_STATE MatcherManager::get_matcher_state( const Matcher & m ) const$/;"	f	class:MatcherManager	signature:( const Matcher & m ) const
MatcherManager::id_to_ip	matcher_manager.cpp	/^const std::string MatcherManager::id_to_ip(unsigned id)$/;"	f	class:MatcherManager	signature:(unsigned id)
MatcherManager::instance	matcher_manager.hpp	/^	static MatcherManager & instance()$/;"	f	class:MatcherManager	access:public	signature:()
MatcherManager::instance_	matcher_manager.cpp	/^MatcherManager * MatcherManager::instance_ = 0;$/;"	m	class:MatcherManager	file:
MatcherManager::instance_	matcher_manager.hpp	/^	static MatcherManager * instance_;$/;"	m	class:MatcherManager	access:private
MatcherManager::lock	matcher_manager.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:MatcherManager	access:public
MatcherManager::make_matcher	matcher_manager.hpp	/^	static MatcherPtr make_matcher( const Matcher::endpoint_type & e, DomainType domain_id )$/;"	f	class:MatcherManager	access:public	signature:( const Matcher::endpoint_type & e, DomainType domain_id )
MatcherManager::make_matcher	matcher_manager.hpp	/^	static MatcherPtr make_matcher( const std::string & ip, DomainType domain_id )$/;"	f	class:MatcherManager	access:public	signature:( const std::string & ip, DomainType domain_id )
MatcherManager::matchers_	matcher_manager.hpp	/^	Matchers matchers_;$/;"	m	class:MatcherManager	access:private
MatcherManager::monitor_	matcher_manager.hpp	/^	boost::mutex monitor_;$/;"	m	class:MatcherManager	access:private
MatcherManager::notify_wait_ready_matcher	matcher_manager.cpp	/^void MatcherManager::notify_wait_ready_matcher()$/;"	f	class:MatcherManager	signature:()
MatcherManager::print_matcher_util	matcher_manager.cpp	/^void MatcherManager::print_matcher_util( ostream & out, const Matchers & ms ) const$/;"	f	class:MatcherManager	signature:( ostream & out, const Matchers & ms ) const
MatcherManager::print_matchers	matcher_manager.cpp	/^void MatcherManager::print_matchers     (std::ostream & out) const$/;"	f	class:MatcherManager	signature:(std::ostream & out) const
MatcherManager::remove_matcher	matcher_manager.cpp	/^void MatcherManager::remove_matcher( const Matcher & m )$/;"	f	class:MatcherManager	signature:( const Matcher & m )
MatcherManager::set_matcher_state	matcher_manager.cpp	/^void MatcherManager::set_matcher_state( const Matcher & m , Matcher::MATCHER_STATE s )$/;"	f	class:MatcherManager	signature:( const Matcher & m , Matcher::MATCHER_STATE s )
MatcherManager::start_timer	matcher_manager.cpp	/^void MatcherManager::start_timer()$/;"	f	class:MatcherManager	signature:()
MatcherManager::timer_	matcher_manager.hpp	/^	boost::timer::cpu_timer timer_;$/;"	m	class:MatcherManager	access:private
MatcherManager::update_all_matcher_load	matcher_manager.cpp	/^void MatcherManager::update_all_matcher_load()$/;"	f	class:MatcherManager	signature:()
MatcherPtr	matcher_manager.hpp	/^typedef boost::shared_ptr< Matcher > MatcherPtr;$/;"	t
Matchers	matcher_manager.hpp	/^	typedef std::vector< MatcherPtr > Matchers;$/;"	t	class:MatcherManager	access:public
Matches	ipoint.h	/^	Matches() {}$/;"	f	class:Matches	access:public	signature:()
Matches	ipoint.h	/^	Matches(IpVec& ipts1, IpVec2& ipts2) : ipts1_(&ipts1), ipts2_(&ipts2) {}$/;"	f	class:Matches	access:public	signature:(IpVec& ipts1, IpVec2& ipts2)
Matches	ipoint.h	/^class Matches {$/;"	c
Matches::IpVec2	ipoint.h	/^	typedef std::vector<I> IpVec2;$/;"	t	class:Matches	access:public
Matches::Matches	ipoint.h	/^	Matches() {}$/;"	f	class:Matches	access:public	signature:()
Matches::Matches	ipoint.h	/^	Matches(IpVec& ipts1, IpVec2& ipts2) : ipts1_(&ipts1), ipts2_(&ipts2) {}$/;"	f	class:Matches	access:public	signature:(IpVec& ipts1, IpVec2& ipts2)
Matches::Run	ipoint.cpp	/^void Matches<D, I>::Run(bool mt) {$/;"	f	class:Matches	signature:(bool mt)
Matches::dist	ipoint.h	/^	D dist;$/;"	m	class:Matches	access:private
Matches::ipt1	ipoint.h	/^	const Ipoint& ipt1(int i) const { return *matches_[i].first;  }$/;"	f	class:Matches	access:public	signature:(int i) const
Matches::ipt2	ipoint.h	/^	const I& ipt2(int i) const { return *matches_[i].second; }$/;"	f	class:Matches	access:public	signature:(int i) const
Matches::ipts1_	ipoint.h	/^	IpVec*  ipts1_;$/;"	m	class:Matches	access:private
Matches::ipts2_	ipoint.h	/^	IpVec2* ipts2_;$/;"	m	class:Matches	access:private
Matches::matchThread	ipoint.cpp	/^void Matches<D, I>::matchThread(int tid) {$/;"	f	class:Matches	signature:(int tid)
Matches::matches_	ipoint.h	/^	std::vector<std::pair<const Ipoint*, const I*> > matches_;$/;"	m	class:Matches	access:private
Matches::size	ipoint.h	/^	int size() const { return matches_.size(); }$/;"	f	class:Matches	access:public	signature:() const
Matches::storeMatch	ipoint.cpp	/^void Matches<EDist, Ipoint>::storeMatch(Ipoint* ipt) {$/;"	f	class:Matches	signature:(Ipoint* ipt)
Matches::storeMatch	ipoint.cpp	/^void Matches<MDist, Ipoint>::storeMatch(Ipoint* ipt) {$/;"	f	class:Matches	signature:(Ipoint* ipt)
Matches::storeMatch	ipoint.h	/^	void storeMatch(Ipoint* ipt)$/;"	f	class:Matches	access:private	signature:(Ipoint* ipt)
MergeThreshold	matcher_manager.hpp	/^	U08 MergeThreshold;$/;"	m	struct:DomainInfo	access:public
MergeUnit	matcher_manager.hpp	/^	U08 MergeUnit;$/;"	m	struct:DomainInfo	access:public
MonitorId	matcher_manager.hpp	/^	U32 MonitorId;$/;"	m	struct:DomainInfo	access:public
N	bits.hpp	/^	int N;$/;"	m	struct:bits	access:public
NBits	matcher_manager.hpp	/^	U08 NBits;$/;"	m	struct:DomainInfo	access:public
NCOLOURS	utils.cpp	/^static const int NCOLOURS = 8;$/;"	v	file:
NEWLIB_H	newlib.h	2;"	d
NUM	newlib.h	/^	enum State { SYNC, NUM, DESC };$/;"	e	enum:VideoLibVec::State
NewLibLoader	match_stream.cpp	/^NewLibLoader::NewLibLoader( const VideoLibVec & lib )$/;"	f	class:NewLibLoader	signature:( const VideoLibVec & lib )
NewLibLoader	match_stream.hpp	/^class NewLibLoader : public StreamNode$/;"	c	inherits:StreamNode
NewLibLoader::NewLibLoader	match_stream.cpp	/^NewLibLoader::NewLibLoader( const VideoLibVec & lib )$/;"	f	class:NewLibLoader	signature:( const VideoLibVec & lib )
NewLibLoader::do_end_task	match_stream.cpp	/^void NewLibLoader::do_end_task()$/;"	f	class:NewLibLoader	signature:()
NewLibLoader::do_run_task	match_stream.cpp	/^void NewLibLoader::do_run_task()$/;"	f	class:NewLibLoader	signature:()
NewLibLoader::lib_	match_stream.hpp	/^	const VideoLibVec & lib_;$/;"	m	class:NewLibLoader	access:private
NewLibLoader::load_lib	match_stream.cpp	/^void NewLibLoader::load_lib( const VideoLibVec & lib )$/;"	f	class:NewLibLoader	signature:( const VideoLibVec & lib )
NewLibSender	match_stream.cpp	/^NewLibSender::NewLibSender( const endpoint & dest )$/;"	f	class:NewLibSender	signature:( const endpoint & dest )
NewLibSender	match_stream.hpp	/^class NewLibSender : public StreamNode$/;"	c	inherits:StreamNode
NewLibSender::NewLibSender	match_stream.cpp	/^NewLibSender::NewLibSender( const endpoint & dest )$/;"	f	class:NewLibSender	signature:( const endpoint & dest )
NewLibSender::dest_	match_stream.hpp	/^	const endpoint dest_;$/;"	m	class:NewLibSender	access:private
NewLibSender::do_end_task	match_stream.cpp	/^void NewLibSender::do_end_task()$/;"	f	class:NewLibSender	signature:()
NewLibSender::do_run_task	match_stream.cpp	/^void NewLibSender::do_run_task()$/;"	f	class:NewLibSender	signature:()
NewLibSender::send_packets	match_stream.cpp	/^void NewLibSender::send_packets()$/;"	f	class:NewLibSender	signature:()
NodeFrequency	matcher_manager.hpp	/^	U16 NodeFrequency;$/;"	m	struct:DomainInfo	access:public
NodeVersion	matcher_manager.hpp	/^	U16 NodeVersion;$/;"	m	struct:DomainInfo	access:public
Nodes	command.hpp	/^	typedef std::set<unsigned> Nodes;$/;"	t	class:AddNodesCommand	access:public
Nodes	command.hpp	/^	typedef std::set<unsigned> Nodes;$/;"	t	class:RemoveNodesCommand	access:public
NumTotalPipe	matcher_manager.hpp	/^	U08 NumTotalPipe;$/;"	m	struct:DomainInfo	access:public
OutputTimeout	matcher_manager.hpp	/^	U08 OutputTimeout;$/;"	m	struct:DomainInfo	access:public
PACKET_HANDLE_CENTER_HPP	packet_handle_center.hpp	2;"	d
PACKET_HPP	packet.hpp	2;"	d
PACKET_MSG	packet_handle_center.cpp	10;"	d	file:
POINT_ALL_END	comm_para.hpp	/^	const u_char      POINT_ALL_END       = 0x64;$/;"	m	namespace:__anon4
POINT_END	comm_para.hpp	/^	const u_char      POINT_END           = 0x24;$/;"	m	namespace:__anon4
POINT_SENDING	comm_para.hpp	/^	const u_char      POINT_SENDING       = 0x04;$/;"	m	namespace:__anon4
POINT_START	comm_para.hpp	/^	const u_char      POINT_START         = 0x14;$/;"	m	namespace:__anon4
PRINT_RANGES	match_analyser.cpp	15;"	d	file:
Packet	packet.hpp	/^typedef CfaUdpPacket       Packet;$/;"	t
PacketHandleCenter	packet_handle_center.cpp	/^PacketHandleCenter::PacketHandleCenter()$/;"	f	class:PacketHandleCenter	signature:()
PacketHandleCenter	packet_handle_center.hpp	/^class PacketHandleCenter$/;"	c
PacketHandleCenter::PacketHandleCenter	packet_handle_center.cpp	/^PacketHandleCenter::PacketHandleCenter()$/;"	f	class:PacketHandleCenter	signature:()
PacketHandleCenter::handle_packet	packet_handle_center.cpp	/^void PacketHandleCenter::handle_packet( PacketPtr p, const udp::endpoint & end_point )$/;"	f	class:PacketHandleCenter	signature:( PacketPtr p, const udp::endpoint & end_point )
PacketHandleCenter::instance	packet_handle_center.hpp	/^	static PacketHandleCenter & instance()$/;"	f	class:PacketHandleCenter	access:public	signature:()
PacketHandleCenter::packet_handle_loop	packet_handle_center.cpp	/^void PacketHandleCenter::packet_handle_loop()$/;"	f	class:PacketHandleCenter	signature:()
PacketHandleCenter::quit_	packet_handle_center.hpp	/^	bool quit_;$/;"	m	class:PacketHandleCenter	access:private
PacketHandleCenter::run	packet_handle_center.cpp	/^void PacketHandleCenter::run()$/;"	f	class:PacketHandleCenter	signature:()
PacketIndex	matcher_manager.hpp	/^	U08 PacketIndex;$/;"	m	struct:DomainInfo	access:public
PacketLength	matcher_manager.hpp	/^	U16 PacketLength;$/;"	m	struct:DomainInfo	access:public
PacketPtr	packet.hpp	/^typedef boost::shared_ptr<CfaUdpPacket> PacketPtr;$/;"	t
PacketQueue	comm_box.hpp	/^typedef CommQueue< PacketPtr > PacketQueue;$/;"	t
PacketType	matcher_manager.hpp	/^	U08 PacketType;$/;"	m	struct:DomainInfo	access:public
PacketWindow	comm_window.hpp	/^	explicit PacketWindow(const std::string & name_, int timeout = 20)$/;"	f	class:PacketWindow	access:protected	signature:(const std::string & name_, int timeout = 20)
PacketWindow	comm_window.hpp	/^class PacketWindow : public Basebox$/;"	c	inherits:Basebox
PacketWindow::PacketWindow	comm_window.hpp	/^	explicit PacketWindow(const std::string & name_, int timeout = 20)$/;"	f	class:PacketWindow	access:protected	signature:(const std::string & name_, int timeout = 20)
PacketWindow::TIMEOUT	comm_window.hpp	/^	const int TIMEOUT;$/;"	m	class:PacketWindow	access:protected
PacketWindow::acquire	comm_window.hpp	/^	Packet * acquire()$/;"	f	class:PacketWindow	access:public	signature:()
PacketWindow::capacity	comm_window.hpp	/^	virtual std::size_t capacity() const { return N; }$/;"	f	class:PacketWindow	access:public	signature:() const
PacketWindow::circular_buf	comm_window.hpp	/^	std::vector<Packet> circular_buf;$/;"	m	class:PacketWindow	access:protected
PacketWindow::confirm	comm_window.hpp	/^	bool confirm(unsigned char index)$/;"	f	class:PacketWindow	access:public	signature:(unsigned char index)
PacketWindow::consider_timeout	comm_window.hpp	/^	bool consider_timeout;$/;"	m	class:PacketWindow	access:protected
PacketWindow::curr	comm_window.hpp	/^	std::size_t curr;	\/\/ ÷∏œÚµ±«∞∑¢ÀÕµƒ∞¸£¨”…get()∑µªÿ$/;"	m	class:PacketWindow	access:protected
PacketWindow::get	comm_window.hpp	/^	Packet * get()$/;"	f	class:PacketWindow	access:public	signature:()
PacketWindow::get_condition_not_satisfied	comm_window.hpp	/^	virtual bool get_condition_not_satisfied() const$/;"	f	class:PacketWindow	access:public	signature:() const
PacketWindow::head	comm_window.hpp	/^	std::size_t head;	\/\/ ∂”¡–Õ∑£¨”…confirmµ˜’˚$/;"	m	class:PacketWindow	access:protected
PacketWindow::name	comm_window.hpp	/^	std::string name;$/;"	m	class:PacketWindow	access:protected
PacketWindow::next	comm_window.hpp	/^	static std::size_t next(std::size_t p) { return (p + 1) % (N + 1); }$/;"	f	class:PacketWindow	access:protected	signature:(std::size_t p)
PacketWindow::num_elements	comm_window.hpp	/^	virtual std::size_t num_elements() const$/;"	f	class:PacketWindow	access:public	signature:() const
PacketWindow::put	comm_window.hpp	/^	void put()$/;"	f	class:PacketWindow	access:public	signature:()
PacketWindow::reset	comm_window.hpp	/^	void reset()$/;"	f	class:PacketWindow	access:public	signature:()
PacketWindow::tail	comm_window.hpp	/^	std::size_t tail;	\/\/ ∂”¡–Œ≤£¨÷∏œÚ“ª∏ˆø’∞¸£¨”…acquire()∑µªÿ$/;"	m	class:PacketWindow	access:protected
PowerPerPipe	matcher_manager.hpp	/^	U08 PowerPerPipe;$/;"	m	struct:DomainInfo	access:public
PresentationId	matcher_manager.hpp	/^	U32 PresentationId;$/;"	m	struct:DomainInfo	access:public
QUITED	comm_para.hpp	/^	const u_char      QUITED              = 0x50;$/;"	m	namespace:__anon4
QueryLoadsCommand	command.cpp	/^QueryLoadsCommand::QueryLoadsCommand(AppId appid)$/;"	f	class:QueryLoadsCommand	signature:(AppId appid)
QueryLoadsCommand	command.hpp	/^class QueryLoadsCommand : public ICommand$/;"	c	inherits:ICommand
QueryLoadsCommand::QueryLoadsCommand	command.cpp	/^QueryLoadsCommand::QueryLoadsCommand(AppId appid)$/;"	f	class:QueryLoadsCommand	signature:(AppId appid)
QueryLoadsCommand::appid_	command.hpp	/^	AppId appid_;$/;"	m	class:QueryLoadsCommand	access:private
QueryLoadsCommand::execute	command.cpp	/^void QueryLoadsCommand::execute()$/;"	f	class:QueryLoadsCommand	signature:()
QueryLoadsCommand::reply	command.cpp	/^void QueryLoadsCommand::reply()$/;"	f	class:QueryLoadsCommand	signature:()
Queue	comm_box.hpp	/^	typedef typename std::queue< T > Queue;$/;"	t	class:CommQueue	access:private
RAW_HEAD_SIZE	packet.hpp	/^	RAW_HEAD_SIZE = 14,$/;"	e	enum:__anon9
RAW_HPP	raw.hpp	14;"	d
RAW_MAX_DATA_LEN	packet.hpp	/^	RAW_MAX_DATA_LEN     = RAW_MAX_LOAD_LEN - 2,		\/\/ 1498$/;"	e	enum:__anon9
RAW_MAX_LOAD_LEN	packet.hpp	/^	RAW_MAX_LOAD_LEN     = ETH_MAX_LEN - RAW_HEAD_SIZE,		\/\/ 1500$/;"	e	enum:__anon9
RAW_MIN_DATA_LEN	packet.hpp	/^	RAW_MIN_DATA_LEN     = RAW_MIN_LOAD_LEN - 2,		\/\/ 44$/;"	e	enum:__anon9
RAW_MIN_LOAD_LEN	packet.hpp	/^	RAW_MIN_LOAD_LEN     = ETH_MIN_LEN - RAW_HEAD_SIZE,		\/\/ 46$/;"	e	enum:__anon9
READY	matcher_manager.hpp	/^		READY,							\/\/<! ready waiting data$/;"	e	enum:Matcher::MATCHER_STATE
RECEIVING	matcher_manager.hpp	/^  		RECEIVING,						\/\/<! receiving data$/;"	e	enum:Matcher::MATCHER_STATE
RandomGetBox	comm_box.hpp	/^	RandomGetBox()$/;"	f	class:RandomGetBox	access:public	signature:()
RandomGetBox	comm_box.hpp	/^class RandomGetBox : public Basebox$/;"	c	inherits:Basebox
RandomGetBox::RandomGetBox	comm_box.hpp	/^	RandomGetBox()$/;"	f	class:RandomGetBox	access:public	signature:()
RandomGetBox::acquire	comm_box.hpp	/^	T * acquire()$/;"	f	class:RandomGetBox	access:public	signature:()
RandomGetBox::buff	comm_box.hpp	/^	std::vector< T > buff;$/;"	m	class:RandomGetBox	access:protected
RandomGetBox::capacity	comm_box.hpp	/^	virtual std::size_t capacity()     const { return N; }$/;"	f	class:RandomGetBox	access:public	signature:() const
RandomGetBox::curr	comm_box.hpp	/^	int curr;$/;"	m	class:RandomGetBox	access:protected
RandomGetBox::get	comm_box.hpp	/^	bool get(std::vector< T > & snk)$/;"	f	class:RandomGetBox	access:public	signature:(std::vector< T > & snk)
RandomGetBox::indexes_type	comm_box.hpp	/^	typedef std::vector<std::size_t> indexes_type;$/;"	t	class:RandomGetBox	access:public
RandomGetBox::num_elements	comm_box.hpp	/^	virtual std::size_t num_elements() const { return curr; }$/;"	f	class:RandomGetBox	access:public	signature:() const
RandomGetBox::put	comm_box.hpp	/^	void put()$/;"	f	class:RandomGetBox	access:public	signature:()
RandomGetBox::tail	comm_box.hpp	/^	int tail;$/;"	m	class:RandomGetBox	access:protected
Range	fdutils.h	/^	Range(int b, int e) : begin(b), end(e) {}$/;"	f	struct:Range	access:public	signature:(int b, int e)
Range	fdutils.h	/^	Range(int e) : begin(0), end(e) {}$/;"	f	struct:Range	access:public	signature:(int e)
Range	fdutils.h	/^struct Range {$/;"	s
Range::Range	fdutils.h	/^	Range(int b, int e) : begin(b), end(e) {}$/;"	f	struct:Range	access:public	signature:(int b, int e)
Range::Range	fdutils.h	/^	Range(int e) : begin(0), end(e) {}$/;"	f	struct:Range	access:public	signature:(int e)
Range::begin	fdutils.h	/^	int begin, end;$/;"	m	struct:Range	access:public
Range::end	fdutils.h	/^	int begin, end;$/;"	m	struct:Range	access:public
RawPacket	packet.hpp	/^	RawPacket (int len = RAW_MAX_DATA_LEN)$/;"	f	class:RawPacket	access:public	signature:(int len = RAW_MAX_DATA_LEN)
RawPacket	packet.hpp	/^	RawPacket (int len, u_char type, u_char idx)$/;"	f	class:RawPacket	access:public	signature:(int len, u_char type, u_char idx)
RawPacket	packet.hpp	/^	RawPacket (int len, u_char type, u_char idx, const eth::address& src, const eth::address& snk)$/;"	f	class:RawPacket	access:public	signature:(int len, u_char type, u_char idx, const eth::address& src, const eth::address& snk)
RawPacket	packet.hpp	/^class RawPacket : public raw_packet_base__$/;"	c	inherits:raw_packet_base__
RawPacket::RawPacket	packet.hpp	/^	RawPacket (int len = RAW_MAX_DATA_LEN)$/;"	f	class:RawPacket	access:public	signature:(int len = RAW_MAX_DATA_LEN)
RawPacket::RawPacket	packet.hpp	/^	RawPacket (int len, u_char type, u_char idx)$/;"	f	class:RawPacket	access:public	signature:(int len, u_char type, u_char idx)
RawPacket::RawPacket	packet.hpp	/^	RawPacket (int len, u_char type, u_char idx, const eth::address& src, const eth::address& snk)$/;"	f	class:RawPacket	access:public	signature:(int len, u_char type, u_char idx, const eth::address& src, const eth::address& snk)
RawResponPacket	packet.hpp	/^	RawResponPacket()$/;"	f	class:RawResponPacket	access:public	signature:()
RawResponPacket	packet.hpp	/^	RawResponPacket(u_char type, u_char idx, const eth::address& src, const eth::address& snk, u_char ctrl = 0x00)$/;"	f	class:RawResponPacket	access:public	signature:(u_char type, u_char idx, const eth::address& src, const eth::address& snk, u_char ctrl = 0x00)
RawResponPacket	packet.hpp	/^	RawResponPacket(u_char type, u_char idx, u_char ctrl = 0x00)$/;"	f	class:RawResponPacket	access:public	signature:(u_char type, u_char idx, u_char ctrl = 0x00)
RawResponPacket	packet.hpp	/^class RawResponPacket : public raw_response_packet_base__$/;"	c	inherits:raw_response_packet_base__
RawResponPacket::RawResponPacket	packet.hpp	/^	RawResponPacket()$/;"	f	class:RawResponPacket	access:public	signature:()
RawResponPacket::RawResponPacket	packet.hpp	/^	RawResponPacket(u_char type, u_char idx, const eth::address& src, const eth::address& snk, u_char ctrl = 0x00)$/;"	f	class:RawResponPacket	access:public	signature:(u_char type, u_char idx, const eth::address& src, const eth::address& snk, u_char ctrl = 0x00)
RawResponPacket::RawResponPacket	packet.hpp	/^	RawResponPacket(u_char type, u_char idx, u_char ctrl = 0x00)$/;"	f	class:RawResponPacket	access:public	signature:(u_char type, u_char idx, u_char ctrl = 0x00)
ReMergeThrehold	matcher_manager.hpp	/^	U08 ReMergeThrehold;$/;"	m	struct:DomainInfo	access:public
RemoveNodesCommand	command.hpp	/^	RemoveNodesCommand(\/*AppId id*\/)$/;"	f	class:RemoveNodesCommand	access:public	signature:( )
RemoveNodesCommand	command.hpp	/^class RemoveNodesCommand : public ICommand$/;"	c	inherits:ICommand
RemoveNodesCommand::Nodes	command.hpp	/^	typedef std::set<unsigned> Nodes;$/;"	t	class:RemoveNodesCommand	access:public
RemoveNodesCommand::RemoveNodesCommand	command.hpp	/^	RemoveNodesCommand(\/*AppId id*\/)$/;"	f	class:RemoveNodesCommand	access:public	signature:( )
RemoveNodesCommand::add_target_node	command.hpp	/^	void add_target_node(unsigned node_id)$/;"	f	class:RemoveNodesCommand	access:public	signature:(unsigned node_id)
RemoveNodesCommand::app_id_	command.hpp	/^	AppId app_id_;$/;"	m	class:RemoveNodesCommand	access:private
RemoveNodesCommand::execute	command.cpp	/^void RemoveNodesCommand::execute()$/;"	f	class:RemoveNodesCommand	signature:()
RemoveNodesCommand::nodes_	command.hpp	/^	Nodes nodes_;$/;"	m	class:RemoveNodesCommand	access:private
RemoveNodesCommand::reply	command.cpp	/^void RemoveNodesCommand::reply()$/;"	f	class:RemoveNodesCommand	signature:()
RemoveNodesCommand::target_nodes	command.hpp	/^	const Nodes & target_nodes() { return nodes_; }$/;"	f	class:RemoveNodesCommand	access:public	signature:()
ReportCycle	matcher_manager.hpp	/^	U08 ReportCycle;$/;"	m	struct:DomainInfo	access:public
ResponPacket	packet.hpp	/^typedef CfaUdpResponPacket ResponPacket;$/;"	t
RightNeighborId	matcher_manager.hpp	/^	U32 RightNeighborId;$/;"	m	struct:DomainInfo	access:public
Run	ipoint.cpp	/^void Matches<D, I>::Run(bool mt) {$/;"	f	class:Matches	signature:(bool mt)
SENDING	matcher_manager.hpp	/^  		SENDING							\/\/<! sending match result$/;"	e	enum:Matcher::MATCHER_STATE
SEND_LIB_PKT_SIZE	comm_para.hpp	/^	const int         SEND_LIB_PKT_SIZE   = 1472;$/;"	m	namespace:__anon4
SERVER_HPP	server.hpp	2;"	d
SERVER_SOCK_FILE	command_recv_service.cpp	5;"	d	file:
SERVER_SOCK_FILE	dcsp_fifo.h	13;"	d
SHIFT	bits.hpp	/^	static const unsigned char SHIFT = 3;$/;"	m	struct:bits	access:public
SYNC	newlib.h	/^	enum State { SYNC, NUM, DESC };$/;"	e	enum:VideoLibVec::State
SYNCWORD	comm_para.hpp	/^	const int         SYNCWORD            = 0xFADCCAFD;$/;"	m	namespace:__anon4
SYNCWORD_END	comm_para.hpp	/^	const int         SYNCWORD_END        = 0xAFCDACDF;$/;"	m	namespace:__anon4
SectionManager	match_utils.h	/^class SectionManager {$/;"	c
SectionManager::Chain	match_utils.h	/^	typedef std::list<MatchSection> Chain;		\/\/ ”––Ú¡¥±Ì$/;"	t	class:SectionManager	access:public
SectionManager::add_section	match_utils.cpp	/^void SectionManager::add_section(const MatchSection& sec) {$/;"	f	class:SectionManager	signature:(const MatchSection& sec)
SectionManager::chains_	match_utils.h	/^	std::map<long long, Chain> chains_;			\/\/  π”√offset_id◊˜Œ™key$/;"	m	class:SectionManager	access:private
SectionManager::clear	match_utils.h	/^	void clear() { chains_.clear(); }$/;"	f	class:SectionManager	access:public	signature:()
SectionManager::delete_chains	match_utils.cpp	/^void SectionManager::delete_chains(int test_id) {$/;"	f	class:SectionManager	signature:(int test_id)
SectionManager::gather_results	match_utils.cpp	/^const MatchResults& SectionManager::gather_results() {$/;"	f	class:SectionManager	signature:()
SectionManager::output_chains	match_utils.cpp	/^void SectionManager::output_chains(ostream& out, int test_id) {$/;"	f	class:SectionManager	signature:(ostream& out, int test_id)
SectionManager::results	match_utils.h	/^	const MatchResults& results() const { return results_; }$/;"	f	class:SectionManager	access:public	signature:() const
SectionManager::results_	match_utils.h	/^	MatchResults results_;$/;"	m	class:SectionManager	access:private
SectionManagerSimp	match_utils.h	/^	SectionManagerSimp(int thres) : slice_thres_(thres) {}$/;"	f	class:SectionManagerSimp	access:public	signature:(int thres)
SectionManagerSimp	match_utils.h	/^class SectionManagerSimp {$/;"	c
SectionManagerSimp::SectionManagerSimp	match_utils.h	/^	SectionManagerSimp(int thres) : slice_thres_(thres) {}$/;"	f	class:SectionManagerSimp	access:public	signature:(int thres)
SectionManagerSimp::add_section	match_utils.cpp	/^void SectionManagerSimp::add_section(const MatchSection& sec) {$/;"	f	class:SectionManagerSimp	signature:(const MatchSection& sec)
SectionManagerSimp::clear	match_utils.h	/^	void clear() { results_.clear(); }$/;"	f	class:SectionManagerSimp	access:public	signature:()
SectionManagerSimp::delete_results	match_utils.cpp	/^void SectionManagerSimp::delete_results(int test_id) {$/;"	f	class:SectionManagerSimp	signature:(int test_id)
SectionManagerSimp::output_results	match_utils.cpp	/^void SectionManagerSimp::output_results(ostream& out, int test_id) {$/;"	f	class:SectionManagerSimp	signature:(ostream& out, int test_id)
SectionManagerSimp::results_	match_utils.h	/^	std::map<long long, int> results_;			\/\/  π”√offset_id◊˜Œ™key$/;"	m	class:SectionManagerSimp	access:private
SectionManagerSimp::slice_thres_	match_utils.h	/^	int slice_thres_;$/;"	m	class:SectionManagerSimp	access:private
Server	server.hpp	/^	Server (CommArg * arg)$/;"	f	class:Server	access:public	signature:(CommArg * arg)
Server	server.hpp	/^class Server : public boost::noncopyable$/;"	c	inherits:boost::noncopyable
Server::Server	server.hpp	/^	Server (CommArg * arg)$/;"	f	class:Server	access:public	signature:(CommArg * arg)
Server::addr	server.hpp	/^	const boost::asio::ip::address addr() const { return local_point_.address(); }$/;"	f	class:Server	access:public	signature:() const
Server::all_comm_end	server.cpp	/^bool Server::all_comm_end() const$/;"	f	class:Server	signature:() const
Server::all_comm_end_	server.hpp	/^	bool all_comm_end_;									\/\/ all communicatioin end flag$/;"	m	class:Server	access:private
Server::arg	server.hpp	/^	CommArg * arg() { return arg_; }$/;"	f	class:Server	access:public	signature:()
Server::arg_	server.hpp	/^	CommArg * arg_;									   	\/\/ arg$/;"	m	class:Server	access:private
Server::bitfeature_all_sent	server.hpp	/^	bool bitfeature_all_sent() const { return bitfeature_all_sent_; }$/;"	f	class:Server	access:public	signature:() const
Server::bitfeature_all_sent_	server.hpp	/^	bool bitfeature_all_sent_;$/;"	m	class:Server	access:private
Server::bitfeature_loader	server.hpp	/^	BitFeatureLoader   * bitfeature_loader()   const { return bitfeature_loader_; }$/;"	f	class:Server	access:public	signature:() const
Server::bitfeature_loader_	server.hpp	/^	BitFeatureLoader   * bitfeature_loader_;$/;"	m	class:Server	access:private
Server::bitfeature_sender	server.hpp	/^	BitFeatureSender   * bitfeature_sender()   const { return bitfeature_sender_; }$/;"	f	class:Server	access:public	signature:() const
Server::bitfeature_sender_	server.hpp	/^	BitFeatureSender   * bitfeature_sender_;$/;"	m	class:Server	access:private
Server::bitfeature_window	server.hpp	/^	BitFeatureWindow   * bitfeature_window()   { return &bitfeature_window_; }$/;"	f	class:Server	access:public	signature:()
Server::bitfeature_window_	server.hpp	/^	BitFeatureWindow      bitfeature_window_;			\/\/ window for sending bitfeature$/;"	m	class:Server	access:private
Server::c_wait_	server.hpp	/^	boost::condition c_wait_;$/;"	m	class:Server	access:private
Server::cmd_queue_	server.hpp	/^	CommandQueue          cmd_queue_;$/;"	m	class:Server	access:private
Server::command_queue	server.hpp	/^	CommandQueue       * command_queue()       { return &cmd_queue_; }$/;"	f	class:Server	access:public	signature:()
Server::command_window	server.hpp	/^	CommandWindow      * command_window()      { return &command_window_; }$/;"	f	class:Server	access:public	signature:()
Server::command_window_	server.hpp	/^	CommandWindow         command_window_;				\/\/ window for sending msg to DCSP$/;"	m	class:Server	access:private
Server::construct_server	server.hpp	/^	static void construct_server( CommArg * arg )$/;"	f	class:Server	access:public	signature:( CommArg * arg )
Server::deadline_	server.hpp	/^	boost::asio::deadline_timer deadline_;              \/\/ timer for getting mac$/;"	m	class:Server	access:private
Server::end_point_	server.hpp	/^	boost::asio::ip::udp::endpoint end_point_;			\/\/ receive endpoint$/;"	m	class:Server	access:private
Server::instance	server.hpp	/^	static Server & instance()$/;"	f	class:Server	access:public	signature:()
Server::io	server.hpp	/^	boost::asio::io_service & io() { return io_; }$/;"	f	class:Server	access:public	signature:()
Server::io_	server.hpp	/^	boost::asio::io_service io_;                        \/\/ io service$/;"	m	class:Server	access:private
Server::local_endpoint	server.hpp	/^	const udp::endpoint  local_endpoint() const { return local_point_; }$/;"	f	class:Server	access:public	signature:() const
Server::local_point_	server.hpp	/^	boost::asio::ip::udp::endpoint local_point_;				$/;"	m	class:Server	access:private
Server::mark_all_comm_end	server.cpp	/^void Server::mark_all_comm_end()$/;"	f	class:Server	signature:()
Server::mark_bitfeatures_all_sent	server.hpp	/^	void mark_bitfeatures_all_sent() { bitfeature_all_sent_ = true; }$/;"	f	class:Server	access:public	signature:()
Server::monitor_	server.hpp	/^	boost::mutex monitor_;$/;"	m	class:Server	access:private
Server::open_services	server.cpp	/^void Server::open_services()$/;"	f	class:Server	signature:()
Server::packet_queue	server.hpp	/^	PacketQueue        * packet_queue()        { return &pkt_queue_; }$/;"	f	class:Server	access:public	signature:()
Server::pkt_queue_	server.hpp	/^	PacketQueue           pkt_queue_;$/;"	m	class:Server	access:private
Server::port	server.hpp	/^	unsigned short                 port() const { return local_point_.port(); }$/;"	f	class:Server	access:public	signature:() const
Server::quit_wanted_	server.hpp	/^	bool quit_wanted_;$/;"	m	class:Server	access:private
Server::recv_buffer_	server.hpp	/^	boost::asio::mutable_buffers_1 recv_buffer_;        \/\/ receive asio buffer$/;"	m	class:Server	access:private
Server::recv_diverse_handler	server.cpp	/^void Server::recv_diverse_handler(const boost::system::error_code& ec, size_t length)$/;"	f	class:Server	signature:(const boost::system::error_code& ec, size_t length)
Server::recv_pkt_	server.hpp	/^	Packet recv_pkt_;                                   \/\/ receive packet buffer$/;"	m	class:Server	access:private
Server::send	server.cpp	/^void Server::send( const boost::asio::mutable_buffers_1 & buffer, const udp::endpoint & dest )$/;"	f	class:Server	signature:( const boost::asio::mutable_buffers_1 & buffer, const udp::endpoint & dest )
Server::send_handler	server.cpp	/^void Server::send_handler(const boost::system::error_code& ec, size_t length)$/;"	f	class:Server	signature:(const boost::system::error_code& ec, size_t length)
Server::send_sock_	server.hpp	/^	boost::asio::ip::udp::socket send_sock_;            \/\/ main thread socket$/;"	m	class:Server	access:private
Server::server_	server.hpp	/^	static Server * server_;$/;"	m	class:Server	access:private
Server::socket_	server.hpp	/^	boost::asio::ip::udp::socket socket_;               \/\/ main thread socket$/;"	m	class:Server	access:private
Server::start	server.cpp	/^void Server::start()$/;"	f	class:Server	signature:()
Server::start_main	server.cpp	/^void Server::start_main()$/;"	f	class:Server	signature:()
Server::surf_lib_window	server.hpp	/^	SurfLibWindow      * surf_lib_window()     { return &surf_lib_window_; }	$/;"	f	class:Server	access:public	signature:()
Server::surf_lib_window_	server.hpp	/^	SurfLibWindow         surf_lib_window_;				\/\/ window for sending surf lib points$/;"	m	class:Server	access:private
Server::wait_all_end	server.hpp	/^	void wait_all_end()$/;"	f	class:Server	access:public	signature:()
Server::wanna_quit	server.hpp	/^	bool wanna_quit() const { return quit_wanted_; }$/;"	f	class:Server	access:public	signature:() const
ShowResultCommand	command.cpp	/^ShowResultCommand::ShowResultCommand(AppId appid)$/;"	f	class:ShowResultCommand	signature:(AppId appid)
ShowResultCommand	command.hpp	/^class ShowResultCommand : public ICommand$/;"	c	inherits:ICommand
ShowResultCommand::ShowResultCommand	command.cpp	/^ShowResultCommand::ShowResultCommand(AppId appid)$/;"	f	class:ShowResultCommand	signature:(AppId appid)
ShowResultCommand::appid_	command.hpp	/^	AppId appid_;$/;"	m	class:ShowResultCommand	access:private
ShowResultCommand::execute	command.cpp	/^void ShowResultCommand::execute()$/;"	f	class:ShowResultCommand	signature:()
ShowResultCommand::reply	command.cpp	/^void ShowResultCommand::reply()$/;"	f	class:ShowResultCommand	signature:()
SliceLen	matcher_manager.hpp	/^	U08 SliceLen;$/;"	m	struct:DomainInfo	access:public
SpeedPerPipe	matcher_manager.hpp	/^	U32 SpeedPerPipe;$/;"	m	struct:DomainInfo	access:public
State	newlib.h	/^	enum State { SYNC, NUM, DESC };$/;"	g	struct:VideoLibVec	access:private
StepWindow	comm_window.hpp	/^typedef PacketWindow<1> StepWindow;$/;"	t
StreamLine	match_stream.hpp	/^class StreamLine$/;"	c
StreamLine::add_node	match_stream.hpp	/^	void add_node(StreamNode * node)$/;"	f	class:StreamLine	access:public	signature:(StreamNode * node)
StreamLine::nodes_	match_stream.hpp	/^	std::vector< StreamNode * > nodes_;$/;"	m	class:StreamLine	access:private
StreamLine::start_running_stream	match_stream.hpp	/^	void start_running_stream()$/;"	f	class:StreamLine	access:public	signature:()
StreamLine::tg	match_stream.hpp	/^	boost::thread_group tg;$/;"	m	class:StreamLine	access:private
StreamLine::wait_stream_end	match_stream.hpp	/^	void wait_stream_end()$/;"	f	class:StreamLine	access:public	signature:()
StreamLine::~StreamLine	match_stream.hpp	/^	~StreamLine()$/;"	f	class:StreamLine	access:public	signature:()
StreamNode	match_stream.hpp	/^	StreamNode()$/;"	f	class:StreamNode	access:public	signature:()
StreamNode	match_stream.hpp	/^class StreamNode$/;"	c
StreamNode::StreamNode	match_stream.hpp	/^	StreamNode()$/;"	f	class:StreamNode	access:public	signature:()
StreamNode::run	match_stream.hpp	/^	void run()$/;"	f	class:StreamNode	access:public	signature:()
StreamNode::~StreamNode	match_stream.hpp	/^	virtual ~StreamNode() {}$/;"	f	class:StreamNode	access:public	signature:()
StructInfo	matcher_manager.hpp	/^	U16 StructInfo;$/;"	m	struct:DomainInfo	access:public
SurfLibWindow	comm_window.hpp	/^	explicit SurfLibWindow(int timeout = 20)$/;"	f	class:SurfLibWindow	access:public	signature:(int timeout = 20)
SurfLibWindow	comm_window.hpp	/^class SurfLibWindow : public surf_lib_window_base__$/;"	c	inherits:surf_lib_window_base__
SurfLibWindow::SurfLibWindow	comm_window.hpp	/^	explicit SurfLibWindow(int timeout = 20)$/;"	f	class:SurfLibWindow	access:public	signature:(int timeout = 20)
SwapOp	comm_box.hpp	/^struct SwapOp : public std::binary_function< T, T, void >$/;"	s	inherits:std::binary_function
SwapOp::operator ()	comm_box.hpp	/^	void operator () (T & lhs, T & rhs)$/;"	f	struct:SwapOp	access:public	signature:(T & lhs, T & rhs)
THREADS	match_utils.cpp	/^int THREADS = 6;$/;"	v
TIMEOUT	comm_window.hpp	/^	const int TIMEOUT;$/;"	m	class:PacketWindow	access:protected
TO_BE_COLLECTED	matcher_manager.hpp	/^		TO_BE_COLLECTED,				\/\/<! to be collected, won't be target any more$/;"	e	enum:Matcher::MATCHER_STATE
TerminalChangeCommand	command.hpp	/^class TerminalChangeCommand : public ICommand$/;"	c	inherits:ICommand
TerminalChangeCommand::execute	command.hpp	/^	virtual void execute() {}$/;"	f	class:TerminalChangeCommand	access:public	signature:()
TerminalChangeCommand::reply	command.hpp	/^	virtual void reply  () {}$/;"	f	class:TerminalChangeCommand	access:public	signature:()
TerminalId	matcher_manager.hpp	/^	U32 TerminalId;$/;"	m	struct:DomainInfo	access:public
TimeStamp	matcher_manager.hpp	/^	U64 TimeStamp;$/;"	m	struct:AppId	access:public
U08	comm_para.hpp	/^typedef unsigned char      U08;$/;"	t
U16	comm_para.hpp	/^typedef unsigned short     U16;$/;"	t
U32	comm_para.hpp	/^typedef unsigned int       U32;$/;"	t
U64	comm_para.hpp	/^typedef unsigned long long U64;$/;"	t
UDP_HEAD_SIZE	packet.hpp	/^	UDP_HEAD_SIZE = 42,$/;"	e	enum:__anon9
UDP_MAX_DATA_LEN	packet.hpp	/^	UDP_MAX_DATA_LEN     = UDP_MAX_LOAD_LEN - 2,		\/\/ 1470$/;"	e	enum:__anon9
UDP_MAX_LOAD_LEN	packet.hpp	/^	UDP_MAX_LOAD_LEN     = ETH_MAX_LEN - UDP_HEAD_SIZE,		\/\/ 1472$/;"	e	enum:__anon9
UDP_MIN_DATA_LEN	packet.hpp	/^	UDP_MIN_DATA_LEN     = UDP_MIN_LOAD_LEN - 2,		\/\/ 16$/;"	e	enum:__anon9
UDP_MIN_LOAD_LEN	packet.hpp	/^	UDP_MIN_LOAD_LEN     = ETH_MIN_LEN - UDP_HEAD_SIZE,		\/\/ 18$/;"	e	enum:__anon9
UNCONNECTED	matcher_manager.hpp	/^		UNCONNECTED,					\/\/<! unconnected default state$/;"	e	enum:Matcher::MATCHER_STATE
UTILS	utils.h	/^namespace UTILS$/;"	n
UTILS::image	utils.h	/^	struct image$/;"	s	namespace:UTILS
UTILS::image::add_descriptor	utils.h	/^		void add_descriptor(descriptor_type v)$/;"	f	struct:UTILS::image	access:public	signature:(descriptor_type v)
UTILS::image::buff	utils.h	/^		point buff;$/;"	m	struct:UTILS::image	access:private
UTILS::image::check_end_image	utils.h	/^		void check_end_image()$/;"	f	struct:UTILS::image	access:public	signature:()
UTILS::image::frame_index	utils.h	/^		frame_type frame_index;$/;"	m	struct:UTILS::image	access:public
UTILS::image::frame_pos	utils.h	/^		unsigned frame_pos() const { return frame_index & 0x00FFFFFF; }$/;"	f	struct:UTILS::image	access:public	signature:() const
UTILS::image::idx	utils.h	/^		int idx;$/;"	m	struct:UTILS::image	access:private
UTILS::image::image	utils.h	/^		image() : idx(0) {}$/;"	f	struct:UTILS::image	access:public	signature:()
UTILS::image::point	utils.h	/^		struct point$/;"	s	struct:UTILS::image	access:public
UTILS::image::point::descriptor	utils.h	/^			descriptor_type descriptor[64];$/;"	m	struct:UTILS::image::point	access:public
UTILS::image::points	utils.h	/^		std::vector<point> points;$/;"	m	struct:UTILS::image	access:public
UTILS::image::swap	utils.h	/^		void swap(image & other)$/;"	f	struct:UTILS::image	access:public	signature:(image & other)
UTILS::image::video_id	utils.h	/^		unsigned video_id () const { return frame_index >> 24; }$/;"	f	struct:UTILS::image	access:public	signature:() const
UTILS_H	utils.h	13;"	d
VERBOSE	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
VideoCapcture	match_utils.cpp	/^VideoCapcture::VideoCapcture(const string& videoFileName, int capBegin, int capEnd, double capFps)$/;"	f	class:VideoCapcture	signature:(const string& videoFileName, int capBegin, int capEnd, double capFps)
VideoCapcture	match_utils.h	/^struct VideoCapcture {$/;"	s
VideoCapcture::VideoCapcture	match_utils.cpp	/^VideoCapcture::VideoCapcture(const string& videoFileName, int capBegin, int capEnd, double capFps)$/;"	f	class:VideoCapcture	signature:(const string& videoFileName, int capBegin, int capEnd, double capFps)
VideoCapcture::cap_end	match_utils.h	/^	int cap_end;$/;"	m	struct:VideoCapcture	access:private
VideoCapcture::cap_step	match_utils.h	/^	double cap_step;$/;"	m	struct:VideoCapcture	access:private
VideoCapcture::capture	match_utils.h	/^	CvCapture* capture;$/;"	m	struct:VideoCapcture	access:private
VideoCapcture::fps	match_utils.h	/^	double fps;$/;"	m	struct:VideoCapcture	access:public
VideoCapcture::frame_count	match_utils.h	/^	double frame_count;$/;"	m	struct:VideoCapcture	access:public
VideoCapcture::frame_pos	match_utils.h	/^	int frame_pos;$/;"	m	struct:VideoCapcture	access:public
VideoCapcture::get_frame	match_utils.cpp	/^IplImage* VideoCapcture::get_frame() {$/;"	f	class:VideoCapcture	signature:()
VideoCapcture::next_frame	match_utils.h	/^	double next_frame;$/;"	m	struct:VideoCapcture	access:private
VideoCapcture::time_stamp	match_utils.h	/^	double time_stamp;$/;"	m	struct:VideoCapcture	access:public
VideoCapcture::~VideoCapcture	match_utils.cpp	/^VideoCapcture::~VideoCapcture() { cvReleaseCapture(&capture); }$/;"	f	class:VideoCapcture	signature:()
VideoLibRec	newlib.h	/^struct VideoLibRec {$/;"	s
VideoLibRec::num_of_frames	newlib.h	/^	short num_of_frames;$/;"	m	struct:VideoLibRec	access:public
VideoLibRec::point_vec	newlib.h	/^	LibPointVec point_vec;$/;"	m	struct:VideoLibRec	access:public
VideoLibRec::video_num	newlib.h	/^	short video_num;$/;"	m	struct:VideoLibRec	access:public
VideoLibVec	newlib.h	/^	VideoLibVec(int nbits = MAX_FEATURE_BITS) :$/;"	f	struct:VideoLibVec	access:public	signature:(int nbits = MAX_FEATURE_BITS)
VideoLibVec	newlib.h	/^struct VideoLibVec : std::vector<VideoLibRec> {$/;"	s	inherits:std::vector
VideoLibVec::DESC	newlib.h	/^	enum State { SYNC, NUM, DESC };$/;"	e	enum:VideoLibVec::State
VideoLibVec::NUM	newlib.h	/^	enum State { SYNC, NUM, DESC };$/;"	e	enum:VideoLibVec::State
VideoLibVec::SYNC	newlib.h	/^	enum State { SYNC, NUM, DESC };$/;"	e	enum:VideoLibVec::State
VideoLibVec::State	newlib.h	/^	enum State { SYNC, NUM, DESC };$/;"	g	struct:VideoLibVec	access:private
VideoLibVec::VideoLibVec	newlib.h	/^	VideoLibVec(int nbits = MAX_FEATURE_BITS) :$/;"	f	struct:VideoLibVec	access:public	signature:(int nbits = MAX_FEATURE_BITS)
VideoLibVec::np_	newlib.h	/^	int state_, np_, nw_;$/;"	m	struct:VideoLibVec	access:private
VideoLibVec::nw_	newlib.h	/^	int state_, np_, nw_;$/;"	m	struct:VideoLibVec	access:private
VideoLibVec::operator !	newlib.h	/^	bool  operator !() const { return state_ != SYNC; }	\/\/ “Ï≥£◊¥Ã¨$/;"	f	struct:VideoLibVec	access:public	signature:() const
VideoLibVec::operator bool	newlib.h	/^	operator   bool () const { return state_ == SYNC; }	\/\/ ’˝≥£◊¥Ã¨$/;"	f	struct:VideoLibVec	access:public	signature:() const
VideoLibVec::point_	newlib.h	/^	BitFeature point_;$/;"	m	struct:VideoLibVec	access:private
VideoLibVec::reset	newlib.h	/^	void reset(int nbits) {$/;"	f	struct:VideoLibVec	access:public	signature:(int nbits)
VideoLibVec::state_	newlib.h	/^	int state_, np_, nw_;$/;"	m	struct:VideoLibVec	access:private
VideoLibVec::store	newlib.cpp	/^void VideoLibVec::store(unsigned int word, bool from_net) {$/;"	f	class:VideoLibVec	signature:(unsigned int word, bool from_net)
VideoLibVec::total_frames	newlib.h	/^	int total_frames() const { return total_frames_; }$/;"	f	struct:VideoLibVec	access:public	signature:() const
VideoLibVec::total_frames_	newlib.h	/^	int total_frames_;$/;"	m	struct:VideoLibVec	access:private
VideoMatcher	match_utils.h	/^	VideoMatcher(const VideoLibVec& lib) : lib_(lib) {}$/;"	f	class:VideoMatcher	access:public	signature:(const VideoLibVec& lib)
VideoMatcher	match_utils.h	/^class VideoMatcher {$/;"	c
VideoMatcher::VideoMatcher	match_utils.h	/^	VideoMatcher(const VideoLibVec& lib) : lib_(lib) {}$/;"	f	class:VideoMatcher	access:public	signature:(const VideoLibVec& lib)
VideoMatcher::clear	match_utils.h	/^	void clear() { sec_man_.clear(); }$/;"	f	class:VideoMatcher	access:public	signature:()
VideoMatcher::lib_	match_utils.h	/^	const VideoLibVec& lib_;$/;"	m	class:VideoMatcher	access:private
VideoMatcher::match_frames	match_utils.cpp	/^void VideoMatcher::match_frames(const LibPointVec& frames, int frame_begin) {$/;"	f	class:VideoMatcher	signature:(const LibPointVec& frames, int frame_begin)
VideoMatcher::match_video	match_utils.cpp	/^void VideoMatcher::match_video(int video_id, const LibPointVec& video_points, int frame_start, int frame_end) {$/;"	f	class:VideoMatcher	signature:(int video_id, const LibPointVec& video_points, int frame_start, int frame_end)
VideoMatcher::match_video	match_utils.cpp	/^void VideoMatcher::match_video(int video_id, const std::string& video_file, int frame_start, int frame_end) {$/;"	f	class:VideoMatcher	signature:(int video_id, const std::string& video_file, int frame_start, int frame_end)
VideoMatcher::results	match_utils.h	/^	const MatchResults& results() const { return sec_man_.results(); }$/;"	f	class:VideoMatcher	access:public	signature:() const
VideoMatcher::sec_man_	match_utils.h	/^	SectionManager sec_man_;$/;"	m	class:VideoMatcher	access:private
WAIT_LIB_LOAD	matcher_manager.hpp	/^		WAIT_LIB_LOAD,					\/\/<! connected but lib not loaded$/;"	e	enum:Matcher::MATCHER_STATE
WANNA_QUIT	comm_para.hpp	/^	const u_char      WANNA_QUIT          = 0x40;$/;"	m	namespace:__anon4
WARN	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
Word	bit_feature.h	/^	typedef unsigned int  Word;			\/\/ 32 bit$/;"	t	class:BitFeature	access:public
__anon1::dump_packets	server.cpp	/^	void dump_packets( Packet & pkt, ostream & out ) {$/;"	f	namespace:__anon1	signature:( Packet & pkt, ostream & out )
__anon1::dump_packets	server.cpp	/^	void dump_packets( char * pc, unsigned len, ostream & out ) {$/;"	f	namespace:__anon1	signature:( char * pc, unsigned len, ostream & out )
__anon2::load_compare	matcher_manager.cpp	/^	bool load_compare(MatcherPtr lhs, MatcherPtr rhs, unsigned short thres)$/;"	f	namespace:__anon2	signature:(MatcherPtr lhs, MatcherPtr rhs, unsigned short thres)
__anon3::node_id_to_ip	command.cpp	/^	const std::string node_id_to_ip(unsigned node_id)$/;"	f	namespace:__anon3	signature:(unsigned node_id)
__anon3::u_char_to_decimal_string	command.cpp	/^	const std::string u_char_to_decimal_string(u_char c)$/;"	f	namespace:__anon3	signature:(u_char c)
__anon4::BITFEATURE_TYPE	comm_para.hpp	/^	const u_char      BITFEATURE_TYPE     = 0x04;$/;"	m	namespace:__anon4
__anon4::CONN_BUILD	comm_para.hpp	/^	const u_char      CONN_BUILD          = 0x70;$/;"	m	namespace:__anon4
__anon4::CTRL_PAUSE	comm_para.hpp	/^	const u_char      CTRL_PAUSE          = 0xFF;$/;"	m	namespace:__anon4
__anon4::CTRL_RECOVER	comm_para.hpp	/^	const u_char      CTRL_RECOVER        = 0x00;$/;"	m	namespace:__anon4
__anon4::EXTRACT_END	comm_para.hpp	/^	const u_char      EXTRACT_END         = 0x2C;$/;"	m	namespace:__anon4
__anon4::EXTRACT_RECVING	comm_para.hpp	/^	const u_char      EXTRACT_RECVING     = 0x0C;$/;"	m	namespace:__anon4
__anon4::IMG_ALL_END	comm_para.hpp	/^	const u_char      IMG_ALL_END         = 0x66;$/;"	m	namespace:__anon4
__anon4::IMG_END	comm_para.hpp	/^	const u_char      IMG_END             = 0x26;$/;"	m	namespace:__anon4
__anon4::IMG_SENDING	comm_para.hpp	/^	const u_char      IMG_SENDING         = 0x06;$/;"	m	namespace:__anon4
__anon4::IMG_START	comm_para.hpp	/^	const u_char      IMG_START           = 0x16;$/;"	m	namespace:__anon4
__anon4::LIB_END	comm_para.hpp	/^	const u_char      LIB_END             = 0x22;$/;"	m	namespace:__anon4
__anon4::LIB_SENDING	comm_para.hpp	/^	const u_char      LIB_SENDING         = 0x02;$/;"	m	namespace:__anon4
__anon4::LIB_START	comm_para.hpp	/^	const u_char      LIB_START           = 0x12;$/;"	m	namespace:__anon4
__anon4::MATCH_END	comm_para.hpp	/^	const u_char      MATCH_END           = 0x28;$/;"	m	namespace:__anon4
__anon4::MATCH_RECVING	comm_para.hpp	/^	const u_char      MATCH_RECVING       = 0x08;$/;"	m	namespace:__anon4
__anon4::MATCH_WIDTH	comm_para.hpp	/^	const int         MATCH_WIDTH         = 128;$/;"	m	namespace:__anon4
__anon4::POINT_ALL_END	comm_para.hpp	/^	const u_char      POINT_ALL_END       = 0x64;$/;"	m	namespace:__anon4
__anon4::POINT_END	comm_para.hpp	/^	const u_char      POINT_END           = 0x24;$/;"	m	namespace:__anon4
__anon4::POINT_SENDING	comm_para.hpp	/^	const u_char      POINT_SENDING       = 0x04;$/;"	m	namespace:__anon4
__anon4::POINT_START	comm_para.hpp	/^	const u_char      POINT_START         = 0x14;$/;"	m	namespace:__anon4
__anon4::QUITED	comm_para.hpp	/^	const u_char      QUITED              = 0x50;$/;"	m	namespace:__anon4
__anon4::SEND_LIB_PKT_SIZE	comm_para.hpp	/^	const int         SEND_LIB_PKT_SIZE   = 1472;$/;"	m	namespace:__anon4
__anon4::SYNCWORD	comm_para.hpp	/^	const int         SYNCWORD            = 0xFADCCAFD;$/;"	m	namespace:__anon4
__anon4::SYNCWORD_END	comm_para.hpp	/^	const int         SYNCWORD_END        = 0xAFCDACDF;$/;"	m	namespace:__anon4
__anon4::WANNA_QUIT	comm_para.hpp	/^	const u_char      WANNA_QUIT          = 0x40;$/;"	m	namespace:__anon4
__anon5::dist_table	bit_feature.cpp	/^	char dist_table[256] = {$/;"	m	namespace:__anon5	file:
__anon5::order_pairs128	bit_feature.cpp	/^	const int order_pairs128[128][2] = {$/;"	m	namespace:__anon5	file:
__anon5::order_pairs32	bit_feature.cpp	/^	const int order_pairs32[32][2] = {$/;"	m	namespace:__anon5	file:
__anon6::ctoh	raw.cpp	/^inline int ctoh(char c) {$/;"	f	namespace:__anon6	signature:(char c)
__anon6::htoc	raw.cpp	/^inline int htoc(unsigned int h) {$/;"	f	namespace:__anon6	signature:(unsigned int h)
__anon8::norm_dcsp_msg_id	command_recv_service.cpp	/^	unsigned norm_dcsp_msg_id( unsigned id )$/;"	f	namespace:__anon8	signature:( unsigned id )
_def	fdutils.h	/^	const E   _def;$/;"	m	class:EnumStringMap	access:private
_size	fdutils.h	/^	const int _size;$/;"	m	class:EnumStringMap	access:private
_str_table	fdutils.h	/^	const char * const * _str_table;$/;"	m	class:EnumStringMap	access:private
abs_	fdutils.h	/^template<typename T> inline T abs_(T x) { return x >= 0 ? x : -x; }$/;"	f	signature:(T x)
acquire	comm_box.hpp	/^	T * acquire()$/;"	f	class:RandomGetBox	access:public	signature:()
acquire	comm_window.hpp	/^	Packet * acquire()$/;"	f	class:PacketWindow	access:public	signature:()
add_descriptor	utils.h	/^		void add_descriptor(descriptor_type v)$/;"	f	struct:UTILS::image	access:public	signature:(descriptor_type v)
add_domain	matcher_manager.hpp	/^	static bool add_domain(DomainInfoPtr pd)$/;"	f	struct:DomainInfo	access:public	signature:(DomainInfoPtr pd)
add_matcher	matcher_manager.cpp	/^void MatcherManager::add_matcher( MatcherPtr m )$/;"	f	class:MatcherManager	signature:( MatcherPtr m )
add_matcher	matcher_manager.cpp	/^void MatcherManager::add_matcher( MatcherPtr m, Matchers & ms )$/;"	f	class:MatcherManager	signature:( MatcherPtr m, Matchers & ms )
add_node	match_stream.hpp	/^	void add_node(StreamNode * node)$/;"	f	class:StreamLine	access:public	signature:(StreamNode * node)
add_section	app_manager.hpp	/^	void add_section(const MatchSection & sec) { sec_man_.add_section(sec); }$/;"	f	class:AppDomain	access:public	signature:(const MatchSection & sec)
add_section	match_utils.cpp	/^void SectionManager::add_section(const MatchSection& sec) {$/;"	f	class:SectionManager	signature:(const MatchSection& sec)
add_section	match_utils.cpp	/^void SectionManagerSimp::add_section(const MatchSection& sec) {$/;"	f	class:SectionManagerSimp	signature:(const MatchSection& sec)
add_target_node	command.hpp	/^	void add_target_node(unsigned node_id)$/;"	f	class:AddNodesCommand	access:public	signature:(unsigned node_id)
add_target_node	command.hpp	/^	void add_target_node(unsigned node_id)$/;"	f	class:RemoveNodesCommand	access:public	signature:(unsigned node_id)
add_testid	app_manager.hpp	/^	void add_testid(unsigned testid) { testid_set_.insert(testid); }$/;"	f	class:AppDomain	access:public	signature:(unsigned testid)
addr	server.hpp	/^	const boost::asio::ip::address addr() const { return local_point_.address(); }$/;"	f	class:Server	access:public	signature:() const
addr_len	raw.hpp	/^	static const int addr_len = 6;$/;"	m	class:eth::address	access:public
addr_type	server.hpp	/^typedef boost::asio::ip::address addr_type;$/;"	t
address	matcher_manager.hpp	/^	const ip_address    address() const { return endpoint_.address(); }$/;"	f	class:Matcher	access:public	signature:() const
address	raw.cpp	/^address::address(const string& str) {$/;"	f	class:eth::address	signature:(const string& str)
address	raw.cpp	/^address::address(const unsigned char* bytes, unsigned int len) {$/;"	f	class:eth::address	signature:(const unsigned char* bytes, unsigned int len)
address	raw.hpp	/^	eth::address address() const { return eth::address(data_.sll_addr, data_.sll_halen); }$/;"	f	class:eth::endpoint	access:public	signature:() const
address	raw.hpp	/^class address {			\/\/ ethernet address$/;"	c	namespace:eth
all_comm_end	server.cpp	/^bool Server::all_comm_end() const$/;"	f	class:Server	signature:() const
all_comm_end_	server.hpp	/^	bool all_comm_end_;									\/\/ all communicatioin end flag$/;"	m	class:Server	access:private
all_put	comm_box.cpp	/^bool Basebox::all_put() const { return all_put_; }$/;"	f	class:Basebox	signature:() const
all_put_	comm_box.hpp	/^	bool all_put_;$/;"	m	class:Basebox	access:protected
app_	match_stream.hpp	/^	AppDomainPtr app_;$/;"	m	class:BitFeatureLoader	access:private
app_	match_stream.hpp	/^	AppDomainPtr app_;$/;"	m	class:BitFeatureSender	access:private
app_id_	command.hpp	/^	AppId app_id_;$/;"	m	class:AddNodesCommand	access:private
app_id_	command.hpp	/^	AppId app_id_;$/;"	m	class:RemoveNodesCommand	access:private
appid	app_manager.hpp	/^	const AppId appid() const { return appid_; }$/;"	f	class:AppDomain	access:public	signature:() const
appid_	app_manager.hpp	/^	AppId appid_;$/;"	m	class:AppDomain	access:private
appid_	command.hpp	/^	AppId appid_;$/;"	m	class:QueryLoadsCommand	access:private
appid_	command.hpp	/^	AppId appid_;$/;"	m	class:ShowResultCommand	access:private
arg	server.hpp	/^	CommArg * arg() { return arg_; }$/;"	f	class:Server	access:public	signature:()
arg_	server.hpp	/^	CommArg * arg_;									   	\/\/ arg$/;"	m	class:Server	access:private
args_table	match_utils.cpp	/^static const int args_table[][4] = {$/;"	v	file:
at	integral.h	/^	int at(int r, int c) const {	\/\/ get the pixel with bound check$/;"	f	struct:IntImage	access:public	signature:(int r, int c) const
balance_threshold	comm_arg.hpp	/^	int balance_threshold;$/;"	m	struct:CommArg	access:public
batch_len	match_utils.h	/^	int batch_len;			\/\/ √ø◊È∆•≈‰÷° ˝$/;"	m	struct:MatchArgs	access:public
begin	fdutils.h	/^	int begin, end;$/;"	m	struct:Range	access:public
bind_device	raw.hpp	/^	void bind_device(const char* dev) {$/;"	f	struct:eth::socket	access:public	signature:(const char* dev)
bind_ip	comm_arg.hpp	/^	std::string    bind_ip;$/;"	m	struct:CommArg	access:public
bitfeature_all_sent	server.hpp	/^	bool bitfeature_all_sent() const { return bitfeature_all_sent_; }$/;"	f	class:Server	access:public	signature:() const
bitfeature_all_sent_	server.hpp	/^	bool bitfeature_all_sent_;$/;"	m	class:Server	access:private
bitfeature_loader	app_manager.hpp	/^	BitFeatureLoader * bitfeature_loader() { return loader_; }$/;"	f	class:AppDomain	access:public	signature:()
bitfeature_loader	server.hpp	/^	BitFeatureLoader   * bitfeature_loader()   const { return bitfeature_loader_; }$/;"	f	class:Server	access:public	signature:() const
bitfeature_loader_	server.hpp	/^	BitFeatureLoader   * bitfeature_loader_;$/;"	m	class:Server	access:private
bitfeature_sender	app_manager.hpp	/^	BitFeatureSender * bitfeature_sender() { return sender_; }$/;"	f	class:AppDomain	access:public	signature:()
bitfeature_sender	server.hpp	/^	BitFeatureSender   * bitfeature_sender()   const { return bitfeature_sender_; }$/;"	f	class:Server	access:public	signature:() const
bitfeature_sender_	server.hpp	/^	BitFeatureSender   * bitfeature_sender_;$/;"	m	class:Server	access:private
bitfeature_window	server.hpp	/^	BitFeatureWindow   * bitfeature_window()   { return &bitfeature_window_; }$/;"	f	class:Server	access:public	signature:()
bitfeature_window_	server.hpp	/^	BitFeatureWindow      bitfeature_window_;			\/\/ window for sending bitfeature$/;"	m	class:Server	access:private
bitfeature_window_base__	comm_window.hpp	/^typedef PacketWindow<16> bitfeature_window_base__;$/;"	t
bits	bits.hpp	/^	bits(int n) { set_size(n); clr(); }$/;"	f	struct:bits	access:public	signature:(int n)
bits	bits.hpp	/^	bits(unsigned char * p, int len) { set_size(len << SHIFT); memcpy(byte_ptr(), p, len); }$/;"	f	struct:bits	access:public	signature:(unsigned char * p, int len)
bits	bits.hpp	/^struct bits$/;"	s
bits::MASK	bits.hpp	/^	static const unsigned char MASK = 0x07;$/;"	m	struct:bits	access:public
bits::N	bits.hpp	/^	int N;$/;"	m	struct:bits	access:public
bits::SHIFT	bits.hpp	/^	static const unsigned char SHIFT = 3;$/;"	m	struct:bits	access:public
bits::bits	bits.hpp	/^	bits(int n) { set_size(n); clr(); }$/;"	f	struct:bits	access:public	signature:(int n)
bits::bits	bits.hpp	/^	bits(unsigned char * p, int len) { set_size(len << SHIFT); memcpy(byte_ptr(), p, len); }$/;"	f	struct:bits	access:public	signature:(unsigned char * p, int len)
bits::byte_ptr	bits.hpp	/^	unsigned char * byte_ptr() { return &bytes[0]; }$/;"	f	struct:bits	access:public	signature:()
bits::bytes	bits.hpp	/^	std::vector< unsigned char > bytes;$/;"	m	struct:bits	access:private
bits::clr	bits.hpp	/^	void clr (int i) { ASSERTS(i < N);        bytes[i >> SHIFT] &= ~(0x80 >> (i & MASK)); }$/;"	f	struct:bits	access:public	signature:(int i)
bits::clr	bits.hpp	/^	void clr()       { memset(byte_ptr(), 0x00, N >> SHIFT); }$/;"	f	struct:bits	access:public	signature:()
bits::set	bits.hpp	/^	void set (int i) { ASSERTS(i < N);        bytes[i >> SHIFT] |=  (0x80 >> (i & MASK)); }$/;"	f	struct:bits	access:public	signature:(int i)
bits::set	bits.hpp	/^	void set()       { memset(byte_ptr(), 0xFF, N >> SHIFT); }$/;"	f	struct:bits	access:public	signature:()
bits::set_size	bits.hpp	/^	void set_size(int n)$/;"	f	struct:bits	access:public	signature:(int n)
bits::test	bits.hpp	/^	bool test(int i) { ASSERTS(i < N); return bytes[i >> SHIFT] &   (0x80 >> (i & MASK)); }$/;"	f	struct:bits	access:public	signature:(int i)
bits::to_int	bits.hpp	/^	int to_int() {$/;"	f	struct:bits	access:public	signature:()
bits::to_string	bits.hpp	/^	std::string to_string() {$/;"	f	struct:bits	access:public	signature:()
box_empty	comm_box.hpp	/^	bool box_empty() const { return num_elements() == 0; }$/;"	f	class:Basebox	access:public	signature:() const
box_full	comm_box.hpp	/^	bool box_full()  const { return num_elements() == capacity(); }$/;"	f	class:Basebox	access:public	signature:() const
broadcast	raw.hpp	/^	static address broadcast() { return address("ff ff ff ff ff ff"); }$/;"	f	class:eth::address	access:public	signature:()
buff	comm_box.hpp	/^	std::vector< T > buff;$/;"	m	class:RandomGetBox	access:protected
buff	utils.h	/^		point buff;$/;"	m	struct:UTILS::image	access:private
buffer_send_center	command_recv_service.cpp	/^void CommandRecvService::buffer_send_center()$/;"	f	class:CommandRecvService	signature:()
built_	match_stream.hpp	/^	bool built_;$/;"	m	class:ConnectionBuilder	access:private
byte_ptr	bits.hpp	/^	unsigned char * byte_ptr() { return &bytes[0]; }$/;"	f	struct:bits	access:public	signature:()
bytes	bit_feature.h	/^		Byte   bytes[MAX_FEATURE_BITS\/ 8];$/;"	m	union:BitFeature::__anon7	access:public
bytes	bits.hpp	/^	std::vector< unsigned char > bytes;$/;"	m	struct:bits	access:private
bytes_	packet.hpp	/^	u_char bytes_[HEAD_SIZE + N];$/;"	m	class:BasicPacket	access:protected
bytes_	raw.hpp	/^	bytes_type bytes_;$/;"	m	class:eth::address	access:private
bytes_type	raw.hpp	/^	typedef unsigned char bytes_type[addr_len];$/;"	t	class:eth::address	access:public
c_get	comm_box.hpp	/^	boost::condition c_put, c_get;$/;"	m	class:Basebox	access:protected
c_put	comm_box.hpp	/^	boost::condition c_put, c_get;$/;"	m	class:Basebox	access:protected
c_wait_	connection_build_service.hpp	/^	boost::condition c_wait_;$/;"	m	class:ConnectionBuilderService	access:private
c_wait_	lib_load_service.hpp	/^	boost::condition c_wait_;$/;"	m	class:LibLoadService	access:private
c_wait_	match_stream.hpp	/^	boost::condition c_wait_;$/;"	m	class:ConnectionBuilder	access:private
c_wait_	matcher_manager.hpp	/^	boost::condition c_wait_;$/;"	m	class:MatcherManager	access:private
c_wait_	server.hpp	/^	boost::condition c_wait_;$/;"	m	class:Server	access:private
cap_end	match_utils.h	/^	int cap_end;$/;"	m	struct:VideoCapcture	access:private
cap_step	match_utils.h	/^	double cap_step;$/;"	m	struct:VideoCapcture	access:private
capacity	comm_box.hpp	/^	virtual std::size_t capacity()     const { return 1; }$/;"	f	class:CommBox	access:public	signature:() const
capacity	comm_box.hpp	/^	virtual std::size_t capacity()     const { return N; }$/;"	f	class:RandomGetBox	access:public	signature:() const
capacity	comm_box.hpp	/^	virtual std::size_t capacity()     const$/;"	f	class:CommQueue	access:public	signature:() const
capacity	comm_window.hpp	/^	virtual std::size_t capacity() const { return N; }$/;"	f	class:PacketWindow	access:public	signature:() const
capacity	raw.hpp	/^	std::size_t capacity() const { return sizeof(sockaddr_ll); }$/;"	f	class:eth::endpoint	access:public	signature:() const
capture	match_utils.h	/^	CvCapture* capture;$/;"	m	struct:VideoCapcture	access:private
cast	utils.h	/^T & cast(void * p)$/;"	f	signature:(void * p)
cfa_udp_packet_base__	packet.hpp	/^typedef BasicPacket< CFA_UDP_HEAD_SIZE, CFA_UDP_MAX_LOAD_LEN > cfa_udp_packet_base__;$/;"	t
cfa_udp_response_packet_base__	packet.hpp	/^typedef BasicPacket< CFA_UDP_HEAD_SIZE, CFA_UDP_MIN_LOAD_LEN > cfa_udp_response_packet_base__;$/;"	t
chains_	match_utils.h	/^	std::map<long long, Chain> chains_;			\/\/  π”√offset_id◊˜Œ™key$/;"	m	class:SectionManager	access:private
check_and_put	match_stream.cpp	24;"	d	file:
check_end_image	utils.h	/^		void check_end_image()$/;"	f	struct:UTILS::image	access:public	signature:()
check_load_len	packet.hpp	/^	void check_load_len( unsigned n )$/;"	f	class:BasicPacket	access:protected	signature:( unsigned n )
choose_next_matcher	matcher_manager.cpp	/^MatcherPtr MatcherManager::choose_next_matcher()$/;"	f	class:MatcherManager	signature:()
choose_next_matcher_for_domain	matcher_manager.cpp	/^MatcherPtr MatcherManager::choose_next_matcher_for_domain(DomainType domain)$/;"	f	class:MatcherManager	signature:(DomainType domain)
circular_buf	comm_window.hpp	/^	std::vector<Packet> circular_buf;$/;"	m	class:PacketWindow	access:protected
clear	bit_feature.h	/^	void clear() { dwords[0] = dwords[1] = 0; }$/;"	f	class:BitFeature	access:public	signature:()
clear	match_utils.h	/^	void clear() { chains_.clear(); }$/;"	f	class:SectionManager	access:public	signature:()
clear	match_utils.h	/^	void clear() { results_.clear(); }$/;"	f	class:SectionManagerSimp	access:public	signature:()
clear	match_utils.h	/^	void clear() { sec_man_.clear(); }$/;"	f	class:VideoMatcher	access:public	signature:()
clear_result_count	matcher_manager.hpp	/^	void clear_result_count() { result_count_ = 0; }$/;"	f	class:Matcher	access:public	signature:()
client_	command_recv_service.hpp	/^	datagram_protocol::endpoint client_;$/;"	m	class:CommandRecvService	access:private
client_addrs	comm_arg.hpp	/^	std::vector<std::string> client_addrs;$/;"	m	struct:CommArg	access:public
clr	bits.hpp	/^	void clr (int i) { ASSERTS(i < N);        bytes[i >> SHIFT] &= ~(0x80 >> (i & MASK)); }$/;"	f	struct:bits	access:public	signature:(int i)
clr	bits.hpp	/^	void clr()       { memset(byte_ptr(), 0x00, N >> SHIFT); }$/;"	f	struct:bits	access:public	signature:()
clusterIndex	ipoint.h	/^	int clusterIndex;		\/\/! Used to store cluster index$/;"	m	struct:Ipoint	access:public
cmd_queue_	server.hpp	/^	CommandQueue          cmd_queue_;$/;"	m	class:Server	access:private
comm_arg	comm_arg.hpp	/^	static CommArg & comm_arg()$/;"	f	struct:CommArg	access:public	signature:()
command_bind_ip	comm_arg.hpp	/^	std::string command_bind_ip;$/;"	m	struct:CommArg	access:public
command_bind_port	comm_arg.hpp	/^	unsigned short command_bind_port;$/;"	m	struct:CommArg	access:public
command_execute_loop	command_recv_service.cpp	/^void CommandRecvService::command_execute_loop()$/;"	f	class:CommandRecvService	signature:()
command_queue	server.hpp	/^	CommandQueue       * command_queue()       { return &cmd_queue_; }$/;"	f	class:Server	access:public	signature:()
command_window	server.hpp	/^	CommandWindow      * command_window()      { return &command_window_; }$/;"	f	class:Server	access:public	signature:()
command_window_	server.hpp	/^	CommandWindow         command_window_;				\/\/ window for sending msg to DCSP$/;"	m	class:Server	access:private
command_window_base__	comm_window.hpp	/^typedef PacketWindow<16> command_window_base__;$/;"	t
con_sink	log.h	/^		sp_stream_sink con_sink()  { return sink_con_;  }$/;"	f	class:LOG::Log	access:public	signature:()
confirm	comm_window.hpp	/^	bool confirm(unsigned char index)$/;"	f	class:PacketWindow	access:public	signature:(unsigned char index)
conn_build_wait_time	comm_arg.hpp	/^	int conn_build_wait_time;$/;"	m	struct:CommArg	access:public
conn_task_	match_stream.cpp	/^std::map<endpoint, ConnectionBuilder *> ConnectionBuilder::conn_task_;$/;"	m	class:ConnectionBuilder	file:
conn_task_	match_stream.hpp	/^	static std::map<endpoint, ConnectionBuilder *> conn_task_;$/;"	m	class:ConnectionBuilder	access:private
connect_matcher	connection_build_service.cpp	/^void ConnectionBuilderService::connect_matcher( MatcherPtr m )$/;"	f	class:ConnectionBuilderService	signature:( MatcherPtr m )
connect_matcher	matcher_manager.cpp	/^void MatcherManager::connect_matcher( const Matcher & m )$/;"	f	class:MatcherManager	signature:( const Matcher & m )
consider_extract_mac	comm_arg.hpp	/^	int consider_extract_mac;$/;"	m	struct:CommArg	access:public
consider_timeout	comm_window.hpp	/^	bool consider_timeout;$/;"	m	class:PacketWindow	access:protected
construct_server	server.hpp	/^	static void construct_server( CommArg * arg )$/;"	f	class:Server	access:public	signature:( CommArg * arg )
core_	log.h	/^		sp_log_core    core_;$/;"	m	class:LOG::Log	access:private
cos_ori	ipoint.h	/^	float sin_ori, cos_ori;	\/\/! sin(orientation) and cos(orientation)$/;"	m	struct:Ipoint	access:public
create_app	app_manager.cpp	/^bool AppManager::create_app(DomainInfoPtr pd)$/;"	f	class:AppManager	signature:(DomainInfoPtr pd)
create_app_threads	app_manager.cpp	/^void AppManager::create_app_threads(AppDomainPtr pa)$/;"	f	class:AppManager	signature:(AppDomainPtr pa)
ctoh	raw.cpp	/^inline int ctoh(char c) {$/;"	f	namespace:__anon6	signature:(char c)
ctrl	packet.hpp	/^	u_char          ctrl() const   { return bytes_[HEAD_SIZE + 2]; }$/;"	f	class:BasicPacket	access:public	signature:() const
curr	comm_box.hpp	/^	int curr;$/;"	m	class:RandomGetBox	access:protected
curr	comm_window.hpp	/^	std::size_t curr;	\/\/ ÷∏œÚµ±«∞∑¢ÀÕµƒ∞¸£¨”…get()∑µªÿ$/;"	m	class:PacketWindow	access:protected
data	comm_box.hpp	/^	T data;$/;"	m	class:CommBox	access:protected
data	raw.hpp	/^	const data_type* data() const { return (data_type*)&data_; }$/;"	f	class:eth::endpoint	access:public	signature:() const
data	raw.hpp	/^	data_type* data() { return (data_type*)&data_; }$/;"	f	class:eth::endpoint	access:public	signature:()
data	raw.hpp	/^	void* data() { return (void*)&ifr_; }$/;"	f	class:eth::device_config	access:public	signature:()
data_	integral.h	/^	T*  data_;              \/\/ Pointer to image data$/;"	m	class:Image	access:protected
data_	raw.hpp	/^	sockaddr_ll data_;$/;"	m	class:eth::endpoint	access:private
data_len	packet.hpp	/^	int      data_len() const { return data_len_; }$/;"	f	class:BasicPacket	access:public	signature:() const
data_len_	packet.hpp	/^	int data_len_;$/;"	m	class:BasicPacket	access:protected
data_ptr	packet.hpp	/^    u_char * data_ptr()  { return bytes_ + HEAD_SIZE + 2; }$/;"	f	class:BasicPacket	access:public	signature:()
data_type	raw.hpp	/^	typedef boost::asio::detail::socket_addr_type data_type;$/;"	t	class:eth::endpoint	access:public
data_valid	comm_box.hpp	/^	bool data_valid;$/;"	m	class:CommBox	access:protected
deadline_	server.hpp	/^	boost::asio::deadline_timer deadline_;              \/\/ timer for getting mac$/;"	m	class:Server	access:private
debug	comm_arg.hpp	/^	int debug;$/;"	m	struct:CommArg	access:public
delete_chains	match_utils.cpp	/^void SectionManager::delete_chains(int test_id) {$/;"	f	class:SectionManager	signature:(int test_id)
delete_results	match_utils.cpp	/^void SectionManagerSimp::delete_results(int test_id) {$/;"	f	class:SectionManagerSimp	signature:(int test_id)
demark_first_flag	matcher_manager.hpp	/^	void demark_first_flag() { first_flag_ = false; }$/;"	f	class:Matcher	access:public	signature:()
descriptor	ipoint.h	/^	float descriptor[64];	\/\/! Vector of descriptor components$/;"	m	struct:Ipoint	access:public
descriptor	ipoint.h	/^	float descriptor[64];	\/\/! Vector of descriptor components$/;"	m	struct:LibIpt	access:public
descriptor	utils.h	/^			descriptor_type descriptor[64];$/;"	m	struct:UTILS::image::point	access:public
dest_	match_stream.hpp	/^	const endpoint dest_;$/;"	m	class:ConnectionBuilder	access:private
dest_	match_stream.hpp	/^	const endpoint dest_;$/;"	m	class:NewLibSender	access:private
dest_addr	match_stream.cpp	/^const endpoint BitFeatureSender::dest_addr() const $/;"	f	class:BitFeatureSender	signature:() const
dest_addr_	match_stream.hpp	/^	endpoint dest_addr_;$/;"	m	class:BitFeatureSender	access:private
device	comm_arg.hpp	/^	std::string    device;$/;"	m	struct:CommArg	access:public
device_config	raw.cpp	/^device_config::device_config(int request, const char* dev) : req_(request) {$/;"	f	class:eth::device_config	signature:(int request, const char* dev)
device_config	raw.hpp	/^class device_config {$/;"	c	namespace:eth
diag_test_thres	match_utils.h	/^	int diag_test_thres;	\/\/ √ø◊È∆•≈‰Ω·π˚≈–∂œ„–÷µ$/;"	m	struct:MatchArgs	access:public
dist	ipoint.h	/^	D dist;$/;"	m	class:Matches	access:private
dist_table	bit_feature.cpp	/^	char dist_table[256] = {$/;"	m	namespace:__anon5	file:
do_build_connection	match_stream.cpp	/^void ConnectionBuilder::do_build_connection( const endpoint & dest )$/;"	f	class:ConnectionBuilder	signature:( const endpoint & dest )
do_end_task	match_stream.cpp	/^void BitFeatureLoader::do_end_task()$/;"	f	class:BitFeatureLoader	signature:()
do_end_task	match_stream.cpp	/^void BitFeatureSender::do_end_task()$/;"	f	class:BitFeatureSender	signature:()
do_end_task	match_stream.cpp	/^void ConnectionBuilder::do_end_task()$/;"	f	class:ConnectionBuilder	signature:()
do_end_task	match_stream.cpp	/^void NewLibLoader::do_end_task()$/;"	f	class:NewLibLoader	signature:()
do_end_task	match_stream.cpp	/^void NewLibSender::do_end_task()$/;"	f	class:NewLibSender	signature:()
do_hton	command.hpp	/^	void do_hton() {$/;"	f	struct:DCSPPacket	access:public	signature:()
do_ntoh	command.hpp	/^	void do_ntoh() {$/;"	f	struct:DCSPPacket	access:public	signature:()
do_run_task	match_stream.cpp	/^void BitFeatureLoader::do_run_task()$/;"	f	class:BitFeatureLoader	signature:()
do_run_task	match_stream.cpp	/^void BitFeatureSender::do_run_task()$/;"	f	class:BitFeatureSender	signature:()
do_run_task	match_stream.cpp	/^void ConnectionBuilder::do_run_task()$/;"	f	class:ConnectionBuilder	signature:()
do_run_task	match_stream.cpp	/^void NewLibLoader::do_run_task()$/;"	f	class:NewLibLoader	signature:()
do_run_task	match_stream.cpp	/^void NewLibSender::do_run_task()$/;"	f	class:NewLibSender	signature:()
do_send_lib	comm_arg.hpp	/^	int do_send_lib;$/;"	m	struct:CommArg	access:public
do_surf	comm_arg.hpp	/^	int do_surf;$/;"	m	struct:CommArg	access:public
domain_	command.hpp	/^	DomainInfoPtr domain_;$/;"	m	class:DomainCreateCommand	access:private
domain_id	matcher_manager.hpp	/^	DomainType domain_id() const { return domain_id_; }$/;"	f	class:Matcher	access:public	signature:() const
domain_id_	matcher_manager.hpp	/^	DomainType domain_id_;$/;"	m	class:Matcher	access:private
domain_info_ptr	app_manager.hpp	/^	DomainInfoPtr domain_info_ptr() { return domaininfo_; }$/;"	f	class:AppDomain	access:public	signature:()
domaininfo_	app_manager.hpp	/^	DomainInfoPtr domaininfo_;$/;"	m	class:AppDomain	access:private
domains	matcher_manager.hpp	/^	static DomainMap domains;	\/\/ public$/;"	m	struct:DomainInfo	access:public
domains_	app_manager.hpp	/^	AppDomainMap domains_;$/;"	m	class:AppManager	access:private
drawFPS	utils.cpp	/^void drawFPS(IplImage *img)$/;"	f	signature:(IplImage *img)
drawIpoint	utils.cpp	/^void drawIpoint(IplImage *img, const Ipoint &ipt, int tailSize)$/;"	f	signature:(IplImage *img, const Ipoint &ipt, int tailSize)
drawIpoints	utils.cpp	/^void drawIpoints(IplImage *img, vector<Ipoint> &ipts, int tailSize)$/;"	f	signature:(IplImage *img, vector<Ipoint> &ipts, int tailSize)
drawPoint	utils.cpp	/^void drawPoint(IplImage *img, const Ipoint &ipt)$/;"	f	signature:(IplImage *img, const Ipoint &ipt)
drawPoints	utils.cpp	/^void drawPoints(IplImage *img, vector<Ipoint> &ipts)$/;"	f	signature:(IplImage *img, vector<Ipoint> &ipts)
drawWindows	utils.cpp	/^void drawWindows(IplImage *img, vector<Ipoint> &ipts)$/;"	f	signature:(IplImage *img, vector<Ipoint> &ipts)
dummy_handler	server.cpp	/^void dummy_handler(const boost::system::error_code& ) {}$/;"	f	signature:(const boost::system::error_code& )
dump_matched_lib	comm_arg.hpp	/^	int dump_matched_lib;$/;"	m	struct:CommArg	access:public
dump_packets	server.cpp	/^	void dump_packets( Packet & pkt, ostream & out ) {$/;"	f	namespace:__anon1	signature:( Packet & pkt, ostream & out )
dump_packets	server.cpp	/^	void dump_packets( char * pc, unsigned len, ostream & out ) {$/;"	f	namespace:__anon1	signature:( char * pc, unsigned len, ostream & out )
dwords	bit_feature.h	/^		DWord dwords[MAX_FEATURE_BITS\/64];$/;"	m	union:BitFeature::__anon7	access:public
dx	ipoint.h	/^	float dx, dy;			\/\/! Placeholders for point motion$/;"	m	struct:Ipoint	access:public
dy	ipoint.h	/^	float dx, dy;			\/\/! Placeholders for point motion$/;"	m	struct:Ipoint	access:public
end	command_recv_service.cpp	/^bool CommandRecvService::end()$/;"	f	class:CommandRecvService	signature:()
end	connection_build_service.cpp	/^bool ConnectionBuilderService::end()$/;"	f	class:ConnectionBuilderService	signature:()
end	fdutils.h	/^	int begin, end;$/;"	m	struct:Range	access:public
end	lib_load_service.cpp	/^bool LibLoadService::end()$/;"	f	class:LibLoadService	signature:()
end_condition_not_satisfied	comm_box.hpp	/^	virtual bool end_condition_not_satisfied() const { return !(all_put() && box_empty()); }$/;"	f	class:Basebox	access:public	signature:() const
end_condition_satisfied	comm_box.hpp	/^	bool end_condition_satisfied() const { return !end_condition_not_satisfied(); }$/;"	f	class:Basebox	access:public	signature:() const
end_point_	server.hpp	/^	boost::asio::ip::udp::endpoint end_point_;			\/\/ receive endpoint$/;"	m	class:Server	access:private
endpoint	match_stream.hpp	/^typedef boost::asio::ip::udp::endpoint endpoint;$/;"	t
endpoint	raw.cpp	/^endpoint::endpoint(int ifindex) : size_(sizeof(sockaddr_ll)) {$/;"	f	class:eth::endpoint	signature:(int ifindex)
endpoint	raw.hpp	/^	typedef eth::endpoint endpoint;$/;"	t	struct:eth::raw	access:public
endpoint	raw.hpp	/^class endpoint {		\/\/ ethernet endpoint$/;"	c	namespace:eth
endpoint_	matcher_manager.hpp	/^	endpoint_type endpoint_;$/;"	m	class:Matcher	access:private
endpoint_type	matcher_manager.hpp	/^	typedef boost::asio::ip::udp::endpoint endpoint_type;$/;"	t	class:Matcher	access:public
eth	raw.cpp	/^namespace eth {$/;"	n	file:
eth	raw.hpp	/^namespace eth {$/;"	n
eth::address	raw.hpp	/^class address {			\/\/ ethernet address$/;"	c	namespace:eth
eth::address::addr_len	raw.hpp	/^	static const int addr_len = 6;$/;"	m	class:eth::address	access:public
eth::address::address	raw.cpp	/^address::address(const string& str) {$/;"	f	class:eth::address	signature:(const string& str)
eth::address::address	raw.cpp	/^address::address(const unsigned char* bytes, unsigned int len) {$/;"	f	class:eth::address	signature:(const unsigned char* bytes, unsigned int len)
eth::address::broadcast	raw.hpp	/^	static address broadcast() { return address("ff ff ff ff ff ff"); }$/;"	f	class:eth::address	access:public	signature:()
eth::address::bytes_	raw.hpp	/^	bytes_type bytes_;$/;"	m	class:eth::address	access:private
eth::address::bytes_type	raw.hpp	/^	typedef unsigned char bytes_type[addr_len];$/;"	t	class:eth::address	access:public
eth::address::is_multicast	raw.hpp	/^	bool is_multicast() const { return bytes_[0] == 1; }$/;"	f	class:eth::address	access:public	signature:() const
eth::address::to_bytes	raw.hpp	/^	const bytes_type& to_bytes() const { return bytes_; }$/;"	f	class:eth::address	access:public	signature:() const
eth::address::to_longlong	raw.cpp	/^unsigned long long address::to_longlong() const {$/;"	f	class:eth::address	signature:() const
eth::address::to_string	raw.cpp	/^string address::to_string() const {$/;"	f	class:eth::address	signature:() const
eth::device_config	raw.hpp	/^class device_config {$/;"	c	namespace:eth
eth::device_config::data	raw.hpp	/^	void* data() { return (void*)&ifr_; }$/;"	f	class:eth::device_config	access:public	signature:()
eth::device_config::device_config	raw.cpp	/^device_config::device_config(int request, const char* dev) : req_(request) {$/;"	f	class:eth::device_config	signature:(int request, const char* dev)
eth::device_config::get_flags	raw.hpp	/^	int get_flags()   const { return ifr_.ifr_flags; }		\/\/ SIOCGIFFLAGS$/;"	f	class:eth::device_config	access:public	signature:() const
eth::device_config::get_hwaddr	raw.hpp	/^	address get_hwaddr() const								\/\/ SIOCGIFHWADDR$/;"	f	class:eth::device_config	access:public	signature:() const
eth::device_config::get_ifindex	raw.hpp	/^	int get_ifindex() const { return ifr_.ifr_ifindex; }	\/\/ SIOCGIFINDEX$/;"	f	class:eth::device_config	access:public	signature:() const
eth::device_config::ifr_	raw.hpp	/^	ifreq ifr_;$/;"	m	class:eth::device_config	access:private
eth::device_config::name	raw.hpp	/^	int name() const { return req_; }$/;"	f	class:eth::device_config	access:public	signature:() const
eth::device_config::req_	raw.hpp	/^	int req_;$/;"	m	class:eth::device_config	access:private
eth::device_config::run	raw.cpp	/^bool device_config::run(socket& sock) {$/;"	f	class:eth::device_config	signature:(socket& sock)
eth::endpoint	raw.hpp	/^class endpoint {		\/\/ ethernet endpoint$/;"	c	namespace:eth
eth::endpoint::address	raw.hpp	/^	eth::address address() const { return eth::address(data_.sll_addr, data_.sll_halen); }$/;"	f	class:eth::endpoint	access:public	signature:() const
eth::endpoint::capacity	raw.hpp	/^	std::size_t capacity() const { return sizeof(sockaddr_ll); }$/;"	f	class:eth::endpoint	access:public	signature:() const
eth::endpoint::data	raw.hpp	/^	const data_type* data() const { return (data_type*)&data_; }$/;"	f	class:eth::endpoint	access:public	signature:() const
eth::endpoint::data	raw.hpp	/^	data_type* data() { return (data_type*)&data_; }$/;"	f	class:eth::endpoint	access:public	signature:()
eth::endpoint::data_	raw.hpp	/^	sockaddr_ll data_;$/;"	m	class:eth::endpoint	access:private
eth::endpoint::data_type	raw.hpp	/^	typedef boost::asio::detail::socket_addr_type data_type;$/;"	t	class:eth::endpoint	access:public
eth::endpoint::endpoint	raw.cpp	/^endpoint::endpoint(int ifindex) : size_(sizeof(sockaddr_ll)) {$/;"	f	class:eth::endpoint	signature:(int ifindex)
eth::endpoint::header_type	raw.hpp	/^	unsigned int header_type() const { return data_.sll_hatype; }$/;"	f	class:eth::endpoint	access:public	signature:() const
eth::endpoint::ifindex	raw.hpp	/^	int ifindex() const { return data_.sll_ifindex; }$/;"	f	class:eth::endpoint	access:public	signature:() const
eth::endpoint::packet_type	raw.hpp	/^	unsigned int packet_type() const { return data_.sll_pkttype; }$/;"	f	class:eth::endpoint	access:public	signature:() const
eth::endpoint::protocol	raw.hpp	/^	protocol_type protocol() const { return raw(); }$/;"	f	class:eth::endpoint	access:public	signature:() const
eth::endpoint::protocol_type	raw.hpp	/^	typedef raw protocol_type;$/;"	t	class:eth::endpoint	access:public
eth::endpoint::resize	raw.hpp	/^	void resize(std::size_t s) { size_ = s; }$/;"	f	class:eth::endpoint	access:public	signature:(std::size_t s)
eth::endpoint::set_address	raw.cpp	/^void endpoint::set_address(const eth::address& addr) {$/;"	f	class:eth::endpoint	signature:(const eth::address& addr)
eth::endpoint::set_ifindex	raw.hpp	/^	void set_ifindex(int index) { data_.sll_ifindex = index; }$/;"	f	class:eth::endpoint	access:public	signature:(int index)
eth::endpoint::size	raw.hpp	/^	std::size_t size() const { return size_; }$/;"	f	class:eth::endpoint	access:public	signature:() const
eth::endpoint::size_	raw.hpp	/^	std::size_t size_;$/;"	m	class:eth::endpoint	access:private
eth::operator !=	raw.hpp	/^	inline bool operator != (const eth::address& x, const eth::address& y) { return x.to_longlong() != y.to_longlong(); }$/;"	f	namespace:eth	signature:(const eth::address& x, const eth::address& y)
eth::operator <	raw.hpp	/^	inline bool operator <  (const eth::address& x, const eth::address& y) { return x.to_longlong() <  y.to_longlong(); }$/;"	f	namespace:eth	signature:(const eth::address& x, const eth::address& y)
eth::operator <<	raw.cpp	/^std::ostream& operator << (std::ostream& os, const eth::endpoint& ep) {$/;"	f	namespace:eth	signature:(std::ostream& os, const eth::endpoint& ep)
eth::operator <<	raw.hpp	/^	inline std::ostream& operator << (std::ostream& os, const eth::address& addr)$/;"	f	namespace:eth	signature:(std::ostream& os, const eth::address& addr)
eth::operator ==	raw.hpp	/^	inline bool operator == (const eth::address& x, const eth::address& y) { return x.to_longlong() == y.to_longlong(); }$/;"	f	namespace:eth	signature:(const eth::address& x, const eth::address& y)
eth::raw	raw.hpp	/^struct raw {			\/\/ ethernet protocol$/;"	s	namespace:eth
eth::raw::endpoint	raw.hpp	/^	typedef eth::endpoint endpoint;$/;"	t	struct:eth::raw	access:public
eth::raw::family	raw.hpp	/^	int family()   const { return AF_PACKET; }			\/\/ 0x0011$/;"	f	struct:eth::raw	access:public	signature:() const
eth::raw::protocol	raw.hpp	/^	int protocol() const { return htons(ETH_P_ALL); }	\/\/ 0x0300$/;"	f	struct:eth::raw	access:public	signature:() const
eth::raw::type	raw.hpp	/^	int type()     const { return SOCK_RAW; }$/;"	f	struct:eth::raw	access:public	signature:() const
eth::socket	raw.hpp	/^struct socket : boost::asio::basic_raw_socket<raw> {	\/\/ ethernet socket$/;"	s	namespace:eth	inherits:boost::asio::basic_raw_socket
eth::socket::bind_device	raw.hpp	/^	void bind_device(const char* dev) {$/;"	f	struct:eth::socket	access:public	signature:(const char* dev)
eth::socket::get_flags	raw.cpp	/^int socket::get_flags(const char* dev) {$/;"	f	class:eth::socket	signature:(const char* dev)
eth::socket::get_hwaddr	raw.cpp	/^address socket::get_hwaddr(const char* dev) {$/;"	f	class:eth::socket	signature:(const char* dev)
eth::socket::get_ifindex	raw.cpp	/^int socket::get_ifindex(const char* dev) {$/;"	f	class:eth::socket	signature:(const char* dev)
eth::socket::ifindex	raw.hpp	/^	int ifindex;$/;"	m	struct:eth::socket	access:public
eth::socket::socket	raw.hpp	/^	explicit socket(boost::asio::io_service& io_service)$/;"	f	struct:eth::socket	access:public	signature:(boost::asio::io_service& io_service)
eth::socket::socket	raw.hpp	/^	socket(boost::asio::io_service& io_service, const char* dev)$/;"	f	struct:eth::socket	access:public	signature:(boost::asio::io_service& io_service, const char* dev)
eth::socket::socket	raw.hpp	/^	socket(boost::asio::io_service& io_service, const endpoint& ep)$/;"	f	struct:eth::socket	access:public	signature:(boost::asio::io_service& io_service, const endpoint& ep)
eth::socket::socket	raw.hpp	/^	socket(boost::asio::io_service& io_service, const raw& protocol)$/;"	f	struct:eth::socket	access:public	signature:(boost::asio::io_service& io_service, const raw& protocol)
eth::socket::socket	raw.hpp	/^	socket(boost::asio::io_service& io_service, const raw& protocol,$/;"	f	struct:eth::socket	access:public	signature:(boost::asio::io_service& io_service, const raw& protocol, const boost::asio::raw_socket_service<raw>::native_handle_type& native_socket)
execute	command.cpp	/^void AddNodesCommand::execute()$/;"	f	class:AddNodesCommand	signature:()
execute	command.cpp	/^void DomainCreateCommand::execute()$/;"	f	class:DomainCreateCommand	signature:()
execute	command.cpp	/^void QueryLoadsCommand::execute()$/;"	f	class:QueryLoadsCommand	signature:()
execute	command.cpp	/^void RemoveNodesCommand::execute()$/;"	f	class:RemoveNodesCommand	signature:()
execute	command.cpp	/^void ShowResultCommand::execute()$/;"	f	class:ShowResultCommand	signature:()
execute	command.hpp	/^	virtual void execute() {}$/;"	f	class:TerminalChangeCommand	access:public	signature:()
exists	matcher_manager.hpp	/^	bool exists( const Matcher & m ) { return find(m); }$/;"	f	class:MatcherManager	access:public	signature:( const Matcher & m )
extract_addr	comm_arg.hpp	/^	std::string    extract_addr;$/;"	m	struct:CommArg	access:public
fRound	fdutils.h	/^inline int fRound(float flt) { return (int) floor(flt+0.5f); }$/;"	f	signature:(float flt)
family	raw.hpp	/^	int family()   const { return AF_PACKET; }			\/\/ 0x0011$/;"	f	struct:eth::raw	access:public	signature:() const
feature_bits	match_utils.h	/^	int feature_bits;		\/\/ Ãÿ’˜æ´∂»$/;"	m	struct:MatchArgs	access:public
file_sink	log.h	/^		sp_file_sink   file_sink() { return sink_file_; }$/;"	f	class:LOG::Log	access:public	signature:()
file_to_match	comm_arg.hpp	/^	std::string file_to_match;$/;"	m	struct:CommArg	access:public
find	matcher_manager.cpp	/^MatcherPtr MatcherManager::find( const Matcher & m ) const$/;"	f	class:MatcherManager	signature:( const Matcher & m ) const
find_domain_by_id	matcher_manager.hpp	/^	static DomainInfoPtr find_domain_by_id(DomainType id)$/;"	f	struct:DomainInfo	access:public	signature:(DomainType id)
find_in	matcher_manager.hpp	/^	static MatcherPtr find_in( const Matcher & m, const Matchers & ms )$/;"	f	class:MatcherManager	access:public	signature:( const Matcher & m, const Matchers & ms )
find_matchers_at_domain	matcher_manager.cpp	/^MatcherManager::Matchers MatcherManager::find_matchers_at_domain( DomainType d )$/;"	f	class:MatcherManager	signature:( DomainType d )
find_matchers_at_domain_and_state	matcher_manager.cpp	/^MatcherManager::Matchers MatcherManager::find_matchers_at_domain_and_state( DomainType d, Matcher::MATCHER_STATE s )$/;"	f	class:MatcherManager	signature:( DomainType d, Matcher::MATCHER_STATE s )
find_matchers_at_state	matcher_manager.cpp	/^MatcherManager::Matchers MatcherManager::find_matchers_at_state( Matcher::MATCHER_STATE s )$/;"	f	class:MatcherManager	signature:( Matcher::MATCHER_STATE s )
find_one_matcher_at_domain_and_state	matcher_manager.cpp	/^MatcherPtr MatcherManager::find_one_matcher_at_domain_and_state( const Matcher::MATCHER_STATE s, DomainType d )$/;"	f	class:MatcherManager	signature:( const Matcher::MATCHER_STATE s, DomainType d )
find_one_matcher_at_state	matcher_manager.cpp	/^MatcherPtr MatcherManager::find_one_matcher_at_state( const Matcher::MATCHER_STATE s )$/;"	f	class:MatcherManager	signature:( const Matcher::MATCHER_STATE s )
first_flag	matcher_manager.hpp	/^	bool first_flag() const { return first_flag_; }$/;"	f	class:Matcher	access:public	signature:() const
first_flag_	matcher_manager.hpp	/^	bool first_flag_;$/;"	m	class:Matcher	access:private
foreach	utils.h	21;"	d
fpga_port	comm_arg.hpp	/^	unsigned short fpga_port;$/;"	m	struct:CommArg	access:public
fps	match_utils.h	/^	double fps;$/;"	m	struct:VideoCapcture	access:public
frame_count	match_utils.h	/^	double frame_count;$/;"	m	struct:VideoCapcture	access:public
frame_index	utils.h	/^		frame_type frame_index;$/;"	m	struct:UTILS::image	access:public
frame_pos	match_utils.h	/^	int frame_pos;$/;"	m	struct:VideoCapcture	access:public
frame_pos	utils.h	/^		unsigned frame_pos() const { return frame_index & 0x00FFFFFF; }$/;"	f	struct:UTILS::image	access:public	signature:() const
frame_thres	match_utils.h	/^	int frame_thres;		\/\/ µ•÷°∆•≈‰„–÷µ$/;"	m	struct:MatchArgs	access:public
frame_type	utils.h	/^typedef unsigned frame_type;$/;"	t
framegroup_size	comm_arg.hpp	/^	int framegroup_size;$/;"	m	struct:CommArg	access:public
from_point	packet.hpp	/^	const udp::endpoint from_point() { return src_endpoint_; }$/;"	f	class:CfaUdpPacket	access:public	signature:()
gather_results	match_utils.cpp	/^const MatchResults& SectionManager::gather_results() {$/;"	f	class:SectionManager	signature:()
get	comm_box.hpp	/^	T get()$/;"	f	class:CommQueue	access:public	signature:()
get	comm_box.hpp	/^	bool get(T & t)$/;"	f	class:CommBox	access:public	signature:(T & t)
get	comm_box.hpp	/^	bool get(std::vector< T > & snk)$/;"	f	class:RandomGetBox	access:public	signature:(std::vector< T > & snk)
get	comm_window.hpp	/^	Packet * get()$/;"	f	class:PacketWindow	access:public	signature:()
get	log.cpp	/^Log& Log::get() {$/;"	f	class:LOG::Log	signature:()
getEnum	fdutils.h	/^	E getEnum(const string& str) const {$/;"	f	class:EnumStringMap	access:public	signature:(const string& str) const
getString	fdutils.h	/^	const char* getString(E val) const {$/;"	f	class:EnumStringMap	access:public	signature:(E val) const
get_build_task	match_stream.hpp	/^	static ConnectionBuilder * get_build_task(const endpoint & e )$/;"	f	class:ConnectionBuilder	access:public	signature:(const endpoint & e )
get_condition_not_satisfied	comm_box.hpp	/^	virtual bool get_condition_not_satisfied() const { return box_empty(); }$/;"	f	class:Basebox	access:public	signature:() const
get_condition_not_satisfied	comm_window.hpp	/^	virtual bool get_condition_not_satisfied() const$/;"	f	class:PacketWindow	access:public	signature:() const
get_domain_by_appid	app_manager.hpp	/^	AppDomainPtr get_domain_by_appid(AppId appid) {$/;"	f	class:AppManager	access:public	signature:(AppId appid)
get_flags	raw.cpp	/^int socket::get_flags(const char* dev) {$/;"	f	class:eth::socket	signature:(const char* dev)
get_flags	raw.hpp	/^	int get_flags()   const { return ifr_.ifr_flags; }		\/\/ SIOCGIFFLAGS$/;"	f	class:eth::device_config	access:public	signature:() const
get_frame	match_utils.cpp	/^IplImage* VideoCapcture::get_frame() {$/;"	f	class:VideoCapcture	signature:()
get_hwaddr	raw.cpp	/^address socket::get_hwaddr(const char* dev) {$/;"	f	class:eth::socket	signature:(const char* dev)
get_hwaddr	raw.hpp	/^	address get_hwaddr() const								\/\/ SIOCGIFHWADDR$/;"	f	class:eth::device_config	access:public	signature:() const
get_ifindex	raw.cpp	/^int socket::get_ifindex(const char* dev) {$/;"	f	class:eth::socket	signature:(const char* dev)
get_ifindex	raw.hpp	/^	int get_ifindex() const { return ifr_.ifr_ifindex; }	\/\/ SIOCGIFINDEX$/;"	f	class:eth::device_config	access:public	signature:() const
get_logger	log.h	/^	inline sev_logger& get_logger() { return Log::get().logger(); }$/;"	f	namespace:LOG	signature:()
get_matcher_state	matcher_manager.cpp	/^Matcher::MATCHER_STATE MatcherManager::get_matcher_state( const Matcher & m ) const$/;"	f	class:MatcherManager	signature:( const Matcher & m ) const
group_pause	comm_arg.hpp	/^	unsigned group_pause;$/;"	m	struct:CommArg	access:public
half2single	fdutils.h	/^static float half2single(halfp h) {$/;"	f	signature:(halfp h)
halfp	fdutils.h	/^typedef unsigned short halfp;		\/\/ 16 bit$/;"	t
hamming_distance	bit_feature.cpp	/^int hamming_distance(const BitFeature& f1, const BitFeature& f2) {$/;"	f	signature:(const BitFeature& f1, const BitFeature& f2)
handle_packet	match_analyser.cpp	/^void MatchAnalyser::handle_packet( Packet & pkt, const udp::endpoint & from_addr )$/;"	f	class:MatchAnalyser	signature:( Packet & pkt, const udp::endpoint & from_addr )
handle_packet	packet_handle_center.cpp	/^void PacketHandleCenter::handle_packet( PacketPtr p, const udp::endpoint & end_point )$/;"	f	class:PacketHandleCenter	signature:( PacketPtr p, const udp::endpoint & end_point )
head	comm_window.hpp	/^	std::size_t head;	\/\/ ∂”¡–Õ∑£¨”…confirmµ˜’˚$/;"	m	class:PacketWindow	access:protected
header_type	raw.hpp	/^	unsigned int header_type() const { return data_.sll_hatype; }$/;"	f	class:eth::endpoint	access:public	signature:() const
height	integral.h	/^	int height() const { return height_; }$/;"	f	class:Image	access:public	signature:() const
height_	integral.h	/^	int height_;            \/\/ Image height in pixels$/;"	m	class:Image	access:private
htoc	raw.cpp	/^inline int htoc(unsigned int h) {$/;"	f	namespace:__anon6	signature:(unsigned int h)
id_to_ip	matcher_manager.cpp	/^const std::string MatcherManager::id_to_ip(unsigned id)$/;"	f	class:MatcherManager	signature:(unsigned id)
idx	utils.h	/^		int idx;$/;"	m	struct:UTILS::image	access:private
ifindex	raw.hpp	/^	int ifindex() const { return data_.sll_ifindex; }$/;"	f	class:eth::endpoint	access:public	signature:() const
ifindex	raw.hpp	/^	int ifindex;$/;"	m	struct:eth::socket	access:public
ifr_	raw.hpp	/^	ifreq ifr_;$/;"	m	class:eth::device_config	access:private
image	utils.h	/^		image() : idx(0) {}$/;"	f	struct:UTILS::image	access:public	signature:()
image	utils.h	/^	struct image$/;"	s	namespace:UTILS
image_cnt_	match_stream.hpp	/^	std::size_t image_cnt_;$/;"	m	class:BitFeatureLoader	access:private
image_libs	comm_arg.hpp	/^	std::vector<std::string> image_libs;$/;"	m	struct:CommArg	access:public
image_pause	comm_arg.hpp	/^	int image_pause;$/;"	m	struct:CommArg	access:public
image_ratio	comm_arg.hpp	/^	int image_ratio;$/;"	m	struct:CommArg	access:public
images	comm_arg.hpp	/^	std::vector<std::string> images;$/;"	m	struct:CommArg	access:public
increase_load	matcher_manager.hpp	/^	void increase_load(unsigned n) { num_load_ += n; } $/;"	f	class:Matcher	access:public	signature:(unsigned n)
increase_sent_frames	app_manager.hpp	/^	void increase_sent_frames(unsigned v) { sent_frames_ += v; }$/;"	f	class:AppDomain	access:public	signature:(unsigned v)
increse_result_count	matcher_manager.hpp	/^	void increse_result_count() { ++result_count_; }$/;"	f	class:Matcher	access:public	signature:()
index	packet.hpp	/^	u_char         index() const   { return bytes_[HEAD_SIZE + 1]; }$/;"	f	class:BasicPacket	access:public	signature:() const
indexes_type	comm_box.hpp	/^	typedef std::vector<std::size_t> indexes_type;$/;"	t	class:RandomGetBox	access:public
init	integral.cpp	/^void GrayImage::init(const IplImage* img) {$/;"	f	class:GrayImage	signature:(const IplImage* img)
init	integral.cpp	/^void IntImage::init(const GrayImage& img) {$/;"	f	class:IntImage	signature:(const GrayImage& img)
init_log_file	log.cpp	/^void Log::init_log_file(const std::string& log_file, const std::string& prog_name) {$/;"	f	class:LOG::Log	signature:(const std::string& log_file, const std::string& prog_name)
init_log_file	log.h	/^	inline void init_log_file(const std::string& log_file, const std::string& prog_name = "")$/;"	f	namespace:LOG	signature:(const std::string& log_file, const std::string& prog_name = ”)
instance	app_manager.hpp	/^	static AppManager & instance() {$/;"	f	class:AppManager	access:public	signature:()
instance	command_recv_service.cpp	/^CommandRecvService & CommandRecvService::instance()$/;"	f	class:CommandRecvService	signature:()
instance	connection_build_service.hpp	/^	static ConnectionBuilderService & instance()$/;"	f	class:ConnectionBuilderService	access:public	signature:()
instance	lib_load_service.hpp	/^	static LibLoadService & instance()$/;"	f	class:LibLoadService	access:public	signature:()
instance	match_analyser.hpp	/^	static MatchAnalyser & instance() {$/;"	f	class:MatchAnalyser	access:public	signature:()
instance	matcher_manager.hpp	/^	static MatcherManager & instance()$/;"	f	class:MatcherManager	access:public	signature:()
instance	packet_handle_center.hpp	/^	static PacketHandleCenter & instance()$/;"	f	class:PacketHandleCenter	access:public	signature:()
instance	server.hpp	/^	static Server & instance()$/;"	f	class:Server	access:public	signature:()
instance_	matcher_manager.cpp	/^MatcherManager * MatcherManager::instance_ = 0;$/;"	m	class:MatcherManager	file:
instance_	matcher_manager.hpp	/^	static MatcherManager * instance_;$/;"	m	class:MatcherManager	access:private
io	server.hpp	/^	boost::asio::io_service & io() { return io_; }$/;"	f	class:Server	access:public	signature:()
io_	command_recv_service.hpp	/^	boost::asio::io_service io_;$/;"	m	class:CommandRecvService	access:private
io_	server.hpp	/^	boost::asio::io_service io_;                        \/\/ io service$/;"	m	class:Server	access:private
ip_address	matcher_manager.hpp	/^typedef boost::asio::ip::address ip_address;$/;"	t
ipt1	ipoint.h	/^	const Ipoint& ipt1(int i) const { return *matches_[i].first;  }$/;"	f	class:Matches	access:public	signature:(int i) const
ipt2	ipoint.h	/^	const I& ipt2(int i) const { return *matches_[i].second; }$/;"	f	class:Matches	access:public	signature:(int i) const
ipts1_	ipoint.h	/^	IpVec*  ipts1_;$/;"	m	class:Matches	access:private
ipts2_	ipoint.h	/^	IpVec2* ipts2_;$/;"	m	class:Matches	access:private
is_multicast	raw.hpp	/^	bool is_multicast() const { return bytes_[0] == 1; }$/;"	f	class:eth::address	access:public	signature:() const
laplacian	ipoint.h	/^	int laplacian;			\/\/! Sign of laplacian for fast matching purposes$/;"	m	struct:Ipoint	access:public
len	match_utils.h	/^	int len;$/;"	m	struct:MatchSection	access:public
less	match_utils.cpp	/^inline bool less (const MatchSection& lhs, const MatchSection& rhs)$/;"	f	signature:(const MatchSection& lhs, const MatchSection& rhs)
lib_	match_stream.hpp	/^	const VideoLibVec & lib_;$/;"	m	class:NewLibLoader	access:private
lib_	match_utils.h	/^	const VideoLibVec& lib_;$/;"	m	class:VideoMatcher	access:private
lib_begin	match_utils.h	/^	int test_begin, lib_begin;$/;"	m	struct:MatchSection	access:public
lib_id	comm_arg.hpp	/^	unsigned lib_id;$/;"	m	struct:CommArg	access:public
lib_id	match_utils.h	/^	int lib_id()   const { return (lib_begin >> 16) & 0xffff;  }$/;"	f	struct:MatchSection	access:public	signature:() const
lib_pos	match_utils.h	/^	int lib_pos()  const { return lib_begin  & 0xffff; }$/;"	f	struct:MatchSection	access:public	signature:() const
lib_valid_	lib_load_service.hpp	/^	bool lib_valid_;$/;"	m	class:LibLoadService	access:private
libmap_	lib_load_service.hpp	/^	LibMap libmap_;$/;"	m	class:LibLoadService	access:private
libs	comm_arg.hpp	/^	std::vector<std::string> libs;$/;"	m	struct:CommArg	access:public
load	integral.cpp	/^void GrayImage::load(const char* file_name) {$/;"	f	class:GrayImage	signature:(const char* file_name)
load	match_utils.cpp	/^void MatchArgs::load(const string& arg_file) {$/;"	f	class:MatchArgs	signature:(const string& arg_file)
loadLibNew	newlib.cpp	/^int loadLibNew( int nbits, VideoLibVec& video_lib, const string& lib_file )$/;"	f	signature:( int nbits, VideoLibVec& video_lib, const string& lib_file )
loadSurf	utils.cpp	/^void loadSurf(char *filename, vector<Ipoint> &ipts)$/;"	f	signature:(char *filename, vector<Ipoint> &ipts)
load_compare	matcher_manager.cpp	/^	bool load_compare(MatcherPtr lhs, MatcherPtr rhs, unsigned short thres)$/;"	f	namespace:__anon2	signature:(MatcherPtr lhs, MatcherPtr rhs, unsigned short thres)
load_domain_lib_to_mem	lib_load_service.cpp	/^void LibLoadService::load_domain_lib_to_mem(DomainType d)$/;"	f	class:LibLoadService	signature:(DomainType d)
load_len	packet.hpp	/^	int      load_len() const { return data_len_ + 2; }$/;"	f	class:BasicPacket	access:public	signature:() const
load_lib	match_stream.cpp	/^void NewLibLoader::load_lib( const VideoLibVec & lib )$/;"	f	class:NewLibLoader	signature:( const VideoLibVec & lib )
load_lib_to_matcher	lib_load_service.cpp	/^void LibLoadService::load_lib_to_matcher( MatcherPtr m, const VideoLibVec & lib )$/;"	f	class:LibLoadService	signature:( MatcherPtr m, const VideoLibVec & lib )
load_lib_to_mem	lib_load_service.cpp	/^void LibLoadService::load_lib_to_mem(const std::string & path, VideoLibVec & lib)$/;"	f	class:LibLoadService	signature:(const std::string & path, VideoLibVec & lib)
load_loop	match_stream.cpp	/^void BitFeatureLoader::load_loop(const VideoLibVec & videos)$/;"	f	class:BitFeatureLoader	signature:(const VideoLibVec & videos)
load_ptr	packet.hpp	/^    u_char * load_ptr()  { return bytes_ + HEAD_SIZE;     }	\/\/ from type$/;"	f	class:BasicPacket	access:public	signature:()
load_section	match_stream.cpp	/^void BitFeatureLoader::load_section (unsigned short vid, unsigned short frompos, const BitFeature * bit_vec, unsigned size, MatcherPtr matcher, unsigned slice_idx)$/;"	f	class:BitFeatureLoader	signature:(unsigned short vid, unsigned short frompos, const BitFeature * bit_vec, unsigned size, MatcherPtr matcher, unsigned slice_idx)
loader_	app_manager.hpp	/^	BitFeatureLoader * loader_;$/;"	m	class:AppDomain	access:private
local_endpoint	server.hpp	/^	const udp::endpoint  local_endpoint() const { return local_point_; }$/;"	f	class:Server	access:public	signature:() const
local_point_	server.hpp	/^	boost::asio::ip::udp::endpoint local_point_;				$/;"	m	class:Server	access:private
lock	comm_box.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:Basebox	access:public
lock	connection_build_service.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:ConnectionBuilderService	access:public
lock	lib_load_service.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:LibLoadService	access:public
lock	match_stream.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:ConnectionBuilder	access:public
lock	matcher_manager.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:Matcher	access:public
lock	matcher_manager.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:MatcherManager	access:public
log_file	comm_arg.hpp	/^	std::string    log_file;$/;"	m	struct:CommArg	access:public
logger	log.h	/^		sev_logger&    logger()    { return slg_;       }$/;"	f	class:LOG::Log	access:public	signature:()
main	main.cpp	/^int main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
mainode_id	comm_arg.hpp	/^	unsigned mainode_id;$/;"	m	struct:CommArg	access:public
make_command	command_recv_service.cpp	/^CommandPtr CommandRecvService::make_command(u_char * msg, unsigned length, unsigned msg_id)$/;"	f	class:CommandRecvService	signature:(u_char * msg, unsigned length, unsigned msg_id)
make_domain	matcher_manager.hpp	/^	static DomainInfoPtr make_domain(char * pc)$/;"	f	struct:DomainInfo	access:public	signature:(char * pc)
make_matcher	matcher_manager.hpp	/^	static MatcherPtr make_matcher( const Matcher::endpoint_type & e, DomainType domain_id )$/;"	f	class:MatcherManager	access:public	signature:( const Matcher::endpoint_type & e, DomainType domain_id )
make_matcher	matcher_manager.hpp	/^	static MatcherPtr make_matcher( const std::string & ip, DomainType domain_id )$/;"	f	class:MatcherManager	access:public	signature:( const std::string & ip, DomainType domain_id )
make_shared_packet	packet.hpp	/^	static PacketPtr make_shared_packet(const Packet & pkt)$/;"	f	class:CfaUdpPacket	access:public	signature:(const Packet & pkt)
manually_broadcast_points	comm_arg.hpp	/^	int manually_broadcast_points;$/;"	m	struct:CommArg	access:public
mark_all_comm_end	server.cpp	/^void Server::mark_all_comm_end()$/;"	f	class:Server	signature:()
mark_bitfeatures_all_sent	server.hpp	/^	void mark_bitfeatures_all_sent() { bitfeature_all_sent_ = true; }$/;"	f	class:Server	access:public	signature:()
match	ipoint.h	/^	const void* match;		\/\/! matched ipoint$/;"	m	struct:Ipoint	access:public
matchThread	ipoint.cpp	/^void Matches<D, I>::matchThread(int tid) {$/;"	f	class:Matches	signature:(int tid)
match_frames	match_utils.cpp	/^void VideoMatcher::match_frames(const LibPointVec& frames, int frame_begin) {$/;"	f	class:VideoMatcher	signature:(const LibPointVec& frames, int frame_begin)
match_source	app_manager.hpp	/^	const std::string match_source() const { return match_source_; }$/;"	f	class:AppDomain	access:public	signature:() const
match_source_	app_manager.hpp	/^	std::string match_source_;$/;"	m	class:AppDomain	access:private
match_threshold	comm_arg.hpp	/^	int match_threshold;$/;"	m	struct:CommArg	access:public
match_threshold	matcher_manager.hpp	/^	unsigned match_threshold() const { return match_threshold_; }$/;"	f	class:Matcher	access:public	signature:() const
match_threshold_	matcher_manager.hpp	/^	unsigned match_threshold_;$/;"	m	class:Matcher	access:private
match_timeout	comm_arg.hpp	/^	int match_timeout;$/;"	m	struct:CommArg	access:public
match_video	match_utils.cpp	/^void VideoMatcher::match_video(int video_id, const LibPointVec& video_points, int frame_start, int frame_end) {$/;"	f	class:VideoMatcher	signature:(int video_id, const LibPointVec& video_points, int frame_start, int frame_end)
match_video	match_utils.cpp	/^void VideoMatcher::match_video(int video_id, const std::string& video_file, int frame_start, int frame_end) {$/;"	f	class:VideoMatcher	signature:(int video_id, const std::string& video_file, int frame_start, int frame_end)
match_width	comm_arg.hpp	/^	int match_width;$/;"	m	struct:CommArg	access:public
matchers_	matcher_manager.hpp	/^	Matchers matchers_;$/;"	m	class:MatcherManager	access:private
matches_	ipoint.h	/^	std::vector<std::pair<const Ipoint*, const I*> > matches_;$/;"	m	class:Matches	access:private
max	integral.h	26;"	d
max_acc	match_utils.cpp	/^static const int min_acc = 1, max_acc = 4;$/;"	v	file:
max_cnv	match_utils.cpp	/^static const int min_cnv = 1, max_cnv = 4;$/;"	v	file:
max_conn_times_allowed	comm_arg.hpp	/^	int max_conn_times_allowed;$/;"	m	struct:CommArg	access:public
max_num_node	comm_arg.hpp	/^	unsigned max_num_node;$/;"	m	struct:CommArg	access:public
merge	match_utils.cpp	/^void MatchSection::merge(const MatchSection& rhs) {$/;"	f	class:MatchSection	signature:(const MatchSection& rhs)
merge_threshold	comm_arg.hpp	/^	int merge_threshold;$/;"	m	struct:CommArg	access:public
merge_threshold	matcher_manager.hpp	/^	unsigned merge_threshold() const { return merge_threshold_; }$/;"	f	class:Matcher	access:public	signature:() const
merge_threshold_	matcher_manager.hpp	/^	unsigned merge_threshold_;$/;"	m	class:Matcher	access:private
merge_unit	comm_arg.hpp	/^	int merge_unit;$/;"	m	struct:CommArg	access:public
merge_unit	matcher_manager.hpp	/^	unsigned merge_unit() const { return merge_unit_; }$/;"	f	class:Matcher	access:public	signature:() const
merge_unit_	matcher_manager.hpp	/^	unsigned merge_unit_;$/;"	m	class:Matcher	access:private
min	integral.h	22;"	d
min_acc	match_utils.cpp	/^static const int min_acc = 1, max_acc = 4;$/;"	v	file:
min_cnv	match_utils.cpp	/^static const int min_cnv = 1, max_cnv = 4;$/;"	v	file:
min_match_len	match_utils.h	/^	int min_match_len;		\/\/ ◊Ó–°¡¨–¯∆•≈‰÷° ˝„–÷µ$/;"	m	struct:MatchArgs	access:public
monitor	comm_box.hpp	/^	boost::mutex monitor;$/;"	m	class:Basebox	access:protected
monitor_	connection_build_service.hpp	/^	boost::mutex monitor_;$/;"	m	class:ConnectionBuilderService	access:private
monitor_	lib_load_service.hpp	/^	boost::mutex monitor_;$/;"	m	class:LibLoadService	access:private
monitor_	match_stream.hpp	/^	boost::mutex monitor_;$/;"	m	class:ConnectionBuilder	access:private
monitor_	matcher_manager.hpp	/^	boost::mutex monitor_;$/;"	m	class:Matcher	access:private
monitor_	matcher_manager.hpp	/^	boost::mutex monitor_;$/;"	m	class:MatcherManager	access:private
monitor_	server.hpp	/^	boost::mutex monitor_;$/;"	m	class:Server	access:private
msg	command.hpp	/^	u_char msg[1500];$/;"	m	struct:DCSPPacket	access:public
msg_id	command.hpp	/^	U32 msg_id;$/;"	m	struct:DCSPPacket	access:public
msg_len	command.hpp	/^	U16 msg_len;$/;"	m	struct:DCSPPacket	access:public
name	comm_window.hpp	/^	std::string name;$/;"	m	class:PacketWindow	access:protected
name	raw.hpp	/^	int name() const { return req_; }$/;"	f	class:eth::device_config	access:public	signature:() const
nbits	comm_arg.hpp	/^	int nbits;$/;"	m	struct:CommArg	access:public
nbits	matcher_manager.hpp	/^	unsigned nbits() const { return nbits_; }$/;"	f	class:Matcher	access:public	signature:() const
nbits_	matcher_manager.hpp	/^	unsigned nbits_;$/;"	m	class:Matcher	access:private
nbytes	bit_feature.h	/^	int nbytes() const { return nwords_ * 4; }$/;"	f	class:BitFeature	access:public	signature:() const
next	comm_window.hpp	/^	static std::size_t next(std::size_t p) { return (p + 1) % (N + 1); }$/;"	f	class:PacketWindow	access:protected	signature:(std::size_t p)
next_frame	match_utils.h	/^	double next_frame;$/;"	m	struct:VideoCapcture	access:private
node_id_to_ip	command.cpp	/^	const std::string node_id_to_ip(unsigned node_id)$/;"	f	namespace:__anon3	signature:(unsigned node_id)
node_speed	comm_arg.hpp	/^	double node_speed;$/;"	m	struct:CommArg	access:public
nodes_	command.hpp	/^	Nodes nodes_;$/;"	m	class:AddNodesCommand	access:private
nodes_	command.hpp	/^	Nodes nodes_;$/;"	m	class:RemoveNodesCommand	access:private
nodes_	match_stream.hpp	/^	std::vector< StreamNode * > nodes_;$/;"	m	class:StreamLine	access:private
norm_dcsp_msg_id	command_recv_service.cpp	/^	unsigned norm_dcsp_msg_id( unsigned id )$/;"	f	namespace:__anon8	signature:( unsigned id )
notify_all_put	comm_box.cpp	/^void Basebox::notify_all_put()$/;"	f	class:Basebox	signature:()
notify_wait_get	comm_box.cpp	/^void Basebox::notify_wait_get()$/;"	f	class:Basebox	signature:()
notify_wait_matcher	connection_build_service.cpp	/^void ConnectionBuilderService::notify_wait_matcher()$/;"	f	class:ConnectionBuilderService	signature:()
notify_wait_matcher	lib_load_service.cpp	/^void LibLoadService::notify_wait_matcher()$/;"	f	class:LibLoadService	signature:()
notify_wait_put	comm_box.cpp	/^void Basebox::notify_wait_put()$/;"	f	class:Basebox	signature:()
notify_wait_ready_matcher	matcher_manager.cpp	/^void MatcherManager::notify_wait_ready_matcher()$/;"	f	class:MatcherManager	signature:()
np_	newlib.h	/^	int state_, np_, nw_;$/;"	m	struct:VideoLibVec	access:private
num_clients	comm_arg.hpp	/^	int num_clients;$/;"	m	struct:CommArg	access:public
num_elements	comm_box.hpp	/^	virtual std::size_t num_elements() const { return curr; }$/;"	f	class:RandomGetBox	access:public	signature:() const
num_elements	comm_box.hpp	/^	virtual std::size_t num_elements() const { return data_valid ? 1 : 0; }$/;"	f	class:CommBox	access:public	signature:() const
num_elements	comm_box.hpp	/^	virtual std::size_t num_elements() const$/;"	f	class:CommQueue	access:public	signature:() const
num_elements	comm_window.hpp	/^	virtual std::size_t num_elements() const$/;"	f	class:PacketWindow	access:public	signature:() const
num_load	matcher_manager.hpp	/^	unsigned num_load() const { return num_load_; }$/;"	f	class:Matcher	access:public	signature:() const
num_load_	matcher_manager.hpp	/^	unsigned num_load_;$/;"	m	class:Matcher	access:private
num_of_frames	newlib.h	/^	short num_of_frames;$/;"	m	struct:VideoLibRec	access:public
num_timeout_	match_stream.hpp	/^	int num_timeout_;$/;"	m	class:ConnectionBuilder	access:private
nw_	newlib.h	/^	int state_, np_, nw_;$/;"	m	struct:VideoLibVec	access:private
nwords	bit_feature.h	/^	int nwords() const { return nwords_; }$/;"	f	class:BitFeature	access:public	signature:() const
nwords_	bit_feature.h	/^	int nwords_;$/;"	m	class:BitFeature	access:private
offset_id	match_utils.h	/^	long long offset_id()  const {$/;"	f	struct:MatchSection	access:public	signature:() const
only_send_image	comm_arg.hpp	/^	int only_send_image;$/;"	m	struct:CommArg	access:public
only_send_lib	comm_arg.hpp	/^	int only_send_lib;$/;"	m	struct:CommArg	access:public
only_transform_lib	comm_arg.hpp	/^	int only_transform_lib;$/;"	m	struct:CommArg	access:public
open_services	server.cpp	/^void Server::open_services()$/;"	f	class:Server	signature:()
operator !	integral.h	/^	bool operator!() const { return size() == 0;  }		\/\/ test image validation$/;"	f	class:Image	access:public	signature:() const
operator !	newlib.h	/^	bool  operator !() const { return state_ != SYNC; }	\/\/ “Ï≥£◊¥Ã¨$/;"	f	struct:VideoLibVec	access:public	signature:() const
operator !=	raw.hpp	/^	inline bool operator != (const eth::address& x, const eth::address& y) { return x.to_longlong() != y.to_longlong(); }$/;"	f	namespace:eth	signature:(const eth::address& x, const eth::address& y)
operator ()	comm_box.hpp	/^	void operator () (T & lhs, T & rhs)$/;"	f	struct:SwapOp	access:public	signature:(T & lhs, T & rhs)
operator ()	comm_box.hpp	/^	void operator () (T & lhs, const T & rhs)$/;"	f	struct:AssignOp	access:public	signature:(T & lhs, const T & rhs)
operator ()	integral.h	/^	T  operator()(int row, int col) const { return pixel(row, col); }	\/\/ get the pixel$/;"	f	class:Image	access:public	signature:(int row, int col) const
operator ()	integral.h	/^	T& operator()(int row, int col)       { return pixel(row, col); }	\/\/ get\/set the pixel$/;"	f	class:Image	access:public	signature:(int row, int col)
operator ()	ipoint.h	/^	float operator () (const Ipoint& lhs, const I& rhs) const {$/;"	f	struct:EDist	access:public	signature:(const Ipoint& lhs, const I& rhs) const
operator ()	ipoint.h	/^	float operator () (const Ipoint& lhs, const I& rhs) const {$/;"	f	struct:MDist	access:public	signature:(const Ipoint& lhs, const I& rhs) const
operator <	match_utils.h	/^inline bool operator < (const MatchSection& lhs, const MatchSection& rhs)$/;"	f	signature:(const MatchSection& lhs, const MatchSection& rhs)
operator <	matcher_manager.cpp	/^bool operator < (const AppId & lhs, const AppId & rhs)$/;"	f	signature:(const AppId & lhs, const AppId & rhs)
operator <	raw.hpp	/^	inline bool operator <  (const eth::address& x, const eth::address& y) { return x.to_longlong() <  y.to_longlong(); }$/;"	f	namespace:eth	signature:(const eth::address& x, const eth::address& y)
operator <<	bit_feature.h	/^inline std::ostream& operator << (std::ostream& os, const BitFeature& f) {$/;"	f	signature:(std::ostream& os, const BitFeature& f)
operator <<	log.cpp	/^std::ostream& operator << (std::ostream& s, severity_level level) { return levelmap.writeEnum(s, level); }$/;"	f	namespace:LOG	signature:(std::ostream& s, severity_level level)
operator <<	match_utils.cpp	/^ostream& operator << (ostream& os, const MatchSection& sec) {$/;"	f	signature:(ostream& os, const MatchSection& sec)
operator <<	matcher_manager.cpp	/^std::ostream & operator << (std::ostream & os, const AppId & appid)$/;"	f	signature:(std::ostream & os, const AppId & appid)
operator <<	raw.cpp	/^std::ostream& operator << (std::ostream& os, const eth::endpoint& ep) {$/;"	f	namespace:eth	signature:(std::ostream& os, const eth::endpoint& ep)
operator <<	raw.hpp	/^	inline std::ostream& operator << (std::ostream& os, const eth::address& addr)$/;"	f	namespace:eth	signature:(std::ostream& os, const eth::address& addr)
operator ==	matcher_manager.cpp	/^bool operator == (const AppId & lhs, const AppId & rhs)$/;"	f	signature:(const AppId & lhs, const AppId & rhs)
operator ==	raw.hpp	/^	inline bool operator == (const eth::address& x, const eth::address& y) { return x.to_longlong() == y.to_longlong(); }$/;"	f	namespace:eth	signature:(const eth::address& x, const eth::address& y)
operator ^	bit_feature.h	/^inline BitFeature operator ^ (const BitFeature& lhs, const BitFeature& rhs) {$/;"	f	signature:(const BitFeature& lhs, const BitFeature& rhs)
operator bool	newlib.h	/^	operator   bool () const { return state_ == SYNC; }	\/\/ ’˝≥£◊¥Ã¨$/;"	f	struct:VideoLibVec	access:public	signature:() const
order_feature	bit_feature.cpp	/^BitFeature order_feature(int nbits, const GrayImage& gimg) {$/;"	f	signature:(int nbits, const GrayImage& gimg)
order_feature	bit_feature.cpp	/^BitFeature order_feature(int nbits, const IplImage* img) {$/;"	f	signature:(int nbits, const IplImage* img)
order_pairs128	bit_feature.cpp	/^	const int order_pairs128[128][2] = {$/;"	m	namespace:__anon5	file:
order_pairs32	bit_feature.cpp	/^	const int order_pairs32[32][2] = {$/;"	m	namespace:__anon5	file:
orientation	ipoint.h	/^	float orientation;		\/\/! Orientation measured anti-clockwise from +ve x-axis$/;"	m	struct:Ipoint	access:public
out_file	comm_arg.hpp	/^	std::string    out_file;$/;"	m	struct:CommArg	access:public
output_chains	match_utils.cpp	/^void SectionManager::output_chains(ostream& out, int test_id) {$/;"	f	class:SectionManager	signature:(ostream& out, int test_id)
output_result	app_manager.cpp	/^void AppDomain::output_result(const std::string & path)$/;"	f	class:AppDomain	signature:(const std::string & path)
output_result	app_manager.cpp	/^void AppDomain::output_result(std::ostream & out)$/;"	f	class:AppDomain	signature:(std::ostream & out)
output_result	match_analyser.cpp	/^void MatchAnalyser::output_result(std::ostream & out)$/;"	f	class:MatchAnalyser	signature:(std::ostream & out)
output_results	match_utils.cpp	/^void SectionManagerSimp::output_results(ostream& out, int test_id) {$/;"	f	class:SectionManagerSimp	signature:(ostream& out, int test_id)
overlap_len	match_utils.h	/^	int overlap_len;		\/\/ œ‡¡⁄¡Ω◊Èº‰÷ÿµ˛÷° ˝$/;"	m	struct:MatchArgs	access:public
packet_handle_loop	packet_handle_center.cpp	/^void PacketHandleCenter::packet_handle_loop()$/;"	f	class:PacketHandleCenter	signature:()
packet_pause	comm_arg.hpp	/^	unsigned packet_pause;$/;"	m	struct:CommArg	access:public
packet_queue	server.hpp	/^	PacketQueue        * packet_queue()        { return &pkt_queue_; }$/;"	f	class:Server	access:public	signature:()
packet_type	raw.hpp	/^	unsigned int packet_type() const { return data_.sll_pkttype; }$/;"	f	class:eth::endpoint	access:public	signature:() const
parse_host_file	comm_arg.cpp	/^bool CommArg::parse_host_file( const char * file )$/;"	f	class:CommArg	signature:( const char * file )
parse_info_file	comm_arg.cpp	/^bool CommArg::parse_info_file( const char * file )$/;"	f	class:CommArg	signature:( const char * file )
pause_time	match_stream.hpp	/^	unsigned pause_time() const { return paused_time_; }$/;"	f	class:BitFeatureSender	access:public	signature:() const
paused_time_	match_stream.hpp	/^	unsigned paused_time_;$/;"	m	class:BitFeatureSender	access:private
pdss_id	comm_arg.hpp	/^	unsigned pdss_id;$/;"	m	struct:CommArg	access:public
pixel	integral.h	/^	T  pixel(int row, int col) const { return data_[row * width_ + col]; }	\/\/ get the pixel$/;"	f	class:Image	access:protected	signature:(int row, int col) const
pixel	integral.h	/^	T& pixel(int row, int col)       { return data_[row * width_ + col]; }	\/\/ get\/set the pixel$/;"	f	class:Image	access:protected	signature:(int row, int col)
pkt_	match_stream.hpp	/^	Packet pkt_;$/;"	m	class:ConnectionBuilder	access:private
pkt_queue_	server.hpp	/^	PacketQueue           pkt_queue_;$/;"	m	class:Server	access:private
point	utils.h	/^		struct point$/;"	s	struct:UTILS::image	access:public
point_	newlib.h	/^	BitFeature point_;$/;"	m	struct:VideoLibVec	access:private
point_vec	newlib.h	/^	LibPointVec point_vec;$/;"	m	struct:VideoLibRec	access:public
points	utils.h	/^		std::vector<point> points;$/;"	m	struct:UTILS::image	access:public
port	matcher_manager.hpp	/^	unsigned            port   () const { return endpoint_.port(); }$/;"	f	class:Matcher	access:public	signature:() const
port	server.hpp	/^	unsigned short                 port() const { return local_point_.port(); }$/;"	f	class:Server	access:public	signature:() const
print_matcher_util	matcher_manager.cpp	/^void MatcherManager::print_matcher_util( ostream & out, const Matchers & ms ) const$/;"	f	class:MatcherManager	signature:( ostream & out, const Matchers & ms ) const
print_matchers	matcher_manager.cpp	/^void MatcherManager::print_matchers     (std::ostream & out) const$/;"	f	class:MatcherManager	signature:(std::ostream & out) const
protocol	raw.hpp	/^	int protocol() const { return htons(ETH_P_ALL); }	\/\/ 0x0300$/;"	f	struct:eth::raw	access:public	signature:() const
protocol	raw.hpp	/^	protocol_type protocol() const { return raw(); }$/;"	f	class:eth::endpoint	access:public	signature:() const
protocol_type	raw.hpp	/^	typedef raw protocol_type;$/;"	t	class:eth::endpoint	access:public
put	comm_box.hpp	/^	void put()$/;"	f	class:RandomGetBox	access:public	signature:()
put	comm_box.hpp	/^	void put(T p)$/;"	f	class:CommQueue	access:public	signature:(T p)
put	comm_box.hpp	/^	void put(const T & t)$/;"	f	class:CommBox	access:public	signature:(const T & t)
put	comm_window.hpp	/^	void put()$/;"	f	class:PacketWindow	access:public	signature:()
put_condition_not_satisfied	comm_box.hpp	/^	virtual bool put_condition_not_satisfied() const { return box_full(); }$/;"	f	class:Basebox	access:public	signature:() const
queue_	comm_box.hpp	/^	Queue queue_;$/;"	m	class:CommQueue	access:private
quit_	packet_handle_center.hpp	/^	bool quit_;$/;"	m	class:PacketHandleCenter	access:private
quit_wanted_	server.hpp	/^	bool quit_wanted_;$/;"	m	class:Server	access:private
random_loop	comm_arg.hpp	/^	int random_loop;$/;"	m	struct:CommArg	access:public
raw	raw.hpp	/^struct raw {			\/\/ ethernet protocol$/;"	s	namespace:eth
raw_packet_base__	packet.hpp	/^typedef BasicPacket<RAW_HEAD_SIZE, RAW_MAX_LOAD_LEN> raw_packet_base__;$/;"	t
raw_response_packet_base__	packet.hpp	/^typedef BasicPacket<RAW_HEAD_SIZE, RAW_MIN_LOAD_LEN> raw_response_packet_base__;$/;"	t
readEnum	fdutils.h	/^	E readEnum(std::istream& s) const {$/;"	f	class:EnumStringMap	access:public	signature:(std::istream& s) const
ready_receive	matcher_manager.hpp	/^	bool ready_receive() const { return (state_ == READY); }$/;"	f	class:Matcher	access:public	signature:() const
recv_buffer_	server.hpp	/^	boost::asio::mutable_buffers_1 recv_buffer_;        \/\/ receive asio buffer$/;"	m	class:Server	access:private
recv_diverse_handler	server.cpp	/^void Server::recv_diverse_handler(const boost::system::error_code& ec, size_t length)$/;"	f	class:Server	signature:(const boost::system::error_code& ec, size_t length)
recv_pkt_	server.hpp	/^	Packet recv_pkt_;                                   \/\/ receive packet buffer$/;"	m	class:Server	access:private
remove_matcher	matcher_manager.cpp	/^void MatcherManager::remove_matcher( const Matcher & m )$/;"	f	class:MatcherManager	signature:( const Matcher & m )
reply	command.cpp	/^void AddNodesCommand::reply()$/;"	f	class:AddNodesCommand	signature:()
reply	command.cpp	/^void DomainCreateCommand::reply()$/;"	f	class:DomainCreateCommand	signature:()
reply	command.cpp	/^void ICommand::reply(unsigned msg_key)$/;"	f	class:ICommand	signature:(unsigned msg_key)
reply	command.cpp	/^void QueryLoadsCommand::reply()$/;"	f	class:QueryLoadsCommand	signature:()
reply	command.cpp	/^void RemoveNodesCommand::reply()$/;"	f	class:RemoveNodesCommand	signature:()
reply	command.cpp	/^void ShowResultCommand::reply()$/;"	f	class:ShowResultCommand	signature:()
reply	command.hpp	/^	virtual void reply  () {}$/;"	f	class:TerminalChangeCommand	access:public	signature:()
report_all	app_manager.hpp	/^	void report_all(std::ostream & out) {$/;"	f	class:AppManager	access:public	signature:(std::ostream & out)
req_	raw.hpp	/^	int req_;$/;"	m	class:eth::device_config	access:private
reset	comm_window.hpp	/^	void reset()$/;"	f	class:PacketWindow	access:public	signature:()
reset	integral.h	/^	void reset(int w, int h) { width_ = w; height_ = h; delete[] data_; data_ = new T[w*h]; }$/;"	f	class:Image	access:public	signature:(int w, int h)
reset	newlib.h	/^	void reset(int nbits) {$/;"	f	struct:VideoLibVec	access:public	signature:(int nbits)
resize	raw.hpp	/^	void resize(std::size_t s) { size_ = s; }$/;"	f	class:eth::endpoint	access:public	signature:(std::size_t s)
result_count	matcher_manager.hpp	/^	U08 result_count() const { return result_count_; }$/;"	f	class:Matcher	access:public	signature:() const
result_count_	matcher_manager.hpp	/^	U08 result_count_;$/;"	m	class:Matcher	access:private
results	match_utils.h	/^	const MatchResults& results() const { return results_; }$/;"	f	class:SectionManager	access:public	signature:() const
results	match_utils.h	/^	const MatchResults& results() const { return sec_man_.results(); }$/;"	f	class:VideoMatcher	access:public	signature:() const
results_	match_utils.h	/^	MatchResults results_;$/;"	m	class:SectionManager	access:private
results_	match_utils.h	/^	std::map<long long, int> results_;			\/\/  π”√offset_id◊˜Œ™key$/;"	m	class:SectionManagerSimp	access:private
run	command_recv_service.cpp	/^void CommandRecvService::run()$/;"	f	class:CommandRecvService	signature:()
run	connection_build_service.cpp	/^void ConnectionBuilderService::run()$/;"	f	class:ConnectionBuilderService	signature:()
run	lib_load_service.cpp	/^void LibLoadService::run()$/;"	f	class:LibLoadService	signature:()
run	match_stream.hpp	/^	void run()$/;"	f	class:StreamNode	access:public	signature:()
run	packet_handle_center.cpp	/^void PacketHandleCenter::run()$/;"	f	class:PacketHandleCenter	signature:()
run	raw.cpp	/^bool device_config::run(socket& sock) {$/;"	f	class:eth::device_config	signature:(socket& sock)
same_sequence	match_utils.h	/^inline bool same_sequence(const MatchSection& lhs, const MatchSection& rhs)$/;"	f	signature:(const MatchSection& lhs, const MatchSection& rhs)
saveLibNew	newlib.cpp	/^int saveLibNew( const VideoLibRec& video_rec, const std::string& file_name )$/;"	f	signature:( const VideoLibRec& video_rec, const std::string& file_name )
saveLibNew	newlib.cpp	/^int saveLibNew( const VideoLibRec& video_rec, std::ostream& of )$/;"	f	signature:( const VideoLibRec& video_rec, std::ostream& of )
saveNewVideoLib	match_utils.cpp	/^int saveNewVideoLib(int nbits, const string& video_name, int video_num, LIB& lib) {$/;"	f	signature:(int nbits, const string& video_name, int video_num, LIB& lib)
saveSurf	utils.cpp	/^void saveSurf(char *filename, vector<Ipoint> &ipts)$/;"	f	signature:(char *filename, vector<Ipoint> &ipts)
saveSurf	utils.cpp	/^void saveSurf(ostream& outfile, vector<Ipoint> &ipts)$/;"	f	signature:(ostream& outfile, vector<Ipoint> &ipts)
scale	ipoint.h	/^	float scale;			\/\/! Detected scale$/;"	m	struct:Ipoint	access:public
sec_dist	match_utils.h	/^inline int sec_dist(const MatchSection& lhs, const MatchSection& rhs) {$/;"	f	signature:(const MatchSection& lhs, const MatchSection& rhs)
sec_man_	app_manager.hpp	/^	SectionManagerSimp sec_man_;$/;"	m	class:AppDomain	access:private
sec_man_	match_analyser.hpp	/^	SectionManager sec_man_;$/;"	m	class:MatchAnalyser	access:private
sec_man_	match_utils.h	/^	SectionManager sec_man_;$/;"	m	class:VideoMatcher	access:private
send	command_recv_service.cpp	/^void CommandRecvService::send( const boost::asio::mutable_buffers_1 & buffer )$/;"	f	class:CommandRecvService	signature:( const boost::asio::mutable_buffers_1 & buffer )
send	server.cpp	/^void Server::send( const boost::asio::mutable_buffers_1 & buffer, const udp::endpoint & dest )$/;"	f	class:Server	signature:( const boost::asio::mutable_buffers_1 & buffer, const udp::endpoint & dest )
send_handler	server.cpp	/^void Server::send_handler(const boost::system::error_code& ec, size_t length)$/;"	f	class:Server	signature:(const boost::system::error_code& ec, size_t length)
send_packets	match_stream.cpp	/^void NewLibSender::send_packets()$/;"	f	class:NewLibSender	signature:()
send_packets_loop	command_recv_service.cpp	/^void CommandRecvService::send_packets_loop()$/;"	f	class:CommandRecvService	signature:()
send_packets_loop	match_stream.cpp	/^void BitFeatureSender::send_packets_loop()$/;"	f	class:BitFeatureSender	signature:()
send_port	comm_arg.hpp	/^	unsigned short send_port;$/;"	m	struct:CommArg	access:public
send_sock_	server.hpp	/^	boost::asio::ip::udp::socket send_sock_;            \/\/ main thread socket$/;"	m	class:Server	access:private
sender_	app_manager.hpp	/^	BitFeatureSender * sender_;$/;"	m	class:AppDomain	access:private
sender_	command_recv_service.hpp	/^	datagram_protocol::endpoint sender_;$/;"	m	class:CommandRecvService	access:private
sent_frames	app_manager.hpp	/^	unsigned sent_frames() const { return sent_frames_; }$/;"	f	class:AppDomain	access:public	signature:() const
sent_frames_	app_manager.hpp	/^	unsigned sent_frames_;$/;"	m	class:AppDomain	access:private
server_	command_recv_service.hpp	/^	datagram_protocol::endpoint server_;$/;"	m	class:CommandRecvService	access:private
server_	server.hpp	/^	static Server * server_;$/;"	m	class:Server	access:private
server_port	comm_arg.hpp	/^	unsigned short server_port;$/;"	m	struct:CommArg	access:public
set	bits.hpp	/^	void set (int i) { ASSERTS(i < N);        bytes[i >> SHIFT] |=  (0x80 >> (i & MASK)); }$/;"	f	struct:bits	access:public	signature:(int i)
set	bits.hpp	/^	void set()       { memset(byte_ptr(), 0xFF, N >> SHIFT); }$/;"	f	struct:bits	access:public	signature:()
set_accuracy	match_utils.cpp	/^void MatchArgs::set_accuracy(int a) {$/;"	f	class:MatchArgs	signature:(int a)
set_address	raw.cpp	/^void endpoint::set_address(const eth::address& addr) {$/;"	f	class:eth::endpoint	signature:(const eth::address& addr)
set_bits	bit_feature.h	/^	void set_bits(int n) {$/;"	f	class:BitFeature	access:public	signature:(int n)
set_built	match_stream.cpp	/^void ConnectionBuilder::set_built(bool b)$/;"	f	class:ConnectionBuilder	signature:(bool b)
set_console_filter	log.h	/^	template<typename F> inline void set_console_filter(F const& flt)$/;"	f	namespace:LOG	signature:(F const& flt)
set_console_format	log.h	/^	template<typename F> inline void set_console_format(F const& fmt)$/;"	f	namespace:LOG	signature:(F const& fmt)
set_converge	match_utils.cpp	/^void MatchArgs::set_converge(int c) {$/;"	f	class:MatchArgs	signature:(int c)
set_ctrl	packet.hpp	/^	void        set_ctrl(u_char c) { bytes_[HEAD_SIZE + 2] = c; }$/;"	f	class:BasicPacket	access:public	signature:(u_char c)
set_data_len	packet.hpp	/^	void set_data_len(unsigned l)$/;"	f	class:BasicPacket	access:public	signature:(unsigned l)
set_dest_addr	match_stream.cpp	/^void BitFeatureSender::set_dest_addr( const endpoint & addr )$/;"	f	class:BitFeatureSender	signature:( const endpoint & addr )
set_domain_id	matcher_manager.hpp	/^	void set_domain_id(DomainType d) { domain_id_ = d; }$/;"	f	class:Matcher	access:public	signature:(DomainType d)
set_file_filter	log.h	/^	template<typename F> inline void set_file_filter(F const& flt)$/;"	f	namespace:LOG	signature:(F const& flt)
set_file_format	log.h	/^	template<typename F> inline void set_file_format(F const& fmt)$/;"	f	namespace:LOG	signature:(F const& fmt)
set_filter	log.h	/^	template<typename SP, typename FLT> inline void set_filter(SP sink, FLT const& flt)$/;"	f	namespace:LOG	signature:(SP sink, FLT const& flt)
set_format	log.h	/^	template<typename SP, typename FMT> inline void set_format(SP sink, FMT const& fmt)$/;"	f	namespace:LOG	signature:(SP sink, FMT const& fmt)
set_from_point	packet.hpp	/^	void set_from_point(const udp::endpoint & e)$/;"	f	class:CfaUdpPacket	access:public	signature:(const udp::endpoint & e)
set_ifindex	raw.hpp	/^	void set_ifindex(int index) { data_.sll_ifindex = index; }$/;"	f	class:eth::endpoint	access:public	signature:(int index)
set_index	packet.hpp	/^	void       set_index(u_char c) { bytes_[HEAD_SIZE + 1] = c; }$/;"	f	class:BasicPacket	access:public	signature:(u_char c)
set_info	packet.hpp	/^	void       	set_info(u_char type, u_char idx) { set_type(type); set_index(idx); }$/;"	f	class:BasicPacket	access:public	signature:(u_char type, u_char idx)
set_info	packet.hpp	/^	void       	set_info(u_char type, u_char idx, int len) { set_type(type); set_index(idx); set_data_len(len); }$/;"	f	class:BasicPacket	access:public	signature:(u_char type, u_char idx, int len)
set_load_len	packet.hpp	/^	void set_load_len(unsigned l)  { set_data_len(l - 2); }$/;"	f	class:BasicPacket	access:public	signature:(unsigned l)
set_loader	app_manager.hpp	/^	void set_loader(BitFeatureLoader * p) { loader_ = p; }$/;"	f	class:AppDomain	access:private	signature:(BitFeatureLoader * p)
set_match_threshold	matcher_manager.cpp	/^void Matcher::set_match_threshold( unsigned n )$/;"	f	class:Matcher	signature:( unsigned n )
set_matcher_state	matcher_manager.cpp	/^void MatcherManager::set_matcher_state( const Matcher & m , Matcher::MATCHER_STATE s )$/;"	f	class:MatcherManager	signature:( const Matcher & m , Matcher::MATCHER_STATE s )
set_merge_threshold	matcher_manager.cpp	/^void Matcher::set_merge_threshold( unsigned n )$/;"	f	class:Matcher	signature:( unsigned n )
set_merge_unit	matcher_manager.cpp	/^void Matcher::set_merge_unit(unsigned m)$/;"	f	class:Matcher	signature:(unsigned m)
set_nbits	matcher_manager.cpp	/^void Matcher::set_nbits( unsigned n )$/;"	f	class:Matcher	signature:( unsigned n )
set_num_load	matcher_manager.cpp	/^void Matcher::set_num_load(unsigned num)$/;"	f	class:Matcher	signature:(unsigned num)
set_sender	app_manager.hpp	/^	void set_sender(BitFeatureSender * p) { sender_ = p; }$/;"	f	class:AppDomain	access:private	signature:(BitFeatureSender * p)
set_size	bits.hpp	/^	void set_size(int n)$/;"	f	struct:bits	access:public	signature:(int n)
set_snk_mac	packet.hpp	/^	void       set_snk_mac(const eth::address& addr) { memcpy(bytes_    , addr.to_bytes(), 6); }$/;"	f	class:BasicPacket	access:public	signature:(const eth::address& addr)
set_src_mac	packet.hpp	/^	void       set_src_mac(const eth::address& addr) { memcpy(bytes_ + 6, addr.to_bytes(), 6); }$/;"	f	class:BasicPacket	access:public	signature:(const eth::address& addr)
set_state	matcher_manager.hpp	/^	void set_state(MATCHER_STATE s) { lock lk(monitor_); state_ = s; }$/;"	f	class:Matcher	access:public	signature:(MATCHER_STATE s)
set_total_len	packet.hpp	/^	void set_total_len(unsigned l) {$/;"	f	class:BasicPacket	access:public	signature:(unsigned l)
set_type	packet.hpp	/^	void        set_type(u_char c) { bytes_[HEAD_SIZE + 0] = c; }$/;"	f	class:BasicPacket	access:public	signature:(u_char c)
sev_levels	log.cpp	/^static const char* sev_levels[] = { "DEBUG", "VERBOSE", "INFO ", "WARN ", "ERROR" };$/;"	m	namespace:LOG	file:
sev_logger	log.h	/^	typedef src::severity_logger<severity_level> sev_logger;$/;"	t	namespace:LOG
severity_level	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	g	namespace:LOG
showImage	utils.cpp	/^void showImage(char *title,const IplImage *img)$/;"	f	signature:(char *title,const IplImage *img)
showImage	utils.cpp	/^void showImage(const IplImage *img)$/;"	f	signature:(const IplImage *img)
sin_ori	ipoint.h	/^	float sin_ori, cos_ori;	\/\/! sin(orientation) and cos(orientation)$/;"	m	struct:Ipoint	access:public
single2half	fdutils.h	/^static halfp single2half(float f) {$/;"	f	signature:(float f)
sink_con_	log.h	/^		sp_stream_sink sink_con_;$/;"	m	class:LOG::Log	access:private
sink_file_	log.h	/^		sp_file_sink   sink_file_;$/;"	m	class:LOG::Log	access:private
size	integral.h	/^	int size()   const { return width_ * height_; }$/;"	f	class:Image	access:public	signature:() const
size	ipoint.h	/^	int size() const { return matches_.size(); }$/;"	f	class:Matches	access:public	signature:() const
size	raw.hpp	/^	std::size_t size() const { return size_; }$/;"	f	class:eth::endpoint	access:public	signature:() const
size_	raw.hpp	/^	std::size_t size_;$/;"	m	class:eth::endpoint	access:private
sleep_time	comm_arg.hpp	/^  	int sleep_time;$/;"	m	struct:CommArg	access:public
slg_	log.h	/^		sev_logger     slg_;$/;"	m	class:LOG::Log	access:private
slice_id	match_utils.h	/^	int slice_id() const { return test_id()  & 0x3ff; }$/;"	f	struct:MatchSection	access:public	signature:() const
slice_len	match_utils.h	/^	int slice_len;			\/\/ ‘Ÿæ€∫œ ”∆µ≥§∂»$/;"	m	struct:MatchArgs	access:public
slice_thres	match_utils.h	/^	int slice_thres;		\/\/ ‘Ÿæ€∫œ„–÷µ$/;"	m	struct:MatchArgs	access:public
slice_thres_	match_utils.h	/^	int slice_thres_;$/;"	m	class:SectionManagerSimp	access:private
snk_addr	packet.hpp	/^	eth::address snk_addr() const { return eth::address(bytes_    , 6); }$/;"	f	class:BasicPacket	access:public	signature:() const
snk_id	command.hpp	/^	U32 snk_id;$/;"	m	struct:DCSPPacket	access:public
sock_	command_recv_service.hpp	/^	datagram_protocol::socket sock_;$/;"	m	class:CommandRecvService	access:private
socket	raw.hpp	/^	explicit socket(boost::asio::io_service& io_service)$/;"	f	struct:eth::socket	access:public	signature:(boost::asio::io_service& io_service)
socket	raw.hpp	/^	socket(boost::asio::io_service& io_service, const char* dev)$/;"	f	struct:eth::socket	access:public	signature:(boost::asio::io_service& io_service, const char* dev)
socket	raw.hpp	/^	socket(boost::asio::io_service& io_service, const endpoint& ep)$/;"	f	struct:eth::socket	access:public	signature:(boost::asio::io_service& io_service, const endpoint& ep)
socket	raw.hpp	/^	socket(boost::asio::io_service& io_service, const raw& protocol)$/;"	f	struct:eth::socket	access:public	signature:(boost::asio::io_service& io_service, const raw& protocol)
socket	raw.hpp	/^	socket(boost::asio::io_service& io_service, const raw& protocol,$/;"	f	struct:eth::socket	access:public	signature:(boost::asio::io_service& io_service, const raw& protocol, const boost::asio::raw_socket_service<raw>::native_handle_type& native_socket)
socket	raw.hpp	/^struct socket : boost::asio::basic_raw_socket<raw> {	\/\/ ethernet socket$/;"	s	namespace:eth	inherits:boost::asio::basic_raw_socket
socket_	server.hpp	/^	boost::asio::ip::udp::socket socket_;               \/\/ main thread socket$/;"	m	class:Server	access:private
sources	comm_arg.hpp	/^	std::vector<std::string> sources;$/;"	m	struct:CommArg	access:public
sp_file_sink	log.h	/^	typedef boost::shared_ptr<sinks::synchronous_sink<sinks::text_file_backend> >    sp_file_sink;$/;"	t	namespace:LOG
sp_log_core	log.h	/^	typedef boost::shared_ptr<logging::core>     sp_log_core;$/;"	t	namespace:LOG
sp_stream_sink	log.h	/^	typedef boost::shared_ptr<sinks::synchronous_sink<sinks::text_ostream_backend> > sp_stream_sink;$/;"	t	namespace:LOG
speed	app_manager.cpp	/^unsigned AppDomain::speed() const$/;"	f	class:AppDomain	signature:() const
src_addr	packet.hpp	/^	eth::address src_addr() const { return eth::address(bytes_ + 6, 6); }$/;"	f	class:BasicPacket	access:public	signature:() const
src_endpoint_	packet.hpp	/^	udp::endpoint src_endpoint_;$/;"	m	class:CfaUdpPacket	access:private
src_id	command.hpp	/^	U32 src_id;$/;"	m	struct:DCSPPacket	access:public
start	server.cpp	/^void Server::start()$/;"	f	class:Server	signature:()
start_main	server.cpp	/^void Server::start_main()$/;"	f	class:Server	signature:()
start_running_stream	match_stream.hpp	/^	void start_running_stream()$/;"	f	class:StreamLine	access:public	signature:()
start_timer	matcher_manager.cpp	/^void MatcherManager::start_timer()$/;"	f	class:MatcherManager	signature:()
state	matcher_manager.hpp	/^	MATCHER_STATE state() const { return state_; }$/;"	f	class:Matcher	access:public	signature:() const
state_	matcher_manager.hpp	/^	MATCHER_STATE state_;$/;"	m	class:Matcher	access:private
state_	newlib.h	/^	int state_, np_, nw_;$/;"	m	struct:VideoLibVec	access:private
stop_io_service	command_recv_service.hpp	/^	void stop_io_service() { io_.stop(); }$/;"	f	class:CommandRecvService	access:public	signature:()
store	newlib.cpp	/^void VideoLibVec::store(unsigned int word, bool from_net) {$/;"	f	class:VideoLibVec	signature:(unsigned int word, bool from_net)
storeMatch	ipoint.cpp	/^void Matches<EDist, Ipoint>::storeMatch(Ipoint* ipt) {$/;"	f	class:Matches	signature:(Ipoint* ipt)
storeMatch	ipoint.cpp	/^void Matches<MDist, Ipoint>::storeMatch(Ipoint* ipt) {$/;"	f	class:Matches	signature:(Ipoint* ipt)
storeMatch	ipoint.h	/^	void storeMatch(Ipoint* ipt)$/;"	f	class:Matches	access:private	signature:(Ipoint* ipt)
surf_lib_window	server.hpp	/^	SurfLibWindow      * surf_lib_window()     { return &surf_lib_window_; }	$/;"	f	class:Server	access:public	signature:()
surf_lib_window_	server.hpp	/^	SurfLibWindow         surf_lib_window_;				\/\/ window for sending surf lib points$/;"	m	class:Server	access:private
surf_lib_window_base__	comm_window.hpp	/^typedef PacketWindow<16> surf_lib_window_base__;$/;"	t
swap	utils.h	/^		void swap(image & other)$/;"	f	struct:UTILS::image	access:public	signature:(image & other)
tail	comm_box.hpp	/^	int tail;$/;"	m	class:RandomGetBox	access:protected
tail	comm_window.hpp	/^	std::size_t tail;	\/\/ ∂”¡–Œ≤£¨÷∏œÚ“ª∏ˆø’∞¸£¨”…acquire()∑µªÿ$/;"	m	class:PacketWindow	access:protected
target_nodes	command.hpp	/^	const Nodes & target_nodes() { return nodes_; }$/;"	f	class:AddNodesCommand	access:public	signature:()
target_nodes	command.hpp	/^	const Nodes & target_nodes() { return nodes_; }$/;"	f	class:RemoveNodesCommand	access:public	signature:()
test	bits.hpp	/^	bool test(int i) { ASSERTS(i < N); return bytes[i >> SHIFT] &   (0x80 >> (i & MASK)); }$/;"	f	struct:bits	access:public	signature:(int i)
test_begin	match_utils.h	/^	int test_begin, lib_begin;$/;"	m	struct:MatchSection	access:public
test_id	match_utils.h	/^	int test_id()  const { return (test_begin >> 12) & 0xfffff; }	\/\/ ∫¨ ”∆µ∫≈∫Õ∆¨∂Œ∫≈$/;"	f	struct:MatchSection	access:public	signature:() const
test_num	match_utils.h	/^inline int test_num(int vid, int sid, int pos)$/;"	f	signature:(int vid, int sid, int pos)
test_pos	match_utils.h	/^	int test_pos() const { return test_begin & 0xfff;  }$/;"	f	struct:MatchSection	access:public	signature:() const
testid_set_	app_manager.hpp	/^	std::set<unsigned> testid_set_;$/;"	m	class:AppDomain	access:private
tg	match_stream.hpp	/^	boost::thread_group tg;$/;"	m	class:StreamLine	access:private
threadRange	fdutils.h	/^inline Range threadRange(Range drng, int tid) {$/;"	f	signature:(Range drng, int tid)
threshold	ipoint.h	/^	float threshold() const { return 0.42; }$/;"	f	struct:EDist	access:public	signature:() const
threshold	ipoint.h	/^	float threshold() const { return 0.6; }$/;"	f	struct:MDist	access:public	signature:() const
time_stamp	match_utils.h	/^	double time_stamp;$/;"	m	struct:VideoCapcture	access:public
timer_	matcher_manager.hpp	/^	boost::timer::cpu_timer timer_;$/;"	m	class:MatcherManager	access:private
to_buffer	command.hpp	/^	const boost::asio::mutable_buffers_1 to_buffer()$/;"	f	struct:DCSPPacket	access:public	signature:()
to_bytes	raw.hpp	/^	const bytes_type& to_bytes() const { return bytes_; }$/;"	f	class:eth::address	access:public	signature:() const
to_endpoint	matcher_manager.hpp	/^	const endpoint_type to_endpoint() const { return endpoint_; }$/;"	f	class:Matcher	access:public	signature:() const
to_int	bits.hpp	/^	int to_int() {$/;"	f	struct:bits	access:public	signature:()
to_longlong	raw.cpp	/^unsigned long long address::to_longlong() const {$/;"	f	class:eth::address	signature:() const
to_raw_buffer	packet.hpp	/^	boost::asio::mutable_buffers_1 to_raw_buffer() { return boost::asio::buffer(bytes_, total_len()); }$/;"	f	class:BasicPacket	access:public	signature:()
to_string	bits.hpp	/^	std::string to_string() {$/;"	f	struct:bits	access:public	signature:()
to_string	matcher_manager.hpp	/^	std::string to_string() const {$/;"	f	struct:AppId	access:public	signature:() const
to_string	raw.cpp	/^string address::to_string() const {$/;"	f	class:eth::address	signature:() const
to_udp_buffer	packet.hpp	/^	boost::asio::mutable_buffers_1 to_udp_buffer() { return boost::asio::buffer(bytes_ + UDP_HEAD_SIZE, total_len() - UDP_HEAD_SIZE ); }$/;"	f	class:BasicPacket	access:public	signature:()
total_frames	newlib.h	/^	int total_frames() const { return total_frames_; }$/;"	f	struct:VideoLibVec	access:public	signature:() const
total_frames_	newlib.h	/^	int total_frames_;$/;"	m	struct:VideoLibVec	access:private
total_len	packet.hpp	/^	int     total_len() const { return load_len() + HEAD_SIZE; }$/;"	f	class:BasicPacket	access:public	signature:() const
transformImage	match_utils.cpp	/^IplImage* transformImage(IplImage* img) {$/;"	f	signature:(IplImage* img)
type	packet.hpp	/^	u_char          type() const   { return bytes_[HEAD_SIZE + 0]; }$/;"	f	class:BasicPacket	access:public	signature:() const
type	raw.hpp	/^	int type()     const { return SOCK_RAW; }$/;"	f	struct:eth::raw	access:public	signature:() const
u_char	comm_para.hpp	/^typedef unsigned char      u_char;$/;"	t
u_char_to_decimal_string	command.cpp	/^	const std::string u_char_to_decimal_string(u_char c)$/;"	f	namespace:__anon3	signature:(u_char c)
uint32	fdutils.h	/^typedef unsigned int  uint32;		\/\/ 32 bit$/;"	t
unhandled_frames	app_manager.cpp	/^unsigned AppDomain::unhandled_frames() const$/;"	f	class:AppDomain	signature:() const
unsigned_to_string	command.cpp	/^const std::string ICommand::unsigned_to_string(unsigned ip)$/;"	f	class:ICommand	signature:(unsigned ip)
update_all_matcher_load	matcher_manager.cpp	/^void MatcherManager::update_all_matcher_load()$/;"	f	class:MatcherManager	signature:()
update_len_bytes	packet.hpp	/^	virtual void update_len_bytes()$/;"	f	class:BasicPacket	access:public	signature:()
update_len_bytes	packet.hpp	/^	virtual void update_len_bytes()$/;"	f	class:CfaUdpPacket	access:public	signature:()
update_len_bytes	packet.hpp	/^	virtual void update_len_bytes()$/;"	f	class:CfaUdpResponPacket	access:public	signature:()
update_pause_time	match_stream.cpp	/^void BitFeatureSender::update_pause_time(unsigned v)$/;"	f	class:BitFeatureSender	signature:(unsigned v)
use_packet_pause	comm_arg.hpp	/^	int use_packet_pause;$/;"	m	struct:CommArg	access:public
vec_	match_stream.hpp	/^	VideoLibVec vec_;$/;"	m	class:BitFeatureLoader	access:private
video_beg	comm_arg.hpp	/^	int video_beg;$/;"	m	struct:CommArg	access:public
video_end	comm_arg.hpp	/^	int video_end;$/;"	m	struct:CommArg	access:public
video_id	match_utils.h	/^	int video_id() const { return test_id()  >> 10; }$/;"	f	struct:MatchSection	access:public	signature:() const
video_id	utils.h	/^		unsigned video_id () const { return frame_index >> 24; }$/;"	f	struct:UTILS::image	access:public	signature:() const
video_num	newlib.h	/^	short video_num;$/;"	m	struct:VideoLibRec	access:public
video_pause	comm_arg.hpp	/^	int video_pause;$/;"	m	struct:CommArg	access:public
video_ratio	comm_arg.hpp	/^	int video_ratio;$/;"	m	struct:CommArg	access:public
videos	comm_arg.hpp	/^	std::vector<std::string> videos;$/;"	m	struct:CommArg	access:public
wait_all_end	server.hpp	/^	void wait_all_end()$/;"	f	class:Server	access:public	signature:()
wait_get_condition	comm_box.cpp	/^void Basebox::wait_get_condition()$/;"	f	class:Basebox	signature:()
wait_put_condition	comm_box.cpp	/^void Basebox::wait_put_condition()$/;"	f	class:Basebox	signature:()
wait_stream_end	match_stream.hpp	/^	void wait_stream_end()$/;"	f	class:StreamLine	access:public	signature:()
wait_until_box_empty	comm_box.cpp	/^void Basebox::wait_until_box_empty()$/;"	f	class:Basebox	signature:()
wanna_quit	server.hpp	/^	bool wanna_quit() const { return quit_wanted_; }$/;"	f	class:Server	access:public	signature:() const
width	integral.h	/^	int width()  const { return width_;  }$/;"	f	class:Image	access:public	signature:() const
width_	integral.h	/^	int width_;             \/\/ Image width in pixels$/;"	m	class:Image	access:private
window	app_manager.hpp	/^	BitFeatureWindow * window() { return &window_; }$/;"	f	class:AppDomain	access:public	signature:()
window_	app_manager.hpp	/^	BitFeatureWindow window_;$/;"	m	class:AppDomain	access:private
words	bit_feature.h	/^		Word   words[MAX_FEATURE_BITS\/32];$/;"	m	union:BitFeature::__anon7	access:public
writeEnum	fdutils.h	/^	std::ostream& writeEnum(std::ostream& s, E val) { return s << getString(val); }$/;"	f	class:EnumStringMap	access:public	signature:(std::ostream& s, E val)
x	ipoint.h	/^	float x, y;				\/\/! Coordinates of the detected interest point$/;"	m	struct:Ipoint	access:public
xml_attribute	match_analyser.cpp	10;"	d	file:
y	ipoint.h	/^	float x, y;				\/\/! Coordinates of the detected interest point$/;"	m	struct:Ipoint	access:public
~ConnectionBuilder	match_stream.cpp	/^ConnectionBuilder::~ConnectionBuilder()$/;"	f	class:ConnectionBuilder	signature:()
~Image	integral.h	/^	~Image() { delete[] data_; }$/;"	f	class:Image	access:public	signature:()
~StreamLine	match_stream.hpp	/^	~StreamLine()$/;"	f	class:StreamLine	access:public	signature:()
~StreamNode	match_stream.hpp	/^	virtual ~StreamNode() {}$/;"	f	class:StreamNode	access:public	signature:()
~VideoCapcture	match_utils.cpp	/^VideoCapcture::~VideoCapcture() { cvReleaseCapture(&capture); }$/;"	f	class:VideoCapcture	signature:()
