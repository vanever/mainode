!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ASSERT	log.h	81;"	d
ASSERTD	log.h	91;"	d
ASSERTS	log.h	87;"	d
ASSERTSD	log.h	92;"	d
AssertionFail	log.h	/^	AssertionFail()  : std::runtime_error("Assertion failed, please check the log file for more information.") {}$/;"	f	struct:AssertionFail	access:public	signature:()
AssertionFail	log.h	/^struct AssertionFail : std::runtime_error {$/;"	s	inherits:std::runtime_error
AssertionFail::AssertionFail	log.h	/^	AssertionFail()  : std::runtime_error("Assertion failed, please check the log file for more information.") {}$/;"	f	struct:AssertionFail	access:public	signature:()
AssignOp	comm_box.hpp	/^struct AssignOp : public std::binary_function< T, T, void >$/;"	s	inherits:std::binary_function
AssignOp::operator ()	comm_box.hpp	/^	void operator () (T & lhs, const T & rhs)$/;"	f	struct:AssignOp	access:public	signature:(T & lhs, const T & rhs)
BITS_HPP	bits.hpp	2;"	d
BUSY	matcher_manager.hpp	/^		BUSY,							\/\/<! do match state$/;"	e	enum:Matcher::MATCHER_STATE
Basebox	comm_box.hpp	/^	Basebox()$/;"	f	class:Basebox	access:protected	signature:()
Basebox	comm_box.hpp	/^class Basebox$/;"	c
Basebox::Basebox	comm_box.hpp	/^	Basebox()$/;"	f	class:Basebox	access:protected	signature:()
Basebox::all_put	comm_box.cpp	/^bool Basebox::all_put() const { return all_put_; }$/;"	f	class:Basebox	signature:() const
Basebox::all_put_	comm_box.hpp	/^	bool all_put_;$/;"	m	class:Basebox	access:protected
Basebox::box_empty	comm_box.hpp	/^	bool box_empty() const { return num_elements() == 0; }$/;"	f	class:Basebox	access:public	signature:() const
Basebox::box_full	comm_box.hpp	/^	bool box_full()  const { return num_elements() == capacity(); }$/;"	f	class:Basebox	access:public	signature:() const
Basebox::c_get	comm_box.hpp	/^	boost::condition c_put, c_get;$/;"	m	class:Basebox	access:protected
Basebox::c_put	comm_box.hpp	/^	boost::condition c_put, c_get;$/;"	m	class:Basebox	access:protected
Basebox::end_condition_not_satisfied	comm_box.hpp	/^	virtual bool end_condition_not_satisfied() const { return !(all_put() && box_empty()); }$/;"	f	class:Basebox	access:public	signature:() const
Basebox::end_condition_satisfied	comm_box.hpp	/^	bool end_condition_satisfied() const { return !end_condition_not_satisfied(); }$/;"	f	class:Basebox	access:public	signature:() const
Basebox::get_condition_not_satisfied	comm_box.hpp	/^	virtual bool get_condition_not_satisfied() const { return box_empty(); }$/;"	f	class:Basebox	access:public	signature:() const
Basebox::lock	comm_box.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:Basebox	access:public
Basebox::monitor	comm_box.hpp	/^	boost::mutex monitor;$/;"	m	class:Basebox	access:protected
Basebox::notify_all_put	comm_box.cpp	/^void Basebox::notify_all_put()$/;"	f	class:Basebox	signature:()
Basebox::notify_wait_get	comm_box.cpp	/^void Basebox::notify_wait_get()$/;"	f	class:Basebox	signature:()
Basebox::notify_wait_put	comm_box.cpp	/^void Basebox::notify_wait_put()$/;"	f	class:Basebox	signature:()
Basebox::put_condition_not_satisfied	comm_box.hpp	/^	virtual bool put_condition_not_satisfied() const { return box_full(); }$/;"	f	class:Basebox	access:public	signature:() const
Basebox::wait_get_condition	comm_box.cpp	/^void Basebox::wait_get_condition()$/;"	f	class:Basebox	signature:()
Basebox::wait_put_condition	comm_box.cpp	/^void Basebox::wait_put_condition()$/;"	f	class:Basebox	signature:()
Basebox::wait_until_box_empty	comm_box.cpp	/^void Basebox::wait_until_box_empty()$/;"	f	class:Basebox	signature:()
BasicPacket	packet.hpp	/^	BasicPacket(int data_len = N - 2)$/;"	f	class:BasicPacket	access:protected	signature:(int data_len = N - 2)
BasicPacket	packet.hpp	/^	BasicPacket(int len, u_char type, u_char idx, const eth::address& src, const eth::address& snk, u_char ctrl)$/;"	f	class:BasicPacket	access:protected	signature:(int len, u_char type, u_char idx, const eth::address& src, const eth::address& snk, u_char ctrl)
BasicPacket	packet.hpp	/^	BasicPacket(int len, u_char type, u_char idx, u_char ctrl)$/;"	f	class:BasicPacket	access:protected	signature:(int len, u_char type, u_char idx, u_char ctrl)
BasicPacket	packet.hpp	/^class BasicPacket$/;"	c
BasicPacket::BasicPacket	packet.hpp	/^	BasicPacket(int data_len = N - 2)$/;"	f	class:BasicPacket	access:protected	signature:(int data_len = N - 2)
BasicPacket::BasicPacket	packet.hpp	/^	BasicPacket(int len, u_char type, u_char idx, const eth::address& src, const eth::address& snk, u_char ctrl)$/;"	f	class:BasicPacket	access:protected	signature:(int len, u_char type, u_char idx, const eth::address& src, const eth::address& snk, u_char ctrl)
BasicPacket::BasicPacket	packet.hpp	/^	BasicPacket(int len, u_char type, u_char idx, u_char ctrl)$/;"	f	class:BasicPacket	access:protected	signature:(int len, u_char type, u_char idx, u_char ctrl)
BasicPacket::bytes_	packet.hpp	/^	u_char bytes_[HEAD_SIZE + N];$/;"	m	class:BasicPacket	access:protected
BasicPacket::check_load_len	packet.hpp	/^	void check_load_len( unsigned n )$/;"	f	class:BasicPacket	access:protected	signature:( unsigned n )
BasicPacket::ctrl	packet.hpp	/^	u_char          ctrl() const   { return bytes_[HEAD_SIZE + 2]; }$/;"	f	class:BasicPacket	access:public	signature:() const
BasicPacket::data_len	packet.hpp	/^	int      data_len() const { return data_len_; }$/;"	f	class:BasicPacket	access:public	signature:() const
BasicPacket::data_len_	packet.hpp	/^	int data_len_;$/;"	m	class:BasicPacket	access:protected
BasicPacket::data_ptr	packet.hpp	/^    u_char * data_ptr()  { return bytes_ + HEAD_SIZE + 2; }$/;"	f	class:BasicPacket	access:public	signature:()
BasicPacket::index	packet.hpp	/^	u_char         index() const   { return bytes_[HEAD_SIZE + 1]; }$/;"	f	class:BasicPacket	access:public	signature:() const
BasicPacket::load_len	packet.hpp	/^	int      load_len() const { return data_len_ + 2; }$/;"	f	class:BasicPacket	access:public	signature:() const
BasicPacket::load_ptr	packet.hpp	/^    u_char * load_ptr()  { return bytes_ + HEAD_SIZE;     }	\/\/ from type$/;"	f	class:BasicPacket	access:public	signature:()
BasicPacket::set_ctrl	packet.hpp	/^	void        set_ctrl(u_char c) { bytes_[HEAD_SIZE + 2] = c; }$/;"	f	class:BasicPacket	access:public	signature:(u_char c)
BasicPacket::set_data_len	packet.hpp	/^	void set_data_len(unsigned l)$/;"	f	class:BasicPacket	access:public	signature:(unsigned l)
BasicPacket::set_index	packet.hpp	/^	void       set_index(u_char c) { bytes_[HEAD_SIZE + 1] = c; }$/;"	f	class:BasicPacket	access:public	signature:(u_char c)
BasicPacket::set_info	packet.hpp	/^	void       	set_info(u_char type, u_char idx) { set_type(type); set_index(idx); }$/;"	f	class:BasicPacket	access:public	signature:(u_char type, u_char idx)
BasicPacket::set_info	packet.hpp	/^	void       	set_info(u_char type, u_char idx, int len) { set_type(type); set_index(idx); set_data_len(len); }$/;"	f	class:BasicPacket	access:public	signature:(u_char type, u_char idx, int len)
BasicPacket::set_load_len	packet.hpp	/^	void set_load_len(unsigned l)  { set_data_len(l - 2); }$/;"	f	class:BasicPacket	access:public	signature:(unsigned l)
BasicPacket::set_snk_mac	packet.hpp	/^	void       set_snk_mac(const eth::address& addr) { memcpy(bytes_    , addr.to_bytes(), 6); }$/;"	f	class:BasicPacket	access:public	signature:(const eth::address& addr)
BasicPacket::set_src_mac	packet.hpp	/^	void       set_src_mac(const eth::address& addr) { memcpy(bytes_ + 6, addr.to_bytes(), 6); }$/;"	f	class:BasicPacket	access:public	signature:(const eth::address& addr)
BasicPacket::set_total_len	packet.hpp	/^	void set_total_len(unsigned l) {$/;"	f	class:BasicPacket	access:public	signature:(unsigned l)
BasicPacket::set_type	packet.hpp	/^	void        set_type(u_char c) { bytes_[HEAD_SIZE + 0] = c; }$/;"	f	class:BasicPacket	access:public	signature:(u_char c)
BasicPacket::snk_addr	packet.hpp	/^	eth::address snk_addr() const { return eth::address(bytes_    , 6); }$/;"	f	class:BasicPacket	access:public	signature:() const
BasicPacket::src_addr	packet.hpp	/^	eth::address src_addr() const { return eth::address(bytes_ + 6, 6); }$/;"	f	class:BasicPacket	access:public	signature:() const
BasicPacket::to_raw_buffer	packet.hpp	/^	boost::asio::mutable_buffers_1 to_raw_buffer() { return boost::asio::buffer(bytes_, total_len()); }$/;"	f	class:BasicPacket	access:public	signature:()
BasicPacket::to_udp_buffer	packet.hpp	/^	boost::asio::mutable_buffers_1 to_udp_buffer() { return boost::asio::buffer(bytes_ + UDP_HEAD_SIZE, total_len() - UDP_HEAD_SIZE ); }$/;"	f	class:BasicPacket	access:public	signature:()
BasicPacket::total_len	packet.hpp	/^	int     total_len() const { return load_len() + HEAD_SIZE; }$/;"	f	class:BasicPacket	access:public	signature:() const
BasicPacket::type	packet.hpp	/^	u_char          type() const   { return bytes_[HEAD_SIZE + 0]; }$/;"	f	class:BasicPacket	access:public	signature:() const
BasicPacket::update_len_bytes	packet.hpp	/^	virtual void update_len_bytes()$/;"	f	class:BasicPacket	access:public	signature:()
BigLibFile	match_stream.hpp	/^	BigLibFile( const vec_str & libs_ )$/;"	f	struct:BigLibFile	access:public	signature:( const vec_str & libs_ )
BigLibFile	match_stream.hpp	/^struct BigLibFile$/;"	s
BigLibFile::BigLibFile	match_stream.hpp	/^	BigLibFile( const vec_str & libs_ )$/;"	f	struct:BigLibFile	access:public	signature:( const vec_str & libs_ )
BigLibFile::buff	match_stream.hpp	/^	int buff;$/;"	m	struct:BigLibFile	access:private
BigLibFile::curr_file	match_stream.hpp	/^	std::ifstream * curr_file;$/;"	m	struct:BigLibFile	access:private
BigLibFile::curr_stream	match_stream.hpp	/^	std::ifstream & curr_stream()$/;"	f	struct:BigLibFile	access:public	signature:()
BigLibFile::free_curr_file	match_stream.hpp	/^	void free_curr_file()$/;"	f	struct:BigLibFile	access:public	signature:()
BigLibFile::lib_id_to_read	match_stream.hpp	/^	std::size_t lib_id_to_read;$/;"	m	struct:BigLibFile	access:private
BigLibFile::libs	match_stream.hpp	/^	vec_str libs;$/;"	m	struct:BigLibFile	access:private
BigLibFile::reach_file_end	match_stream.hpp	/^	bool reach_file_end;$/;"	m	struct:BigLibFile	access:private
BigLibFile::read_word	match_stream.hpp	/^	bool read_word( int & word )$/;"	f	struct:BigLibFile	access:public	signature:( int & word )
BigLibFile::vec_str	match_stream.hpp	/^	typedef std::vector< std::string > vec_str;$/;"	t	struct:BigLibFile	access:public
BigLibFile::~BigLibFile	match_stream.hpp	/^	~BigLibFile()$/;"	f	struct:BigLibFile	access:public	signature:()
BitFeature	bit_feature.h	/^	explicit BitFeature(int n) : nwords_(n\/32) {$/;"	f	class:BitFeature	access:public	signature:(int n)
BitFeature	bit_feature.h	/^class BitFeature {$/;"	c
BitFeature::BitFeature	bit_feature.h	/^	explicit BitFeature(int n) : nwords_(n\/32) {$/;"	f	class:BitFeature	access:public	signature:(int n)
BitFeature::Byte	bit_feature.h	/^	typedef unsigned char Byte;			\/\/ 8 bit$/;"	t	class:BitFeature	access:public
BitFeature::DWord	bit_feature.h	/^	typedef unsigned long long DWord;	\/\/ 64 bit$/;"	t	class:BitFeature	access:public
BitFeature::Word	bit_feature.h	/^	typedef unsigned int  Word;			\/\/ 32 bit$/;"	t	class:BitFeature	access:public
BitFeature::__anon5::bytes	bit_feature.h	/^		Byte   bytes[MAX_FEATURE_BITS\/ 8];$/;"	m	union:BitFeature::__anon5	access:public
BitFeature::__anon5::dwords	bit_feature.h	/^		DWord dwords[MAX_FEATURE_BITS\/64];$/;"	m	union:BitFeature::__anon5	access:public
BitFeature::__anon5::words	bit_feature.h	/^		Word   words[MAX_FEATURE_BITS\/32];$/;"	m	union:BitFeature::__anon5	access:public
BitFeature::clear	bit_feature.h	/^	void clear() {$/;"	f	class:BitFeature	access:public	signature:()
BitFeature::nbytes	bit_feature.h	/^	int nbytes() const { return nwords_ * 4; }$/;"	f	class:BitFeature	access:public	signature:() const
BitFeature::nwords	bit_feature.h	/^	int nwords() const { return nwords_; }$/;"	f	class:BitFeature	access:public	signature:() const
BitFeature::nwords_	bit_feature.h	/^	int nwords_;$/;"	m	class:BitFeature	access:private
BitFeature_H	bit_feature.h	2;"	d
BorderAdj	fasthessian.h	/^	static const int TLBorder = 5, RBBorder = 4, BorderAdj = 2;		\/\/ border & adjustment for layer 3$/;"	m	class:Octave	access:private
BoxImage	comm_box.hpp	/^	BoxImage(IplImage * img = 0, int frm = 0) : image(img), frame(frm) {}$/;"	f	struct:BoxImage	access:public	signature:(IplImage * img = 0, int frm = 0)
BoxImage	comm_box.hpp	/^struct BoxImage$/;"	s
BoxImage::BoxImage	comm_box.hpp	/^	BoxImage(IplImage * img = 0, int frm = 0) : image(img), frame(frm) {}$/;"	f	struct:BoxImage	access:public	signature:(IplImage * img = 0, int frm = 0)
BoxImage::frame	comm_box.hpp	/^	int        frame;$/;"	m	struct:BoxImage	access:public
BoxImage::image	comm_box.hpp	/^	IplImage * image;$/;"	m	struct:BoxImage	access:public
BoxIntegral	integral.h	/^	int BoxIntegral(int row, int col, int rows, int cols) const {$/;"	f	struct:IntImage	access:public	signature:(int row, int col, int rows, int cols) const
Byte	bit_feature.h	/^	typedef unsigned char Byte;			\/\/ 8 bit$/;"	t	class:BitFeature	access:public
CFA_UDP_HEAD_SIZE	packet.hpp	/^	CFA_UDP_HEAD_SIZE = UDP_HEAD_SIZE + 4,$/;"	e	enum:__anon6
CFA_UDP_MAX_DATA_LEN	packet.hpp	/^	CFA_UDP_MAX_DATA_LEN = CFA_UDP_MAX_LOAD_LEN - 2,	\/\/ 1466$/;"	e	enum:__anon6
CFA_UDP_MAX_LOAD_LEN	packet.hpp	/^	CFA_UDP_MAX_LOAD_LEN = ETH_MAX_LEN - CFA_UDP_HEAD_SIZE,	\/\/ 1468$/;"	e	enum:__anon6
CFA_UDP_MIN_DATA_LEN	packet.hpp	/^	CFA_UDP_MIN_DATA_LEN = CFA_UDP_MIN_LOAD_LEN - 2,	\/\/ 12$/;"	e	enum:__anon6
CFA_UDP_MIN_LOAD_LEN	packet.hpp	/^	CFA_UDP_MIN_LOAD_LEN = ETH_MIN_LEN - CFA_UDP_HEAD_SIZE,	\/\/ 14$/;"	e	enum:__anon6
COLOURS	utils.cpp	/^static const CvScalar COLOURS [] = {cvScalar(255,0,0), cvScalar(0,255,0), $/;"	v	file:
COMM_ARG_HPP	comm_arg.hpp	2;"	d
COMM_BOX_HPP	comm_box.hpp	8;"	d
COMM_PARA_HPP	comm_para.hpp	2;"	d
COMM_STATE	matcher_manager.hpp	/^	enum COMM_STATE {$/;"	g	class:Matcher	access:public
COMM_WINDOW	comm_window.hpp	8;"	d
CONNECTION_BUILD_SERVICE_HPP	connection_build_service.hpp	2;"	d
CONN_BUILD	comm_para.hpp	/^	const u_char      CONN_BUILD          = 0x70;$/;"	m	namespace:__anon2
CTRL_PAUSE	comm_para.hpp	/^	const u_char      CTRL_PAUSE          = 0xFF;$/;"	m	namespace:__anon2
CTRL_RECOVER	comm_para.hpp	/^	const u_char      CTRL_RECOVER        = 0x00;$/;"	m	namespace:__anon2
CUTED_SIZE	comm_box.hpp	/^	enum { FILTER_NUM = 8, CUT_THRESHOLD = 88, CUTED_SIZE = 45 };$/;"	e	enum:MatchImageBox::__anon3
CUT_THRESHOLD	comm_box.hpp	/^	enum { FILTER_NUM = 8, CUT_THRESHOLD = 88, CUTED_SIZE = 45 };$/;"	e	enum:MatchImageBox::__anon3
CfaUdpPacket	packet.hpp	/^	CfaUdpPacket (int len = CFA_UDP_MAX_DATA_LEN)$/;"	f	class:CfaUdpPacket	access:public	signature:(int len = CFA_UDP_MAX_DATA_LEN)
CfaUdpPacket	packet.hpp	/^	CfaUdpPacket (int len, u_char type, u_char idx)$/;"	f	class:CfaUdpPacket	access:public	signature:(int len, u_char type, u_char idx)
CfaUdpPacket	packet.hpp	/^class CfaUdpPacket : public cfa_udp_packet_base__$/;"	c	inherits:cfa_udp_packet_base__
CfaUdpPacket::CfaUdpPacket	packet.hpp	/^	CfaUdpPacket (int len = CFA_UDP_MAX_DATA_LEN)$/;"	f	class:CfaUdpPacket	access:public	signature:(int len = CFA_UDP_MAX_DATA_LEN)
CfaUdpPacket::CfaUdpPacket	packet.hpp	/^	CfaUdpPacket (int len, u_char type, u_char idx)$/;"	f	class:CfaUdpPacket	access:public	signature:(int len, u_char type, u_char idx)
CfaUdpPacket::from_point	packet.hpp	/^	const udp::endpoint from_point() { return src_endpoint_; }$/;"	f	class:CfaUdpPacket	access:public	signature:()
CfaUdpPacket::make_shared_packet	packet.hpp	/^	static PacketPtr make_shared_packet(const Packet & pkt)$/;"	f	class:CfaUdpPacket	access:public	signature:(const Packet & pkt)
CfaUdpPacket::set_from_point	packet.hpp	/^	void set_from_point(const udp::endpoint & e)$/;"	f	class:CfaUdpPacket	access:public	signature:(const udp::endpoint & e)
CfaUdpPacket::src_endpoint_	packet.hpp	/^	udp::endpoint src_endpoint_;$/;"	m	class:CfaUdpPacket	access:private
CfaUdpPacket::update_len_bytes	packet.hpp	/^	virtual void update_len_bytes()$/;"	f	class:CfaUdpPacket	access:public	signature:()
CfaUdpResponPacket	packet.hpp	/^	CfaUdpResponPacket()$/;"	f	class:CfaUdpResponPacket	access:public	signature:()
CfaUdpResponPacket	packet.hpp	/^	CfaUdpResponPacket(u_char type, u_char idx, u_char ctrl = 0x00)$/;"	f	class:CfaUdpResponPacket	access:public	signature:(u_char type, u_char idx, u_char ctrl = 0x00)
CfaUdpResponPacket	packet.hpp	/^class CfaUdpResponPacket : public cfa_udp_response_packet_base__$/;"	c	inherits:cfa_udp_response_packet_base__
CfaUdpResponPacket::CfaUdpResponPacket	packet.hpp	/^	CfaUdpResponPacket()$/;"	f	class:CfaUdpResponPacket	access:public	signature:()
CfaUdpResponPacket::CfaUdpResponPacket	packet.hpp	/^	CfaUdpResponPacket(u_char type, u_char idx, u_char ctrl = 0x00)$/;"	f	class:CfaUdpResponPacket	access:public	signature:(u_char type, u_char idx, u_char ctrl = 0x00)
CfaUdpResponPacket::update_len_bytes	packet.hpp	/^	virtual void update_len_bytes()$/;"	f	class:CfaUdpResponPacket	access:public	signature:()
CommArg	comm_arg.hpp	/^	CommArg()$/;"	f	struct:CommArg	access:private	signature:()
CommArg	comm_arg.hpp	/^struct CommArg : boost::noncopyable$/;"	s	inherits:boost::noncopyable
CommArg::CommArg	comm_arg.hpp	/^	CommArg()$/;"	f	struct:CommArg	access:private	signature:()
CommArg::bind_ip	comm_arg.hpp	/^	std::string    bind_ip;$/;"	m	struct:CommArg	access:public
CommArg::client_addrs	comm_arg.hpp	/^	std::vector<std::string> client_addrs;$/;"	m	struct:CommArg	access:public
CommArg::comm_arg	comm_arg.hpp	/^	static CommArg & comm_arg()$/;"	f	struct:CommArg	access:public	signature:()
CommArg::conn_build_wait_time	comm_arg.hpp	/^	int conn_build_wait_time;$/;"	m	struct:CommArg	access:public
CommArg::consider_extract_mac	comm_arg.hpp	/^	int consider_extract_mac;$/;"	m	struct:CommArg	access:public
CommArg::device	comm_arg.hpp	/^	std::string    device;$/;"	m	struct:CommArg	access:public
CommArg::do_send_lib	comm_arg.hpp	/^	int do_send_lib;$/;"	m	struct:CommArg	access:public
CommArg::do_surf	comm_arg.hpp	/^	int do_surf;$/;"	m	struct:CommArg	access:public
CommArg::dump_matched_lib	comm_arg.hpp	/^	int dump_matched_lib;$/;"	m	struct:CommArg	access:public
CommArg::extract_addr	comm_arg.hpp	/^	std::string    extract_addr;$/;"	m	struct:CommArg	access:public
CommArg::fpga_port	comm_arg.hpp	/^	unsigned short fpga_port;$/;"	m	struct:CommArg	access:public
CommArg::image_libs	comm_arg.hpp	/^	std::vector<std::string> image_libs;$/;"	m	struct:CommArg	access:public
CommArg::image_pause	comm_arg.hpp	/^	int image_pause;$/;"	m	struct:CommArg	access:public
CommArg::image_ratio	comm_arg.hpp	/^	int image_ratio;$/;"	m	struct:CommArg	access:public
CommArg::images	comm_arg.hpp	/^	std::vector<std::string> images;$/;"	m	struct:CommArg	access:public
CommArg::libs	comm_arg.hpp	/^	std::vector<std::string> libs;$/;"	m	struct:CommArg	access:public
CommArg::log_file	comm_arg.hpp	/^	std::string    log_file;$/;"	m	struct:CommArg	access:public
CommArg::manually_broadcast_points	comm_arg.hpp	/^	int manually_broadcast_points;$/;"	m	struct:CommArg	access:public
CommArg::match_timeout	comm_arg.hpp	/^	int match_timeout;$/;"	m	struct:CommArg	access:public
CommArg::match_width	comm_arg.hpp	/^	int match_width;$/;"	m	struct:CommArg	access:public
CommArg::max_conn_times_allowed	comm_arg.hpp	/^	int max_conn_times_allowed;$/;"	m	struct:CommArg	access:public
CommArg::num_clients	comm_arg.hpp	/^	int num_clients;$/;"	m	struct:CommArg	access:public
CommArg::only_send_image	comm_arg.hpp	/^	int only_send_image;$/;"	m	struct:CommArg	access:public
CommArg::only_send_lib	comm_arg.hpp	/^	int only_send_lib;$/;"	m	struct:CommArg	access:public
CommArg::only_transform_lib	comm_arg.hpp	/^	int only_transform_lib;$/;"	m	struct:CommArg	access:public
CommArg::out_file	comm_arg.hpp	/^	std::string    out_file;$/;"	m	struct:CommArg	access:public
CommArg::parse_host_file	comm_arg.cpp	/^bool CommArg::parse_host_file( const char * file )$/;"	f	class:CommArg	signature:( const char * file )
CommArg::parse_info_file	comm_arg.cpp	/^bool CommArg::parse_info_file( const char * file )$/;"	f	class:CommArg	signature:( const char * file )
CommArg::random_loop	comm_arg.hpp	/^	int random_loop;$/;"	m	struct:CommArg	access:public
CommArg::send_port	comm_arg.hpp	/^	unsigned short send_port;$/;"	m	struct:CommArg	access:public
CommArg::server_port	comm_arg.hpp	/^	unsigned short server_port;$/;"	m	struct:CommArg	access:public
CommArg::sleep_time	comm_arg.hpp	/^  	int sleep_time;$/;"	m	struct:CommArg	access:public
CommArg::video_beg	comm_arg.hpp	/^	int video_beg;$/;"	m	struct:CommArg	access:public
CommArg::video_end	comm_arg.hpp	/^	int video_end;$/;"	m	struct:CommArg	access:public
CommArg::video_pause	comm_arg.hpp	/^	int video_pause;$/;"	m	struct:CommArg	access:public
CommArg::video_ratio	comm_arg.hpp	/^	int video_ratio;$/;"	m	struct:CommArg	access:public
CommArg::videos	comm_arg.hpp	/^	std::vector<std::string> videos;$/;"	m	struct:CommArg	access:public
CommBox	comm_box.hpp	/^	CommBox()$/;"	f	class:CommBox	access:public	signature:()
CommBox	comm_box.hpp	/^class CommBox : public Basebox$/;"	c	inherits:Basebox
CommBox::CommBox	comm_box.hpp	/^	CommBox()$/;"	f	class:CommBox	access:public	signature:()
CommBox::capacity	comm_box.hpp	/^	virtual std::size_t capacity()     const { return 1; }$/;"	f	class:CommBox	access:public	signature:() const
CommBox::data	comm_box.hpp	/^	T data;$/;"	m	class:CommBox	access:protected
CommBox::data_valid	comm_box.hpp	/^	bool data_valid;$/;"	m	class:CommBox	access:protected
CommBox::get	comm_box.hpp	/^	bool get(T & t)$/;"	f	class:CommBox	access:public	signature:(T & t)
CommBox::num_elements	comm_box.hpp	/^	virtual std::size_t num_elements() const { return data_valid ? 1 : 0; }$/;"	f	class:CommBox	access:public	signature:() const
CommBox::put	comm_box.hpp	/^	void put(const T & t)$/;"	f	class:CommBox	access:public	signature:(const T & t)
ConnectionBuilder	match_stream.hpp	/^class ConnectionBuilder : public StreamNode$/;"	c	inherits:StreamNode
ConnectionBuilder::built_	match_stream.hpp	/^	bool built_;$/;"	m	class:ConnectionBuilder	access:private
ConnectionBuilder::c_wait_	match_stream.hpp	/^	boost::condition c_wait_;$/;"	m	class:ConnectionBuilder	access:private
ConnectionBuilder::conn_task_	match_stream.hpp	/^	static std::map<endpoint, ConnectionBuilder *> conn_task_;$/;"	m	class:ConnectionBuilder	access:private
ConnectionBuilder::dest_	match_stream.hpp	/^	const endpoint dest_;$/;"	m	class:ConnectionBuilder	access:private
ConnectionBuilder::get_build_task	match_stream.hpp	/^	static ConnectionBuilder * get_build_task(const endpoint & e )$/;"	f	class:ConnectionBuilder	access:public	signature:(const endpoint & e )
ConnectionBuilder::lock	match_stream.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:ConnectionBuilder	access:public
ConnectionBuilder::monitor_	match_stream.hpp	/^	boost::mutex monitor_;$/;"	m	class:ConnectionBuilder	access:private
ConnectionBuilder::num_timeout_	match_stream.hpp	/^	int num_timeout_;$/;"	m	class:ConnectionBuilder	access:private
ConnectionBuilder::pkt_	match_stream.hpp	/^	Packet pkt_;$/;"	m	class:ConnectionBuilder	access:private
ConnectionBuilderService	connection_build_service.hpp	/^class ConnectionBuilderService$/;"	c
ConnectionBuilderService::c_wait_	connection_build_service.hpp	/^	boost::condition c_wait_;$/;"	m	class:ConnectionBuilderService	access:private
ConnectionBuilderService::connect_matcher	connection_build_service.cpp	/^void ConnectionBuilderService::connect_matcher( MatcherPtr m )$/;"	f	class:ConnectionBuilderService	signature:( MatcherPtr m )
ConnectionBuilderService::end	connection_build_service.cpp	/^bool ConnectionBuilderService::end()$/;"	f	class:ConnectionBuilderService	signature:()
ConnectionBuilderService::instance	connection_build_service.hpp	/^	static ConnectionBuilderService & instance()$/;"	f	class:ConnectionBuilderService	access:public	signature:()
ConnectionBuilderService::lock	connection_build_service.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:ConnectionBuilderService	access:public
ConnectionBuilderService::monitor_	connection_build_service.hpp	/^	boost::mutex monitor_;$/;"	m	class:ConnectionBuilderService	access:private
ConnectionBuilderService::notify_wait_matcher	connection_build_service.cpp	/^void ConnectionBuilderService::notify_wait_matcher()$/;"	f	class:ConnectionBuilderService	signature:()
ConnectionBuilderService::run	connection_build_service.cpp	/^void ConnectionBuilderService::run()$/;"	f	class:ConnectionBuilderService	signature:()
DEBUG	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
DWord	bit_feature.h	/^	typedef unsigned long long DWord;	\/\/ 64 bit$/;"	t	class:BitFeature	access:public
DYN_CALL0	match_utils.h	32;"	d
DYN_CALL1	match_utils.h	39;"	d
DYN_CALL2	match_utils.h	46;"	d
EDist	ipoint.h	/^struct EDist {		\/\/ Euclidean distance$/;"	s
EDist::operator ()	ipoint.h	/^	float operator () (const Ipoint& lhs, const I& rhs) const {$/;"	f	struct:EDist	access:public	signature:(const Ipoint& lhs, const I& rhs) const
EDist::threshold	ipoint.h	/^	float threshold() const { return 0.42; }$/;"	f	struct:EDist	access:public	signature:() const
ENDWORD	surflib.cpp	14;"	d	file:
END_KEY	match_analyser.cpp	/^static const unsigned int END_KEY = 0xFFFFFFFF;$/;"	v	file:
ERR	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
ETH_MAX_LEN	packet.hpp	/^	ETH_MAX_LEN  = 1514,$/;"	e	enum:__anon6
ETH_MIN_LEN	packet.hpp	/^	ETH_MIN_LEN  = 60,$/;"	e	enum:__anon6
EXCEPTION_HANDLE	main.cpp	6;"	d	file:
EXTRACT_END	comm_para.hpp	/^	const u_char      EXTRACT_END         = 0x2C;$/;"	m	namespace:__anon2
EXTRACT_RECVING	comm_para.hpp	/^	const u_char      EXTRACT_RECVING     = 0x0C;$/;"	m	namespace:__anon2
EnumStringMap	fdutils.h	/^	explicit EnumStringMap(const SA& st, E default_value = (E)0)$/;"	f	class:EnumStringMap	access:public	signature:(const SA& st, E default_value = (E)0)
EnumStringMap	fdutils.h	/^class EnumStringMap {$/;"	c
EnumStringMap::EnumStringMap	fdutils.h	/^	explicit EnumStringMap(const SA& st, E default_value = (E)0)$/;"	f	class:EnumStringMap	access:public	signature:(const SA& st, E default_value = (E)0)
EnumStringMap::_def	fdutils.h	/^	const E   _def;$/;"	m	class:EnumStringMap	access:private
EnumStringMap::_size	fdutils.h	/^	const int _size;$/;"	m	class:EnumStringMap	access:private
EnumStringMap::_str_table	fdutils.h	/^	const char * const * _str_table;$/;"	m	class:EnumStringMap	access:private
EnumStringMap::getEnum	fdutils.h	/^	E getEnum(const string& str) const {$/;"	f	class:EnumStringMap	access:public	signature:(const string& str) const
EnumStringMap::getString	fdutils.h	/^	const char* getString(E val) const {$/;"	f	class:EnumStringMap	access:public	signature:(E val) const
EnumStringMap::readEnum	fdutils.h	/^	E readEnum(std::istream& s) const {$/;"	f	class:EnumStringMap	access:public	signature:(std::istream& s) const
EnumStringMap::writeEnum	fdutils.h	/^	std::ostream& writeEnum(std::ostream& s, E val) { return s << getString(val); }$/;"	f	class:EnumStringMap	access:public	signature:(std::ostream& s, E val)
FAIL_CONNECT	matcher_manager.hpp	/^		FAIL_CONNECT,					\/\/<! fail connect$/;"	e	enum:Matcher::MATCHER_STATE
FASTHESSIAN_H	fasthessian.h	13;"	d
FDU_DEBUG	log.h	90;"	d
FDU_LOG	log.h	78;"	d
FDU_LOGGING_H_	log.h	2;"	d
FDU_LOGV	log.h	79;"	d
FILTER_NUM	comm_box.hpp	/^	enum { FILTER_NUM = 8, CUT_THRESHOLD = 88, CUTED_SIZE = 45 };$/;"	e	enum:MatchImageBox::__anon3
FUDANFPGA_UTILS_H_	fdutils.h	2;"	d
GEN_MODE	match_stream.hpp	/^	enum GEN_MODE { SEQUENCE, RANDOM_LOOP };$/;"	g	class:GrayImageGenerator	access:public
Gaussian	surf.cpp	/^	Gaussian(float sig) {$/;"	f	class:__anon1::Gaussian	access:public	signature:(float sig)
Gaussian	surf.cpp	/^class Gaussian {$/;"	c	namespace:__anon1	file:
GaussianElim	fasthessian.cpp	/^static bool GaussianElim(Matrix34& am, float& x0, float& x1, float& x2) {$/;"	f	file:	signature:(Matrix34& am, float& x0, float& x1, float& x2)
GrayImage	integral.h	/^	GrayImage() {}$/;"	f	struct:GrayImage	access:public	signature:()
GrayImage	integral.h	/^	GrayImage(const IplImage* img) { init(img); }$/;"	f	struct:GrayImage	access:public	signature:(const IplImage* img)
GrayImage	integral.h	/^	GrayImage(const char* file_name) { load(file_name); }$/;"	f	struct:GrayImage	access:public	signature:(const char* file_name)
GrayImage	integral.h	/^struct GrayImage : Image<unsigned char> {$/;"	s	inherits:Image
GrayImage::GrayImage	integral.h	/^	GrayImage() {}$/;"	f	struct:GrayImage	access:public	signature:()
GrayImage::GrayImage	integral.h	/^	GrayImage(const IplImage* img) { init(img); }$/;"	f	struct:GrayImage	access:public	signature:(const IplImage* img)
GrayImage::GrayImage	integral.h	/^	GrayImage(const char* file_name) { load(file_name); }$/;"	f	struct:GrayImage	access:public	signature:(const char* file_name)
GrayImage::init	integral.cpp	/^void GrayImage::init(const IplImage* img) {$/;"	f	class:GrayImage	signature:(const IplImage* img)
GrayImage::load	integral.cpp	/^void GrayImage::load(const char* file_name) {$/;"	f	class:GrayImage	signature:(const char* file_name)
GrayImageGenerator	match_stream.cpp	/^GrayImageGenerator::GrayImageGenerator(GrayImageGenerator::GEN_MODE mode)$/;"	f	class:GrayImageGenerator	signature:(GrayImageGenerator::GEN_MODE mode)
GrayImageGenerator	match_stream.hpp	/^class GrayImageGenerator : public StreamNode$/;"	c	inherits:StreamNode
GrayImageGenerator::GEN_MODE	match_stream.hpp	/^	enum GEN_MODE { SEQUENCE, RANDOM_LOOP };$/;"	g	class:GrayImageGenerator	access:public
GrayImageGenerator::GrayImageGenerator	match_stream.cpp	/^GrayImageGenerator::GrayImageGenerator(GrayImageGenerator::GEN_MODE mode)$/;"	f	class:GrayImageGenerator	signature:(GrayImageGenerator::GEN_MODE mode)
GrayImageGenerator::RANDOM_LOOP	match_stream.hpp	/^	enum GEN_MODE { SEQUENCE, RANDOM_LOOP };$/;"	e	enum:GrayImageGenerator::GEN_MODE
GrayImageGenerator::SEQUENCE	match_stream.hpp	/^	enum GEN_MODE { SEQUENCE, RANDOM_LOOP };$/;"	e	enum:GrayImageGenerator::GEN_MODE
GrayImageGenerator::do_end_task	match_stream.cpp	/^void GrayImageGenerator::do_end_task()$/;"	f	class:GrayImageGenerator	signature:()
GrayImageGenerator::do_run_task	match_stream.cpp	/^void GrayImageGenerator::do_run_task()$/;"	f	class:GrayImageGenerator	signature:()
GrayImageGenerator::gen_image_frame	match_stream.cpp	/^void GrayImageGenerator::gen_image_frame(const string & image, unsigned idx)$/;"	f	class:GrayImageGenerator	signature:(const string & image, unsigned idx)
GrayImageGenerator::gen_video_frame	match_stream.cpp	/^void GrayImageGenerator::gen_video_frame(const string & video, unsigned idx)$/;"	f	class:GrayImageGenerator	signature:(const string & video, unsigned idx)
GrayImageGenerator::image_generate_thread	match_stream.cpp	/^void GrayImageGenerator::image_generate_thread(GrayImageGenerator::GEN_MODE mode)$/;"	f	class:GrayImageGenerator	signature:(GrayImageGenerator::GEN_MODE mode)
GrayImageGenerator::image_pause	match_stream.hpp	/^	int image_pause;$/;"	m	class:GrayImageGenerator	access:private
GrayImageGenerator::make_frame	match_stream.hpp	/^	static unsigned make_frame(unsigned frame_idx)$/;"	f	class:GrayImageGenerator	access:public	signature:(unsigned frame_idx)
GrayImageGenerator::make_frame	match_stream.hpp	/^	static unsigned make_frame(unsigned video_idx, unsigned frame_idx)$/;"	f	class:GrayImageGenerator	access:public	signature:(unsigned video_idx, unsigned frame_idx)
GrayImageGenerator::mode_	match_stream.hpp	/^	GEN_MODE mode_;$/;"	m	class:GrayImageGenerator	access:private
GrayImageGenerator::set_pause	match_stream.hpp	/^	void set_pause(int img, int vdo)$/;"	f	class:GrayImageGenerator	access:public	signature:(int img, int vdo)
GrayImageGenerator::video_pause	match_stream.hpp	/^	int video_pause;$/;"	m	class:GrayImageGenerator	access:private
GrayImageLoader	match_stream.hpp	/^	GrayImageLoader()$/;"	f	class:GrayImageLoader	access:public	signature:()
GrayImageLoader	match_stream.hpp	/^class GrayImageLoader : public StreamNode$/;"	c	inherits:StreamNode
GrayImageLoader::GrayImageLoader	match_stream.hpp	/^	GrayImageLoader()$/;"	f	class:GrayImageLoader	access:public	signature:()
GrayImageLoader::do_end_task	match_stream.cpp	/^void GrayImageLoader::do_end_task()$/;"	f	class:GrayImageLoader	signature:()
GrayImageLoader::do_run_task	match_stream.cpp	/^void GrayImageLoader::do_run_task()$/;"	f	class:GrayImageLoader	signature:()
GrayImageLoader::handle_image	match_stream.cpp	/^void GrayImageLoader::handle_image(IplImage * img, int frame_idx)$/;"	f	class:GrayImageLoader	signature:(IplImage * img, int frame_idx)
GrayImageLoader::image_load_thread	match_stream.cpp	/^void GrayImageLoader::image_load_thread()$/;"	f	class:GrayImageLoader	signature:()
GrayImageLoader::num_skip_	match_stream.hpp	/^	int num_skip_;			\/\/ num image skipped$/;"	m	class:GrayImageLoader	access:private
GrayImageSender	match_stream.hpp	/^	GrayImageSender ()$/;"	f	class:GrayImageSender	access:public	signature:()
GrayImageSender	match_stream.hpp	/^class GrayImageSender : public StreamNode$/;"	c	inherits:StreamNode
GrayImageSender::GrayImageSender	match_stream.hpp	/^	GrayImageSender ()$/;"	f	class:GrayImageSender	access:public	signature:()
GrayImageSender::cnt	match_stream.hpp	/^	std::size_t cnt;$/;"	m	class:GrayImageSender	access:private
GrayImageSender::do_end_task	match_stream.cpp	/^void GrayImageSender::do_end_task()$/;"	f	class:GrayImageSender	signature:()
GrayImageSender::do_run_task	match_stream.cpp	/^void GrayImageSender::do_run_task()$/;"	f	class:GrayImageSender	signature:()
GrayImageSender::gray_image_send_thread	match_stream.cpp	/^void GrayImageSender::gray_image_send_thread(const endpoint & dest)$/;"	f	class:GrayImageSender	signature:(const endpoint & dest)
GrayImageWindow	comm_window.hpp	/^	explicit GrayImageWindow(int timeout = 20)$/;"	f	class:GrayImageWindow	access:public	signature:(int timeout = 20)
GrayImageWindow	comm_window.hpp	/^class GrayImageWindow : public StepWindow$/;"	c	inherits:StepWindow
GrayImageWindow::GrayImageWindow	comm_window.hpp	/^	explicit GrayImageWindow(int timeout = 20)$/;"	f	class:GrayImageWindow	access:public	signature:(int timeout = 20)
IMG_ALL_END	comm_para.hpp	/^	const u_char      IMG_ALL_END         = 0x66;$/;"	m	namespace:__anon2
IMG_END	comm_para.hpp	/^	const u_char      IMG_END             = 0x26;$/;"	m	namespace:__anon2
IMG_SENDING	comm_para.hpp	/^	const u_char      IMG_SENDING         = 0x06;$/;"	m	namespace:__anon2
IMG_START	comm_para.hpp	/^	const u_char      IMG_START           = 0x16;$/;"	m	namespace:__anon2
INFO	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
INTEGRAL_H	integral.h	13;"	d
INTERVALS	fasthessian.h	/^static const int INTERVALS = 4;$/;"	v
INTSCALE	integral.h	/^static const int INTSCALE = 256;$/;"	v
INVALID_COMM_STATE	matcher_manager.hpp	/^		INVALID_COMM_STATE = -1,		\/\/<! invalid $/;"	e	enum:Matcher::COMM_STATE
INVALID_MATCHER_STATE	matcher_manager.hpp	/^		INVALID_MATCHER_STATE = -2,		\/\/<! invalid state$/;"	e	enum:Matcher::MATCHER_STATE
IPOINT_H	ipoint.h	13;"	d
Image	integral.h	/^	Image() : width_(0), height_(0), data_(0) {}$/;"	f	class:Image	access:public	signature:()
Image	integral.h	/^	Image(int w, int h) : width_(w), height_(h), data_(new T[w*h]) {}$/;"	f	class:Image	access:public	signature:(int w, int h)
Image	integral.h	/^template<typename T> class Image {$/;"	c
Image::Image	integral.h	/^	Image() : width_(0), height_(0), data_(0) {}$/;"	f	class:Image	access:public	signature:()
Image::Image	integral.h	/^	Image(int w, int h) : width_(w), height_(h), data_(new T[w*h]) {}$/;"	f	class:Image	access:public	signature:(int w, int h)
Image::data_	integral.h	/^	T*  data_;              \/\/ Pointer to image data$/;"	m	class:Image	access:protected
Image::height	integral.h	/^	int height() const { return height_; }$/;"	f	class:Image	access:public	signature:() const
Image::height_	integral.h	/^	int height_;            \/\/ Image height in pixels$/;"	m	class:Image	access:private
Image::operator !	integral.h	/^	bool operator!() const { return size() == 0;  }		\/\/ test image validation$/;"	f	class:Image	access:public	signature:() const
Image::operator ()	integral.h	/^	T  operator()(int row, int col) const { return pixel(row, col); }	\/\/ get the pixel$/;"	f	class:Image	access:public	signature:(int row, int col) const
Image::operator ()	integral.h	/^	T& operator()(int row, int col)       { return pixel(row, col); }	\/\/ get\/set the pixel$/;"	f	class:Image	access:public	signature:(int row, int col)
Image::pixel	integral.h	/^	T  pixel(int row, int col) const { return data_[row * width_ + col]; }	\/\/ get the pixel$/;"	f	class:Image	access:protected	signature:(int row, int col) const
Image::pixel	integral.h	/^	T& pixel(int row, int col)       { return data_[row * width_ + col]; }	\/\/ get\/set the pixel$/;"	f	class:Image	access:protected	signature:(int row, int col)
Image::reset	integral.h	/^	void reset(int w, int h) { width_ = w; height_ = h; delete[] data_; data_ = new T[w*h]; }$/;"	f	class:Image	access:public	signature:(int w, int h)
Image::size	integral.h	/^	int size()   const { return width_ * height_; }$/;"	f	class:Image	access:public	signature:() const
Image::width	integral.h	/^	int width()  const { return width_;  }$/;"	f	class:Image	access:public	signature:() const
Image::width_	integral.h	/^	int width_;             \/\/ Image width in pixels$/;"	m	class:Image	access:private
Image::~Image	integral.h	/^	~Image() { delete[] data_; }$/;"	f	class:Image	access:public	signature:()
ImageGenBox	comm_box.cpp	/^ImageGenBox::ImageGenBox(Server * s)$/;"	f	class:ImageGenBox	signature:(Server * s)
ImageGenBox	comm_box.hpp	/^class ImageGenBox : public image_gen_box_base__$/;"	c	inherits:image_gen_box_base__
ImageGenBox::ImageGenBox	comm_box.cpp	/^ImageGenBox::ImageGenBox(Server * s)$/;"	f	class:ImageGenBox	signature:(Server * s)
ImageGenBox::get_condition_not_satisfied	comm_box.cpp	/^bool ImageGenBox::get_condition_not_satisfied() const$/;"	f	class:ImageGenBox	signature:() const
ImageGenBox::server_	comm_box.hpp	/^	Server * server_;$/;"	m	class:ImageGenBox	access:private
ImageMatchAnalyser	match_analyser.hpp	/^	ImageMatchAnalyser ( frame_type frame, const std::string & path )$/;"	f	class:ImageMatchAnalyser	access:public	signature:( frame_type frame, const std::string & path )
ImageMatchAnalyser	match_analyser.hpp	/^class ImageMatchAnalyser$/;"	c
ImageMatchAnalyser::ImageMatchAnalyser	match_analyser.hpp	/^	ImageMatchAnalyser ( frame_type frame, const std::string & path )$/;"	f	class:ImageMatchAnalyser	access:public	signature:( frame_type frame, const std::string & path )
ImageMatchAnalyser::add_match	match_analyser.cpp	/^void ImageMatchAnalyser::add_match( frame_type frame )$/;"	f	class:ImageMatchAnalyser	signature:( frame_type frame )
ImageMatchAnalyser::frame_	match_analyser.hpp	/^	const frame_type frame_;$/;"	m	class:ImageMatchAnalyser	access:private
ImageMatchAnalyser::frames_type	match_analyser.hpp	/^	typedef std::vector< frame_type >                    frames_type;$/;"	t	class:ImageMatchAnalyser	access:private
ImageMatchAnalyser::matched_frames_	match_analyser.hpp	/^	frames_type matched_frames_;$/;"	m	class:ImageMatchAnalyser	access:private
ImageMatchAnalyser::path_	match_analyser.hpp	/^	const std::string path_;$/;"	m	class:ImageMatchAnalyser	access:private
ImageMatchAnalyser::write_match_result	match_analyser.cpp	/^void ImageMatchAnalyser::write_match_result( std::ostream & out )$/;"	f	class:ImageMatchAnalyser	signature:( std::ostream & out )
ImageMatchAnalyser::xml_begin_image	match_analyser.cpp	/^void ImageMatchAnalyser::xml_begin_image( std::ostream & out )$/;"	f	class:ImageMatchAnalyser	signature:( std::ostream & out )
ImageMatchAnalyser::xml_end_image	match_analyser.cpp	/^void ImageMatchAnalyser::xml_end_image( std::ostream & out )$/;"	f	class:ImageMatchAnalyser	signature:( std::ostream & out )
ImageMatchAnalyser::xml_matched_image	match_analyser.cpp	/^void ImageMatchAnalyser::xml_matched_image( std::ostream & out, unsigned index, frame_type matched_frame )$/;"	f	class:ImageMatchAnalyser	signature:( std::ostream & out, unsigned index, frame_type matched_frame )
ImagePointsLoader	match_stream.cpp	/^ImagePointsLoader::ImagePointsLoader ()$/;"	f	class:ImagePointsLoader	signature:()
ImagePointsLoader	match_stream.hpp	/^class ImagePointsLoader : public StreamNode$/;"	c	inherits:StreamNode
ImagePointsLoader::ImagePointsLoader	match_stream.cpp	/^ImagePointsLoader::ImagePointsLoader ()$/;"	f	class:ImagePointsLoader	signature:()
ImagePointsLoader::do_end_task	match_stream.cpp	/^void ImagePointsLoader::do_end_task()$/;"	f	class:ImagePointsLoader	signature:()
ImagePointsLoader::do_load_image_points	match_stream.cpp	/^void ImagePointsLoader::do_load_image_points( const vector<match_image> & images, MatcherPtr matcher )$/;"	f	class:ImagePointsLoader	signature:( const vector<match_image> & images, MatcherPtr matcher )
ImagePointsLoader::do_run_task	match_stream.cpp	/^void ImagePointsLoader::do_run_task()$/;"	f	class:ImagePointsLoader	signature:()
ImagePointsLoader::image	match_stream.hpp	/^	typedef match_image image;$/;"	t	class:ImagePointsLoader	access:public
ImagePointsLoader::image_cnt_	match_stream.hpp	/^	std::size_t image_cnt_;$/;"	m	class:ImagePointsLoader	access:private
ImagePointsLoader::load_image_points_loop	match_stream.cpp	/^void ImagePointsLoader::load_image_points_loop()$/;"	f	class:ImagePointsLoader	signature:()
ImagePointsSender	match_stream.hpp	/^	ImagePointsSender ()$/;"	f	class:ImagePointsSender	access:public	signature:()
ImagePointsSender	match_stream.hpp	/^class ImagePointsSender : public StreamNode$/;"	c	inherits:StreamNode
ImagePointsSender::ImagePointsSender	match_stream.hpp	/^	ImagePointsSender ()$/;"	f	class:ImagePointsSender	access:public	signature:()
ImagePointsSender::dest_addr	match_stream.cpp	/^const endpoint ImagePointsSender::dest_addr() const $/;"	f	class:ImagePointsSender	signature:() const
ImagePointsSender::dest_addr_	match_stream.hpp	/^	endpoint dest_addr_;$/;"	m	class:ImagePointsSender	access:private
ImagePointsSender::do_end_task	match_stream.cpp	/^void ImagePointsSender::do_end_task()$/;"	f	class:ImagePointsSender	signature:()
ImagePointsSender::do_run_task	match_stream.cpp	/^void ImagePointsSender::do_run_task()$/;"	f	class:ImagePointsSender	signature:()
ImagePointsSender::send_packets_loop	match_stream.cpp	/^void ImagePointsSender::send_packets_loop()$/;"	f	class:ImagePointsSender	signature:()
ImagePointsSender::set_dest_addr	match_stream.cpp	/^void ImagePointsSender::set_dest_addr( const endpoint & addr )$/;"	f	class:ImagePointsSender	signature:( const endpoint & addr )
ImagePointsWindow	comm_window.hpp	/^	explicit ImagePointsWindow(int timeout = 20)$/;"	f	class:ImagePointsWindow	access:public	signature:(int timeout = 20)
ImagePointsWindow	comm_window.hpp	/^class ImagePointsWindow : public StepWindow$/;"	c	inherits:StepWindow
ImagePointsWindow::ImagePointsWindow	comm_window.hpp	/^	explicit ImagePointsWindow(int timeout = 20)$/;"	f	class:ImagePointsWindow	access:public	signature:(int timeout = 20)
IntImage	integral.h	/^	IntImage() {}$/;"	f	struct:IntImage	access:public	signature:()
IntImage	integral.h	/^	IntImage(const GrayImage& src) { init(src); }$/;"	f	struct:IntImage	access:public	signature:(const GrayImage& src)
IntImage	integral.h	/^struct IntImage : Image<int> {				\/\/ Integral image$/;"	s	inherits:Image
IntImage::BoxIntegral	integral.h	/^	int BoxIntegral(int row, int col, int rows, int cols) const {$/;"	f	struct:IntImage	access:public	signature:(int row, int col, int rows, int cols) const
IntImage::IntImage	integral.h	/^	IntImage() {}$/;"	f	struct:IntImage	access:public	signature:()
IntImage::IntImage	integral.h	/^	IntImage(const GrayImage& src) { init(src); }$/;"	f	struct:IntImage	access:public	signature:(const GrayImage& src)
IntImage::at	integral.h	/^	int at(int r, int c) const {	\/\/ get the pixel with bound check$/;"	f	struct:IntImage	access:public	signature:(int r, int c) const
IntImage::init	integral.cpp	/^void IntImage::init(const GrayImage& img) {$/;"	f	class:IntImage	signature:(const GrayImage& img)
IpVec	ipoint.h	/^typedef std::vector<Ipoint> IpVec;$/;"	t
IpVec2	ipoint.h	/^	typedef std::vector<I> IpVec2;$/;"	t	class:Matches	access:public
IplImage	integral.h	/^typedef struct _IplImage IplImage;$/;"	t	typeref:struct:_IplImage
IplImage	utils.h	/^typedef struct _IplImage IplImage;$/;"	t	typeref:struct:_IplImage
Ipoint	ipoint.h	/^	Ipoint() : orientation(0), clusterIndex(0), match(0) {};$/;"	f	struct:Ipoint	access:public	signature:()
Ipoint	ipoint.h	/^	Ipoint(float xx, float yy, float ss, int ll)$/;"	f	struct:Ipoint	access:public	signature:(float xx, float yy, float ss, int ll)
Ipoint	ipoint.h	/^struct Ipoint {$/;"	s
Ipoint::Ipoint	ipoint.h	/^	Ipoint() : orientation(0), clusterIndex(0), match(0) {};$/;"	f	struct:Ipoint	access:public	signature:()
Ipoint::Ipoint	ipoint.h	/^	Ipoint(float xx, float yy, float ss, int ll)$/;"	f	struct:Ipoint	access:public	signature:(float xx, float yy, float ss, int ll)
Ipoint::clusterIndex	ipoint.h	/^	int clusterIndex;		\/\/! Used to store cluster index$/;"	m	struct:Ipoint	access:public
Ipoint::cos_ori	ipoint.h	/^	float sin_ori, cos_ori;	\/\/! sin(orientation) and cos(orientation)$/;"	m	struct:Ipoint	access:public
Ipoint::descriptor	ipoint.h	/^	float descriptor[64];	\/\/! Vector of descriptor components$/;"	m	struct:Ipoint	access:public
Ipoint::dx	ipoint.h	/^	float dx, dy;			\/\/! Placeholders for point motion$/;"	m	struct:Ipoint	access:public
Ipoint::dy	ipoint.h	/^	float dx, dy;			\/\/! Placeholders for point motion$/;"	m	struct:Ipoint	access:public
Ipoint::laplacian	ipoint.h	/^	int laplacian;			\/\/! Sign of laplacian for fast matching purposes$/;"	m	struct:Ipoint	access:public
Ipoint::match	ipoint.h	/^	const void* match;		\/\/! matched ipoint$/;"	m	struct:Ipoint	access:public
Ipoint::orientation	ipoint.h	/^	float orientation;		\/\/! Orientation measured anti-clockwise from +ve x-axis$/;"	m	struct:Ipoint	access:public
Ipoint::scale	ipoint.h	/^	float scale;			\/\/! Detected scale$/;"	m	struct:Ipoint	access:public
Ipoint::sin_ori	ipoint.h	/^	float sin_ori, cos_ori;	\/\/! sin(orientation) and cos(orientation)$/;"	m	struct:Ipoint	access:public
Ipoint::x	ipoint.h	/^	float x, y;				\/\/! Coordinates of the detected interest point$/;"	m	struct:Ipoint	access:public
Ipoint::y	ipoint.h	/^	float x, y;				\/\/! Coordinates of the detected interest point$/;"	m	struct:Ipoint	access:public
LIB_END	comm_para.hpp	/^	const u_char      LIB_END             = 0x22;$/;"	m	namespace:__anon2
LIB_LOADING	matcher_manager.hpp	/^		LIB_LOADING,					\/\/<! lib loading$/;"	e	enum:Matcher::MATCHER_STATE
LIB_LOAD_SERVICE_HPP	lib_load_service.hpp	2;"	d
LIB_SENDING	comm_para.hpp	/^	const u_char      LIB_SENDING         = 0x02;$/;"	m	namespace:__anon2
LIB_START	comm_para.hpp	/^	const u_char      LIB_START           = 0x12;$/;"	m	namespace:__anon2
LOG	log.cpp	/^namespace LOG {$/;"	n	file:
LOG	log.h	/^namespace LOG {$/;"	n
LOG::DEBUG	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
LOG::ERR	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
LOG::INFO	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
LOG::Log	log.h	/^	class Log : boost::noncopyable {$/;"	c	namespace:LOG	inherits:boost::noncopyable
LOG::Log::Log	log.cpp	/^Log::Log() : core_(logging::core::get()) {$/;"	f	class:LOG::Log	signature:()
LOG::Log::con_sink	log.h	/^		sp_stream_sink con_sink()  { return sink_con_;  }$/;"	f	class:LOG::Log	access:public	signature:()
LOG::Log::core_	log.h	/^		sp_log_core    core_;$/;"	m	class:LOG::Log	access:private
LOG::Log::file_sink	log.h	/^		sp_file_sink   file_sink() { return sink_file_; }$/;"	f	class:LOG::Log	access:public	signature:()
LOG::Log::get	log.cpp	/^Log& Log::get() {$/;"	f	class:LOG::Log	signature:()
LOG::Log::init_log_file	log.cpp	/^void Log::init_log_file(const std::string& log_file, const std::string& prog_name) {$/;"	f	class:LOG::Log	signature:(const std::string& log_file, const std::string& prog_name)
LOG::Log::logger	log.h	/^		sev_logger&    logger()    { return slg_;       }$/;"	f	class:LOG::Log	access:public	signature:()
LOG::Log::sink_con_	log.h	/^		sp_stream_sink sink_con_;$/;"	m	class:LOG::Log	access:private
LOG::Log::sink_file_	log.h	/^		sp_file_sink   sink_file_;$/;"	m	class:LOG::Log	access:private
LOG::Log::slg_	log.h	/^		sev_logger     slg_;$/;"	m	class:LOG::Log	access:private
LOG::VERBOSE	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
LOG::WARN	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
LOG::get_logger	log.h	/^	inline sev_logger& get_logger() { return Log::get().logger(); }$/;"	f	namespace:LOG	signature:()
LOG::init_log_file	log.h	/^	inline void init_log_file(const std::string& log_file, const std::string& prog_name = "")$/;"	f	namespace:LOG	signature:(const std::string& log_file, const std::string& prog_name = Ó)
LOG::operator <<	log.cpp	/^std::ostream& operator << (std::ostream& s, severity_level level) { return levelmap.writeEnum(s, level); }$/;"	f	namespace:LOG	signature:(std::ostream& s, severity_level level)
LOG::set_console_filter	log.h	/^	template<typename F> inline void set_console_filter(F const& flt)$/;"	f	namespace:LOG	signature:(F const& flt)
LOG::set_console_format	log.h	/^	template<typename F> inline void set_console_format(F const& fmt)$/;"	f	namespace:LOG	signature:(F const& fmt)
LOG::set_file_filter	log.h	/^	template<typename F> inline void set_file_filter(F const& flt)$/;"	f	namespace:LOG	signature:(F const& flt)
LOG::set_file_format	log.h	/^	template<typename F> inline void set_file_format(F const& fmt)$/;"	f	namespace:LOG	signature:(F const& fmt)
LOG::set_filter	log.h	/^	template<typename SP, typename FLT> inline void set_filter(SP sink, FLT const& flt)$/;"	f	namespace:LOG	signature:(SP sink, FLT const& flt)
LOG::set_format	log.h	/^	template<typename SP, typename FMT> inline void set_format(SP sink, FMT const& fmt)$/;"	f	namespace:LOG	signature:(SP sink, FMT const& fmt)
LOG::sev_levels	log.cpp	/^static const char* sev_levels[] = { "DEBUG", "VERBOSE", "INFO ", "WARN ", "ERROR" };$/;"	m	namespace:LOG	file:
LOG::sev_logger	log.h	/^	typedef src::severity_logger<severity_level> sev_logger;$/;"	t	namespace:LOG
LOG::severity_level	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	g	namespace:LOG
LOG::sp_file_sink	log.h	/^	typedef boost::shared_ptr<sinks::synchronous_sink<sinks::text_file_backend> >    sp_file_sink;$/;"	t	namespace:LOG
LOG::sp_log_core	log.h	/^	typedef boost::shared_ptr<logging::core>     sp_log_core;$/;"	t	namespace:LOG
LOG::sp_stream_sink	log.h	/^	typedef boost::shared_ptr<sinks::synchronous_sink<sinks::text_ostream_backend> > sp_stream_sink;$/;"	t	namespace:LOG
LibIpVec	ipoint.h	/^typedef std::vector<LibIpt> LibIpVec;$/;"	t
LibIpt	ipoint.h	/^struct LibIpt {				\/\/ Simplified ipoint for surf library$/;"	s
LibIpt::descriptor	ipoint.h	/^	float descriptor[64];	\/\/! Vector of descriptor components$/;"	m	struct:LibIpt	access:public
LibLoadService	lib_load_service.cpp	/^LibLoadService::LibLoadService()$/;"	f	class:LibLoadService	signature:()
LibLoadService	lib_load_service.hpp	/^class LibLoadService$/;"	c
LibLoadService::LibLoadService	lib_load_service.cpp	/^LibLoadService::LibLoadService()$/;"	f	class:LibLoadService	signature:()
LibLoadService::c_wait_	lib_load_service.hpp	/^	boost::condition c_wait_;$/;"	m	class:LibLoadService	access:private
LibLoadService::end	lib_load_service.cpp	/^bool LibLoadService::end()$/;"	f	class:LibLoadService	signature:()
LibLoadService::instance	lib_load_service.hpp	/^	static LibLoadService & instance()$/;"	f	class:LibLoadService	access:public	signature:()
LibLoadService::lib_valid_	lib_load_service.hpp	/^	bool lib_valid_;$/;"	m	class:LibLoadService	access:private
LibLoadService::load_lib_to_matcher	lib_load_service.cpp	/^void LibLoadService::load_lib_to_matcher( MatcherPtr m )$/;"	f	class:LibLoadService	signature:( MatcherPtr m )
LibLoadService::load_lib_to_mem	lib_load_service.cpp	/^void LibLoadService::load_lib_to_mem(const std::string & path)$/;"	f	class:LibLoadService	signature:(const std::string & path)
LibLoadService::lock	lib_load_service.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:LibLoadService	access:public
LibLoadService::monitor_	lib_load_service.hpp	/^	boost::mutex monitor_;$/;"	m	class:LibLoadService	access:private
LibLoadService::notify_wait_matcher	lib_load_service.cpp	/^void LibLoadService::notify_wait_matcher()$/;"	f	class:LibLoadService	signature:()
LibLoadService::run	lib_load_service.cpp	/^void LibLoadService::run()$/;"	f	class:LibLoadService	signature:()
LibLoadService::video_lib	lib_load_service.hpp	/^	const VideoLibVec & video_lib()$/;"	f	class:LibLoadService	access:public	signature:()
LibLoadService::video_lib_	lib_load_service.hpp	/^	VideoLibVec video_lib_;$/;"	m	class:LibLoadService	access:private
LibPointVec	newlib.h	/^typedef std::vector<BitFeature> LibPointVec;$/;"	t
Log	log.cpp	/^Log::Log() : core_(logging::core::get()) {$/;"	f	class:LOG::Log	signature:()
Log	log.h	/^	class Log : boost::noncopyable {$/;"	c	namespace:LOG	inherits:boost::noncopyable
MASK	bits.hpp	/^	static const unsigned char MASK = 0x07;$/;"	m	struct:bits	access:public
MATCHER_MANAGER_HPP	matcher_manager.hpp	2;"	d
MATCHER_STATE	matcher_manager.hpp	/^	enum MATCHER_STATE {$/;"	g	class:Matcher	access:public
MATCH_ANALYSER	match_analyser.hpp	2;"	d
MATCH_CHAIN_HPP	match_stream.hpp	20;"	d
MATCH_END	comm_para.hpp	/^	const u_char      MATCH_END           = 0x28;$/;"	m	namespace:__anon2
MATCH_RECVING	comm_para.hpp	/^	const u_char      MATCH_RECVING       = 0x08;$/;"	m	namespace:__anon2
MATCH_UTILS_HPP	match_utils.h	2;"	d
MATCH_WIDTH	comm_para.hpp	/^	const int         MATCH_WIDTH         = 128;$/;"	m	namespace:__anon2
MAX_FEATURE_BITS	bit_feature.h	12;"	d
MDist	ipoint.h	/^struct MDist {		\/\/ Manhattan distance$/;"	s
MDist::operator ()	ipoint.h	/^	float operator () (const Ipoint& lhs, const I& rhs) const {$/;"	f	struct:MDist	access:public	signature:(const Ipoint& lhs, const I& rhs) const
MDist::threshold	ipoint.h	/^	float threshold() const { return 0.6; }$/;"	f	struct:MDist	access:public	signature:() const
MIN_FEATURE_BITS	bit_feature.h	11;"	d
MatchAnalyser	match_analyser.hpp	/^	MatchAnalyser () {}$/;"	f	class:MatchAnalyser	access:private	signature:()
MatchAnalyser	match_analyser.hpp	/^class MatchAnalyser : public boost::noncopyable$/;"	c	inherits:boost::noncopyable
MatchAnalyser::MatchAnalyser	match_analyser.hpp	/^	MatchAnalyser () {}$/;"	f	class:MatchAnalyser	access:private	signature:()
MatchAnalyser::add_image	match_analyser.cpp	/^void MatchAnalyser::add_image( frame_type frame, const std::string & path )$/;"	f	class:MatchAnalyser	signature:( frame_type frame, const std::string & path )
MatchAnalyser::add_match	match_analyser.cpp	/^void MatchAnalyser::add_match( frame_type matched_frame, frame_type frame )$/;"	f	class:MatchAnalyser	signature:( frame_type matched_frame, frame_type frame )
MatchAnalyser::add_video	match_analyser.cpp	/^void MatchAnalyser::add_video( unsigned index, const std::string & path, double fps )$/;"	f	class:MatchAnalyser	signature:( unsigned index, const std::string & path, double fps )
MatchAnalyser::do_post_calculations	match_analyser.cpp	/^void MatchAnalyser::do_post_calculations()$/;"	f	class:MatchAnalyser	signature:()
MatchAnalyser::endpoint	match_analyser.hpp	/^	typedef boost::asio::ip::udp::endpoint 			   endpoint;$/;"	t	class:MatchAnalyser	access:public
MatchAnalyser::frames_buffer_type	match_analyser.hpp	/^	typedef std::vector<frames_type>                   frames_buffer_type;$/;"	t	class:MatchAnalyser	access:public
MatchAnalyser::frames_map_	match_analyser.hpp	/^	frames_map_type frames_map_;$/;"	m	class:MatchAnalyser	access:private
MatchAnalyser::frames_map_type	match_analyser.hpp	/^    typedef std::map<endpoint, frames_type>            frames_map_type;$/;"	t	class:MatchAnalyser	access:public
MatchAnalyser::frames_type	match_analyser.hpp	/^	typedef std::vector<frame_type>                    frames_type;$/;"	t	class:MatchAnalyser	access:public
MatchAnalyser::get_match_frame_video_index	match_analyser.hpp	/^	static unsigned get_match_frame_video_index( frame_type frame ) { return frame >> 24; }$/;"	f	class:MatchAnalyser	access:public	signature:( frame_type frame )
MatchAnalyser::get_num_points_of_frame	match_analyser.cpp	/^unsigned MatchAnalyser::get_num_points_of_frame( frame_type frame )$/;"	f	class:MatchAnalyser	signature:( frame_type frame )
MatchAnalyser::get_video_match_frame_pos	match_analyser.hpp	/^	static unsigned get_video_match_frame_pos  ( frame_type frame ) { return frame & 0x00FFFFFF; }$/;"	f	class:MatchAnalyser	access:public	signature:( frame_type frame )
MatchAnalyser::handle_packet	match_analyser.cpp	/^void MatchAnalyser::handle_packet( Packet & pkt, const MatchAnalyser::endpoint & from_addr )$/;"	f	class:MatchAnalyser	signature:( Packet & pkt, const MatchAnalyser::endpoint & from_addr )
MatchAnalyser::images_map_	match_analyser.hpp	/^	images_map_type images_map_;$/;"	m	class:MatchAnalyser	access:private
MatchAnalyser::images_map_type	match_analyser.hpp	/^	typedef std::map<frame_type, image_matcher_ptr>    images_map_type;$/;"	t	class:MatchAnalyser	access:public
MatchAnalyser::instance	match_analyser.hpp	/^	static MatchAnalyser & instance()$/;"	f	class:MatchAnalyser	access:public	signature:()
MatchAnalyser::match_frame_is_image	match_analyser.hpp	/^	static bool     match_frame_is_image( frame_type frame )        { return get_match_frame_video_index( frame ) == 0; }$/;"	f	class:MatchAnalyser	access:public	signature:( frame_type frame )
MatchAnalyser::num_points_map_	match_analyser.hpp	/^	num_points_map_type num_points_map_;$/;"	m	class:MatchAnalyser	access:private
MatchAnalyser::num_points_map_type	match_analyser.hpp	/^	typedef std::map<frame_type, unsigned>             num_points_map_type;$/;"	t	class:MatchAnalyser	access:public
MatchAnalyser::set_num_points_of_frame	match_analyser.cpp	/^void MatchAnalyser::set_num_points_of_frame( frame_type frame , unsigned num_points )$/;"	f	class:MatchAnalyser	signature:( frame_type frame , unsigned num_points )
MatchAnalyser::store_match_group_info	match_analyser.cpp	/^void MatchAnalyser::store_match_group_info( const MatchAnalyser::endpoint & addr, const MatchAnalyser::frames_type & frame_group, const std::vector<unsigned> & num_points_vec )$/;"	f	class:MatchAnalyser	signature:( const MatchAnalyser::endpoint & addr, const MatchAnalyser::frames_type & frame_group, const std::vector<unsigned> & num_points_vec )
MatchAnalyser::videos_map_	match_analyser.hpp	/^	videos_map_type videos_map_;$/;"	m	class:MatchAnalyser	access:private
MatchAnalyser::videos_map_type	match_analyser.hpp	/^    typedef std::map<frame_type, video_matcher_ptr>    videos_map_type;$/;"	t	class:MatchAnalyser	access:public
MatchAnalyser::write_match_result	match_analyser.cpp	/^void MatchAnalyser::write_match_result( std::ostream & out )$/;"	f	class:MatchAnalyser	signature:( std::ostream & out )
MatchArgs	match_utils.h	/^struct MatchArgs {$/;"	s
MatchArgs::batch_len	match_utils.h	/^	int batch_len;		\/\/ Ã¿×éÆ¥ÅäÖ¡Êý$/;"	m	struct:MatchArgs	access:public
MatchArgs::diag_test_bits	match_utils.h	/^	int diag_test_bits;		\/\/ Ã¿×éÆ¥Åä½á¹û£¨¶Ô½ÇÏß£©ÅÐ¶ÏÎ»Êý$/;"	m	struct:MatchArgs	access:public
MatchArgs::diag_test_thres	match_utils.h	/^	int diag_test_thres;	\/\/ Ã¿×éÆ¥Åä½á¹ûÅÐ¶ÏãÐÖµ$/;"	m	struct:MatchArgs	access:public
MatchArgs::feature_bits	match_utils.h	/^	int feature_bits;		\/\/ ÌØÕ÷¾«¶È$/;"	m	struct:MatchArgs	access:public
MatchArgs::frame_thres	match_utils.h	/^	int frame_thres;		\/\/ µ¥Ö¡Æ¥ÅäãÐÖµ$/;"	m	struct:MatchArgs	access:public
MatchArgs::load	match_utils.cpp	/^void MatchArgs::load(const string& arg_file) {$/;"	f	class:MatchArgs	signature:(const string& arg_file)
MatchArgs::max_skip	match_utils.h	/^	int max_skip;			\/\/ ¿ÉÌø¹ýµÄÁ¬Ðø²»Æ¥ÅäÖ¡Êý$/;"	m	struct:MatchArgs	access:public
MatchArgs::min_match_len	match_utils.h	/^	int min_match_len;		\/\/ ×îÐ¡Á¬ÐøÆ¥ÅäÖ¡ÊýãÐÖµ$/;"	m	struct:MatchArgs	access:public
MatchArgs::sequence_thres	match_utils.h	/^	int sequence_thres;		\/\/ ÓÃÓÚÆ¥Åä¶ÎµÄºÏ²¢$/;"	m	struct:MatchArgs	access:public
MatchImageBox	comm_box.cpp	/^MatchImageBox::MatchImageBox (Server * s)$/;"	f	class:MatchImageBox	signature:(Server * s)
MatchImageBox	comm_box.hpp	/^class MatchImageBox : public match_image_box_base__$/;"	c	inherits:match_image_box_base__
MatchImageBox::CUTED_SIZE	comm_box.hpp	/^	enum { FILTER_NUM = 8, CUT_THRESHOLD = 88, CUTED_SIZE = 45 };$/;"	e	enum:MatchImageBox::__anon3
MatchImageBox::CUT_THRESHOLD	comm_box.hpp	/^	enum { FILTER_NUM = 8, CUT_THRESHOLD = 88, CUTED_SIZE = 45 };$/;"	e	enum:MatchImageBox::__anon3
MatchImageBox::FILTER_NUM	comm_box.hpp	/^	enum { FILTER_NUM = 8, CUT_THRESHOLD = 88, CUTED_SIZE = 45 };$/;"	e	enum:MatchImageBox::__anon3
MatchImageBox::MatchImageBox	comm_box.cpp	/^MatchImageBox::MatchImageBox (Server * s)$/;"	f	class:MatchImageBox	signature:(Server * s)
MatchImageBox::acquire	comm_box.cpp	/^match_image * MatchImageBox::acquire()$/;"	f	class:MatchImageBox	signature:()
MatchImageBox::choose_targets	comm_box.cpp	/^MatchImageBox::indexes_type MatchImageBox::choose_targets()$/;"	f	class:MatchImageBox	signature:()
MatchImageBox::get	comm_box.cpp	/^bool MatchImageBox::get(std::vector< match_image > & snk)$/;"	f	class:MatchImageBox	signature:(std::vector< match_image > & snk)
MatchImageBox::get_condition_not_satisfied	comm_box.cpp	/^bool MatchImageBox::get_condition_not_satisfied() const$/;"	f	class:MatchImageBox	signature:() const
MatchImageBox::is_first_get_	comm_box.hpp	/^	bool        is_first_get_;$/;"	m	class:MatchImageBox	access:private
MatchImageBox::num_first_get_required_	comm_box.hpp	/^	std::size_t num_first_get_required_;$/;"	m	class:MatchImageBox	access:private
MatchImageBox::put	comm_box.cpp	/^void MatchImageBox::put()$/;"	f	class:MatchImageBox	signature:()
MatchImageBox::server_	comm_box.hpp	/^	Server *    server_;$/;"	m	class:MatchImageBox	access:private
MatchResult	match_utils.h	/^	MatchResult(int tb, int lb, int ln, unsigned int bits) :$/;"	f	struct:MatchResult	access:public	signature:(int tb, int lb, int ln, unsigned int bits)
MatchResult	match_utils.h	/^struct MatchResult {$/;"	s
MatchResult::MatchResult	match_utils.h	/^	MatchResult(int tb, int lb, int ln, unsigned int bits) :$/;"	f	struct:MatchResult	access:public	signature:(int tb, int lb, int ln, unsigned int bits)
MatchResult::lib_begin	match_utils.h	/^	int test_begin, lib_begin;$/;"	m	struct:MatchResult	access:public
MatchResult::match_bits	match_utils.h	/^	unsigned int match_bits;$/;"	m	struct:MatchResult	access:public
MatchResult::match_len	match_utils.h	/^	int match_len;$/;"	m	struct:MatchResult	access:public
MatchResult::test_begin	match_utils.h	/^	int test_begin, lib_begin;$/;"	m	struct:MatchResult	access:public
MatchSection	match_utils.h	/^	MatchSection(int tb, int lb, int ln) :$/;"	f	struct:MatchSection	access:public	signature:(int tb, int lb, int ln)
MatchSection	match_utils.h	/^struct MatchSection {$/;"	s
MatchSection::MatchSection	match_utils.h	/^	MatchSection(int tb, int lb, int ln) :$/;"	f	struct:MatchSection	access:public	signature:(int tb, int lb, int ln)
MatchSection::len	match_utils.h	/^	int len;$/;"	m	struct:MatchSection	access:public
MatchSection::lib_begin	match_utils.h	/^	int test_begin, lib_begin;$/;"	m	struct:MatchSection	access:public
MatchSection::lib_id	match_utils.h	/^	int lib_id()  const { return lib_begin  >> 16; }$/;"	f	struct:MatchSection	access:public	signature:() const
MatchSection::lib_pos	match_utils.h	/^	int lib_pos()  const { return lib_begin  & 0xffff; }$/;"	f	struct:MatchSection	access:public	signature:() const
MatchSection::merge	match_utils.cpp	/^void MatchSection::merge(const MatchSection& rhs) {$/;"	f	class:MatchSection	signature:(const MatchSection& rhs)
MatchSection::offset	match_utils.h	/^	int offset()  const { return lib_begin - test_begin; }$/;"	f	struct:MatchSection	access:public	signature:() const
MatchSection::test_begin	match_utils.h	/^	int test_begin, lib_begin;$/;"	m	struct:MatchSection	access:public
MatchSection::test_id	match_utils.h	/^	int test_id() const { return test_begin >> 16; }$/;"	f	struct:MatchSection	access:public	signature:() const
MatchSection::test_pos	match_utils.h	/^	int test_pos() const { return test_begin & 0xffff; }$/;"	f	struct:MatchSection	access:public	signature:() const
Matcher	matcher_manager.hpp	/^	Matcher ( const endpoint_type & e )$/;"	f	class:Matcher	access:public	signature:( const endpoint_type & e )
Matcher	matcher_manager.hpp	/^class Matcher$/;"	c
Matcher::BUSY	matcher_manager.hpp	/^		BUSY,							\/\/<! do match state$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::COMM_STATE	matcher_manager.hpp	/^	enum COMM_STATE {$/;"	g	class:Matcher	access:public
Matcher::FAIL_CONNECT	matcher_manager.hpp	/^		FAIL_CONNECT,					\/\/<! fail connect$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::INVALID_COMM_STATE	matcher_manager.hpp	/^		INVALID_COMM_STATE = -1,		\/\/<! invalid $/;"	e	enum:Matcher::COMM_STATE
Matcher::INVALID_MATCHER_STATE	matcher_manager.hpp	/^		INVALID_MATCHER_STATE = -2,		\/\/<! invalid state$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::LIB_LOADING	matcher_manager.hpp	/^		LIB_LOADING,					\/\/<! lib loading$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::MATCHER_STATE	matcher_manager.hpp	/^	enum MATCHER_STATE {$/;"	g	class:Matcher	access:public
Matcher::Matcher	matcher_manager.hpp	/^	Matcher ( const endpoint_type & e )$/;"	f	class:Matcher	access:public	signature:( const endpoint_type & e )
Matcher::READY	matcher_manager.hpp	/^		READY,							\/\/<! ready waiting data$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::RECEIVING	matcher_manager.hpp	/^		RECEIVING,						\/\/<! receiving data$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::RESPONSED	matcher_manager.hpp	/^		RESPONSED,						\/\/<! last packet responsed $/;"	e	enum:Matcher::COMM_STATE
Matcher::SENDING	matcher_manager.hpp	/^		SENDING							\/\/<! sending match result$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::UNCONNECTED	matcher_manager.hpp	/^		UNCONNECTED,					\/\/<! unconnected default state$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::UNRESPONSED	matcher_manager.hpp	/^		UNRESPONSED						\/\/<! last packet not responsed$/;"	e	enum:Matcher::COMM_STATE
Matcher::WAIT_LIB_LOAD	matcher_manager.hpp	/^		WAIT_LIB_LOAD,					\/\/<! connected but lib not loaded$/;"	e	enum:Matcher::MATCHER_STATE
Matcher::address	matcher_manager.hpp	/^	const ip_address    address() const { return endpoint_.address(); }$/;"	f	class:Matcher	access:public	signature:() const
Matcher::clear_load	matcher_manager.hpp	/^	void clear_load() { num_load_imgs_ = 0; }$/;"	f	class:Matcher	access:public	signature:()
Matcher::comm_state	matcher_manager.hpp	/^	COMM_STATE comm_state() const { return comm_state_; }$/;"	f	class:Matcher	access:public	signature:() const
Matcher::comm_state_	matcher_manager.hpp	/^	COMM_STATE comm_state_;		\/\/ currently not used$/;"	m	class:Matcher	access:private
Matcher::endpoint_	matcher_manager.hpp	/^	endpoint_type endpoint_;$/;"	m	class:Matcher	access:private
Matcher::endpoint_type	matcher_manager.hpp	/^	typedef boost::asio::ip::udp::endpoint endpoint_type;$/;"	t	class:Matcher	access:public
Matcher::increase_load	matcher_manager.hpp	/^	void increase_load() { ++num_load_imgs_; }$/;"	f	class:Matcher	access:public	signature:()
Matcher::lock	matcher_manager.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:Matcher	access:public
Matcher::monitor_	matcher_manager.hpp	/^	boost::mutex monitor_;$/;"	m	class:Matcher	access:private
Matcher::num_load_imgs	matcher_manager.hpp	/^	unsigned num_load_imgs() const { return num_load_imgs_; }$/;"	f	class:Matcher	access:public	signature:() const
Matcher::num_load_imgs_	matcher_manager.hpp	/^	unsigned num_load_imgs_;$/;"	m	class:Matcher	access:private
Matcher::port	matcher_manager.hpp	/^	unsigned            port   () const { return endpoint_.port(); }$/;"	f	class:Matcher	access:public	signature:() const
Matcher::ready_receive	matcher_manager.hpp	/^	bool ready_receive() const { return (state_ == READY) && comm_state_ == RESPONSED; }$/;"	f	class:Matcher	access:public	signature:() const
Matcher::set_comm_state	matcher_manager.hpp	/^	void set_comm_state(COMM_STATE s) { lock lk(monitor_); comm_state_ = s; }$/;"	f	class:Matcher	access:public	signature:(COMM_STATE s)
Matcher::set_state	matcher_manager.hpp	/^	void set_state(MATCHER_STATE s) { lock lk(monitor_); state_ = s; }$/;"	f	class:Matcher	access:public	signature:(MATCHER_STATE s)
Matcher::state	matcher_manager.hpp	/^	MATCHER_STATE state() const { return state_; }$/;"	f	class:Matcher	access:public	signature:() const
Matcher::state_	matcher_manager.hpp	/^	MATCHER_STATE state_;$/;"	m	class:Matcher	access:private
Matcher::to_endpoint	matcher_manager.hpp	/^	const endpoint_type to_endpoint() const { return endpoint_; }$/;"	f	class:Matcher	access:public	signature:() const
MatcherManager	matcher_manager.hpp	/^	MatcherManager() {}$/;"	f	class:MatcherManager	access:private	signature:()
MatcherManager	matcher_manager.hpp	/^class MatcherManager$/;"	c
MatcherManager::MatcherManager	matcher_manager.hpp	/^	MatcherManager() {}$/;"	f	class:MatcherManager	access:private	signature:()
MatcherManager::Matchers	matcher_manager.hpp	/^	typedef std::deque< MatcherPtr > Matchers;$/;"	t	class:MatcherManager	access:public
MatcherManager::add_matcher	matcher_manager.cpp	/^void MatcherManager::add_matcher( MatcherPtr m )$/;"	f	class:MatcherManager	signature:( MatcherPtr m )
MatcherManager::add_matcher	matcher_manager.cpp	/^void MatcherManager::add_matcher( MatcherPtr m, Matchers & ms )$/;"	f	class:MatcherManager	signature:( MatcherPtr m, Matchers & ms )
MatcherManager::choose_next_matcher	matcher_manager.hpp	/^	MatcherPtr choose_next_matcher()$/;"	f	class:MatcherManager	access:public	signature:()
MatcherManager::conn_matchers	matcher_manager.hpp	/^	const Matchers & conn_matchers() const { return conn_matchers_; }$/;"	f	class:MatcherManager	access:public	signature:() const
MatcherManager::conn_matchers_	matcher_manager.hpp	/^	Matchers conn_matchers_;$/;"	m	class:MatcherManager	access:private
MatcherManager::connect_matcher	matcher_manager.cpp	/^void MatcherManager::connect_matcher( const Matcher & m )$/;"	f	class:MatcherManager	signature:( const Matcher & m )
MatcherManager::exists	matcher_manager.hpp	/^	bool exists( const Matcher & m ) { return find(m); }$/;"	f	class:MatcherManager	access:public	signature:( const Matcher & m )
MatcherManager::find	matcher_manager.hpp	/^	MatcherPtr find( const Matcher & m ) const$/;"	f	class:MatcherManager	access:public	signature:( const Matcher & m ) const
MatcherManager::find_in	matcher_manager.hpp	/^	static MatcherPtr find_in( const Matcher & m, const Matchers & ms )$/;"	f	class:MatcherManager	access:public	signature:( const Matcher & m, const Matchers & ms )
MatcherManager::find_matchers_at_state	matcher_manager.hpp	/^	Matchers find_matchers_at_state( const Matcher::MATCHER_STATE s )$/;"	f	class:MatcherManager	access:public	signature:( const Matcher::MATCHER_STATE s )
MatcherManager::find_one_matcher_at_state	matcher_manager.hpp	/^	MatcherPtr find_one_matcher_at_state( const Matcher::MATCHER_STATE s )$/;"	f	class:MatcherManager	access:public	signature:( const Matcher::MATCHER_STATE s )
MatcherManager::free_matcher	matcher_manager.cpp	/^void MatcherManager::free_matcher(const Matcher & m)$/;"	f	class:MatcherManager	signature:(const Matcher & m)
MatcherManager::get_comm_state	matcher_manager.hpp	/^	Matcher::COMM_STATE get_comm_state( const Matcher & m ) const$/;"	f	class:MatcherManager	access:public	signature:( const Matcher & m ) const
MatcherManager::get_matcher_state	matcher_manager.hpp	/^	Matcher::MATCHER_STATE get_matcher_state( const Matcher & m ) const$/;"	f	class:MatcherManager	access:public	signature:( const Matcher & m ) const
MatcherManager::instance	matcher_manager.hpp	/^	static MatcherManager & instance()$/;"	f	class:MatcherManager	access:public	signature:()
MatcherManager::instance_	matcher_manager.hpp	/^	static MatcherManager * instance_;$/;"	m	class:MatcherManager	access:private
MatcherManager::lock	matcher_manager.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:MatcherManager	access:public
MatcherManager::make_matcher	matcher_manager.hpp	/^	static MatcherPtr make_matcher( const Matcher::endpoint_type & e )$/;"	f	class:MatcherManager	access:public	signature:( const Matcher::endpoint_type & e )
MatcherManager::matchers	matcher_manager.hpp	/^	const Matchers & matchers() const { return matchers_; }$/;"	f	class:MatcherManager	access:public	signature:() const
MatcherManager::matchers_	matcher_manager.hpp	/^	Matchers matchers_;$/;"	m	class:MatcherManager	access:private
MatcherManager::monitor_	matcher_manager.hpp	/^	boost::mutex monitor_;$/;"	m	class:MatcherManager	access:private
MatcherManager::no_available_matcher	matcher_manager.cpp	/^bool MatcherManager::no_available_matcher() $/;"	f	class:MatcherManager	signature:()
MatcherManager::print_conn_matchers	matcher_manager.hpp	/^	void print_conn_matchers(std::ostream & out) const$/;"	f	class:MatcherManager	access:public	signature:(std::ostream & out) const
MatcherManager::print_matcher_util	matcher_manager.cpp	/^void MatcherManager::print_matcher_util( ostream & out, const Matchers & ms ) const$/;"	f	class:MatcherManager	signature:( ostream & out, const Matchers & ms ) const
MatcherManager::print_matchers	matcher_manager.hpp	/^	void print_matchers     (std::ostream & out) const$/;"	f	class:MatcherManager	access:public	signature:(std::ostream & out) const
MatcherManager::set_matcher_comm_state	matcher_manager.hpp	/^	void set_matcher_comm_state( MatcherPtr m , Matcher::COMM_STATE s ) { set_matcher_comm_state( *m, s ); }$/;"	f	class:MatcherManager	access:public	signature:( MatcherPtr m , Matcher::COMM_STATE s )
MatcherManager::set_matcher_comm_state	matcher_manager.hpp	/^	void set_matcher_comm_state( const Matcher & m , Matcher::COMM_STATE s )$/;"	f	class:MatcherManager	access:public	signature:( const Matcher & m , Matcher::COMM_STATE s )
MatcherManager::set_matcher_comm_state	matcher_manager.hpp	/^	void set_matcher_comm_state( const Matcher::endpoint_type & e, Matcher::COMM_STATE s ) { set_matcher_comm_state( Matcher(e), s ); }$/;"	f	class:MatcherManager	access:public	signature:( const Matcher::endpoint_type & e, Matcher::COMM_STATE s )
MatcherManager::set_matcher_state	matcher_manager.hpp	/^	void set_matcher_state( MatcherPtr m , Matcher::MATCHER_STATE s ) { set_matcher_state( *m, s ); }$/;"	f	class:MatcherManager	access:public	signature:( MatcherPtr m , Matcher::MATCHER_STATE s )
MatcherManager::set_matcher_state	matcher_manager.hpp	/^	void set_matcher_state( const Matcher & m , Matcher::MATCHER_STATE s )$/;"	f	class:MatcherManager	access:public	signature:( const Matcher & m , Matcher::MATCHER_STATE s )
MatcherManager::set_matcher_state	matcher_manager.hpp	/^	void set_matcher_state( const Matcher::endpoint_type & e, Matcher::MATCHER_STATE s ) { set_matcher_state( Matcher(e), s ); }$/;"	f	class:MatcherManager	access:public	signature:( const Matcher::endpoint_type & e, Matcher::MATCHER_STATE s )
MatcherPtr	matcher_manager.hpp	/^typedef boost::shared_ptr< Matcher > MatcherPtr;$/;"	t
Matchers	matcher_manager.hpp	/^	typedef std::deque< MatcherPtr > Matchers;$/;"	t	class:MatcherManager	access:public
Matches	ipoint.h	/^	Matches() {}$/;"	f	class:Matches	access:public	signature:()
Matches	ipoint.h	/^	Matches(IpVec& ipts1, IpVec2& ipts2) : ipts1_(&ipts1), ipts2_(&ipts2) {}$/;"	f	class:Matches	access:public	signature:(IpVec& ipts1, IpVec2& ipts2)
Matches	ipoint.h	/^class Matches {$/;"	c
Matches::IpVec2	ipoint.h	/^	typedef std::vector<I> IpVec2;$/;"	t	class:Matches	access:public
Matches::Matches	ipoint.h	/^	Matches() {}$/;"	f	class:Matches	access:public	signature:()
Matches::Matches	ipoint.h	/^	Matches(IpVec& ipts1, IpVec2& ipts2) : ipts1_(&ipts1), ipts2_(&ipts2) {}$/;"	f	class:Matches	access:public	signature:(IpVec& ipts1, IpVec2& ipts2)
Matches::Run	ipoint.cpp	/^void Matches<D, I>::Run(bool mt) {$/;"	f	class:Matches	signature:(bool mt)
Matches::dist	ipoint.h	/^	D dist;$/;"	m	class:Matches	access:private
Matches::ipt1	ipoint.h	/^	const Ipoint& ipt1(int i) const { return *matches_[i].first;  }$/;"	f	class:Matches	access:public	signature:(int i) const
Matches::ipt2	ipoint.h	/^	const I& ipt2(int i) const { return *matches_[i].second; }$/;"	f	class:Matches	access:public	signature:(int i) const
Matches::ipts1_	ipoint.h	/^	IpVec*  ipts1_;$/;"	m	class:Matches	access:private
Matches::ipts2_	ipoint.h	/^	IpVec2* ipts2_;$/;"	m	class:Matches	access:private
Matches::matchThread	ipoint.cpp	/^void Matches<D, I>::matchThread(int tid) {$/;"	f	class:Matches	signature:(int tid)
Matches::matches_	ipoint.h	/^	std::vector<std::pair<const Ipoint*, const I*> > matches_;$/;"	m	class:Matches	access:private
Matches::size	ipoint.h	/^	int size() const { return matches_.size(); }$/;"	f	class:Matches	access:public	signature:() const
Matches::storeMatch	ipoint.cpp	/^void Matches<EDist, Ipoint>::storeMatch(Ipoint* ipt) {$/;"	f	class:Matches	signature:(Ipoint* ipt)
Matches::storeMatch	ipoint.cpp	/^void Matches<MDist, Ipoint>::storeMatch(Ipoint* ipt) {$/;"	f	class:Matches	signature:(Ipoint* ipt)
Matches::storeMatch	ipoint.h	/^	void storeMatch(Ipoint* ipt)$/;"	f	class:Matches	access:private	signature:(Ipoint* ipt)
Matrix34	fasthessian.cpp	/^typedef float Matrix34[3][4];$/;"	t	file:
MaxDirection	surf.cpp	/^	MaxDirection(float sx = 0, float sy = 0) : x(sx), y(sy), l(sx*sx + sy*sy) {}$/;"	f	class:MaxDirection	access:public	signature:(float sx = 0, float sy = 0)
MaxDirection	surf.cpp	/^class MaxDirection {$/;"	c	file:
MaxDirection::MaxDirection	surf.cpp	/^	MaxDirection(float sx = 0, float sy = 0) : x(sx), y(sy), l(sx*sx + sy*sy) {}$/;"	f	class:MaxDirection	access:public	signature:(float sx = 0, float sy = 0)
MaxDirection::angle	surf.cpp	/^	float angle() const {$/;"	f	class:MaxDirection	access:public	signature:() const
MaxDirection::cos	surf.cpp	/^	float cos() const { return x \/ sqrt(l); }$/;"	f	class:MaxDirection	access:public	signature:() const
MaxDirection::l	surf.cpp	/^	float x, y, l;$/;"	m	class:MaxDirection	file:	access:private
MaxDirection::set	surf.cpp	/^	void set(float sx, float sy) {$/;"	f	class:MaxDirection	access:public	signature:(float sx, float sy)
MaxDirection::sin	surf.cpp	/^	float sin() const { return y \/ sqrt(l); }$/;"	f	class:MaxDirection	access:public	signature:() const
MaxDirection::x	surf.cpp	/^	float x, y, l;$/;"	m	class:MaxDirection	file:	access:private
MaxDirection::y	surf.cpp	/^	float x, y, l;$/;"	m	class:MaxDirection	file:	access:private
N	bits.hpp	/^	int N;$/;"	m	struct:bits	access:public
NCOLOURS	utils.cpp	/^static const int NCOLOURS = 8;$/;"	v	file:
NEWLIB_H	newlib.h	2;"	d
NewLibLoader	match_stream.hpp	/^class NewLibLoader : public StreamNode$/;"	c	inherits:StreamNode
NewLibLoader::big_file	match_stream.hpp	/^	BigLibFile big_file;$/;"	m	class:NewLibLoader	access:private
NewLibSender	match_stream.hpp	/^class NewLibSender : public StreamNode$/;"	c	inherits:StreamNode
NewLibSender::dest_	match_stream.hpp	/^	const endpoint dest_;$/;"	m	class:NewLibSender	access:private
OCTAVES	fasthessian.h	/^static const int OCTAVES = 4;$/;"	v
Octave	fasthessian.cpp	/^Octave::Octave(Surf* surf, int oid) :$/;"	f	class:Octave	signature:(Surf* surf, int oid)
Octave	fasthessian.h	/^class Octave {$/;"	c
Octave::BorderAdj	fasthessian.h	/^	static const int TLBorder = 5, RBBorder = 4, BorderAdj = 2;		\/\/ border & adjustment for layer 3$/;"	m	class:Octave	access:private
Octave::Octave	fasthessian.cpp	/^Octave::Octave(Surf* surf, int oid) :$/;"	f	class:Octave	signature:(Surf* surf, int oid)
Octave::RBBorder	fasthessian.h	/^	static const int TLBorder = 5, RBBorder = 4, BorderAdj = 2;		\/\/ border & adjustment for layer 3$/;"	m	class:Octave	access:private
Octave::RPos	fasthessian.h	/^	struct RPos { int i, r, c; };$/;"	s	class:Octave	access:public
Octave::RPos::c	fasthessian.h	/^	struct RPos { int i, r, c; };$/;"	m	struct:Octave::RPos	access:public
Octave::RPos::i	fasthessian.h	/^	struct RPos { int i, r, c; };$/;"	m	struct:Octave::RPos	access:public
Octave::RPos::r	fasthessian.h	/^	struct RPos { int i, r, c; };$/;"	m	struct:Octave::RPos	access:public
Octave::TLBorder	fasthessian.h	/^	static const int TLBorder = 5, RBBorder = 4, BorderAdj = 2;		\/\/ border & adjustment for layer 3$/;"	m	class:Octave	access:private
Octave::buildHessian	fasthessian.cpp	/^void Octave::buildHessian(bool mt) {$/;"	f	class:Octave	signature:(bool mt)
Octave::filterBase	fasthessian.h	/^	int filterBase(int i) const { return layers_[i].filterBase(); }$/;"	f	class:Octave	access:private	signature:(int i) const
Octave::getIpoints	fasthessian.cpp	/^void Octave::getIpoints(bool mt) {$/;"	f	class:Octave	signature:(bool mt)
Octave::img	fasthessian.cpp	/^inline const IntImage& Octave::img() const { return surf_->img(); }$/;"	f	class:Octave	signature:() const
Octave::interpolateExtremum	fasthessian.cpp	/^void Octave::interpolateExtremum(RPos p) {$/;"	f	class:Octave	signature:(RPos p)
Octave::ipointsThread1	fasthessian.cpp	/^void Octave::ipointsThread1(int tid) {$/;"	f	class:Octave	signature:(int tid)
Octave::ipointsThread2	fasthessian.cpp	/^void Octave::ipointsThread2(int tid) {$/;"	f	class:Octave	signature:(int tid)
Octave::isExtremum	fasthessian.cpp	/^bool Octave::isExtremum(RPos p) {$/;"	f	class:Octave	signature:(RPos p)
Octave::laplacian	fasthessian.h	/^	float laplacian(int i, int r, int c) const { return layers_[i].laplacian(r, c); }$/;"	f	class:Octave	access:private	signature:(int i, int r, int c) const
Octave::layers_	fasthessian.h	/^	ResponseLayer layers_[INTERVALS];$/;"	m	class:Octave	access:private
Octave::rHeight	fasthessian.h	/^	int rWidth, rHeight;		\/\/ response size$/;"	m	class:Octave	access:private
Octave::rOffset	fasthessian.h	/^	int rOffset;				\/\/ TLBorder * step$/;"	m	class:Octave	access:private
Octave::rWidth	fasthessian.h	/^	int rWidth, rHeight;		\/\/ response size$/;"	m	class:Octave	access:private
Octave::response	fasthessian.h	/^	float response(RPos p) const { return response(p.i, p.r, p.c); }$/;"	f	class:Octave	access:private	signature:(RPos p) const
Octave::response	fasthessian.h	/^	float response(int i, int r, int c)  const { return layers_[i].response(r, c); }$/;"	f	class:Octave	access:private	signature:(int i, int r, int c) const
Octave::step	fasthessian.h	/^	int step;$/;"	m	class:Octave	access:private
Octave::surf_	fasthessian.h	/^	Surf* surf_;$/;"	m	class:Octave	access:private
PACKET_HANDLE_CENTER_HPP	packet_handle_center.hpp	2;"	d
PACKET_HPP	packet.hpp	2;"	d
PACKET_MSG	packet_handle_center.cpp	9;"	d	file:
POINT_ALL_END	comm_para.hpp	/^	const u_char      POINT_ALL_END       = 0x64;$/;"	m	namespace:__anon2
POINT_END	comm_para.hpp	/^	const u_char      POINT_END           = 0x24;$/;"	m	namespace:__anon2
POINT_MANAGER	point_manager.hpp	2;"	d
POINT_SENDING	comm_para.hpp	/^	const u_char      POINT_SENDING       = 0x04;$/;"	m	namespace:__anon2
POINT_START	comm_para.hpp	/^	const u_char      POINT_START         = 0x14;$/;"	m	namespace:__anon2
PRINT_RANGES	match_analyser.cpp	14;"	d	file:
Packet	packet.hpp	/^typedef CfaUdpPacket       Packet;$/;"	t
PacketHandleCenter	packet_handle_center.cpp	/^PacketHandleCenter::PacketHandleCenter()$/;"	f	class:PacketHandleCenter	signature:()
PacketHandleCenter	packet_handle_center.hpp	/^class PacketHandleCenter$/;"	c
PacketHandleCenter::PacketHandleCenter	packet_handle_center.cpp	/^PacketHandleCenter::PacketHandleCenter()$/;"	f	class:PacketHandleCenter	signature:()
PacketHandleCenter::handle_packet	packet_handle_center.cpp	/^void PacketHandleCenter::handle_packet( PacketPtr p, const udp::endpoint & end_point )$/;"	f	class:PacketHandleCenter	signature:( PacketPtr p, const udp::endpoint & end_point )
PacketHandleCenter::instance	packet_handle_center.hpp	/^	static PacketHandleCenter & instance()$/;"	f	class:PacketHandleCenter	access:public	signature:()
PacketHandleCenter::packet_handle_loop	packet_handle_center.cpp	/^void PacketHandleCenter::packet_handle_loop()$/;"	f	class:PacketHandleCenter	signature:()
PacketHandleCenter::quit_	packet_handle_center.hpp	/^	bool quit_;$/;"	m	class:PacketHandleCenter	access:private
PacketHandleCenter::run	packet_handle_center.cpp	/^void PacketHandleCenter::run()$/;"	f	class:PacketHandleCenter	signature:()
PacketPtr	packet.hpp	/^typedef boost::shared_ptr<CfaUdpPacket> PacketPtr;$/;"	t
PacketQueue	comm_box.hpp	/^class PacketQueue : public Basebox$/;"	c	inherits:Basebox
PacketQueue::capacity	comm_box.hpp	/^	virtual std::size_t capacity()     const$/;"	f	class:PacketQueue	access:public	signature:() const
PacketQueue::get	comm_box.hpp	/^	PacketPtr get()$/;"	f	class:PacketQueue	access:public	signature:()
PacketQueue::num_elements	comm_box.hpp	/^	virtual std::size_t num_elements() const$/;"	f	class:PacketQueue	access:public	signature:() const
PacketQueue::put	comm_box.hpp	/^	void put(PacketPtr p)$/;"	f	class:PacketQueue	access:public	signature:(PacketPtr p)
PacketQueue::queue_	comm_box.hpp	/^	std::queue< PacketPtr > queue_;$/;"	m	class:PacketQueue	access:private
PacketWindow	comm_window.hpp	/^	explicit PacketWindow(const std::string & name_, int timeout = 20)$/;"	f	class:PacketWindow	access:protected	signature:(const std::string & name_, int timeout = 20)
PacketWindow	comm_window.hpp	/^class PacketWindow : public Basebox$/;"	c	inherits:Basebox
PacketWindow::PacketWindow	comm_window.hpp	/^	explicit PacketWindow(const std::string & name_, int timeout = 20)$/;"	f	class:PacketWindow	access:protected	signature:(const std::string & name_, int timeout = 20)
PacketWindow::TIMEOUT	comm_window.hpp	/^	const int TIMEOUT;$/;"	m	class:PacketWindow	access:protected
PacketWindow::acquire	comm_window.hpp	/^	Packet * acquire()$/;"	f	class:PacketWindow	access:public	signature:()
PacketWindow::capacity	comm_window.hpp	/^	virtual std::size_t capacity() const { return N; }$/;"	f	class:PacketWindow	access:public	signature:() const
PacketWindow::circular_buf	comm_window.hpp	/^	std::vector<Packet> circular_buf;$/;"	m	class:PacketWindow	access:protected
PacketWindow::confirm	comm_window.hpp	/^	bool confirm(unsigned char index)$/;"	f	class:PacketWindow	access:public	signature:(unsigned char index)
PacketWindow::consider_timeout	comm_window.hpp	/^	bool consider_timeout;$/;"	m	class:PacketWindow	access:protected
PacketWindow::curr	comm_window.hpp	/^	std::size_t curr;	\/\/ Ö¸Ïòµ±Ç°·¢ËÍµÄ°ü£¬ÓÉget()·µ»Ø$/;"	m	class:PacketWindow	access:protected
PacketWindow::get	comm_window.hpp	/^	Packet * get()$/;"	f	class:PacketWindow	access:public	signature:()
PacketWindow::get_condition_not_satisfied	comm_window.hpp	/^	virtual bool get_condition_not_satisfied() const$/;"	f	class:PacketWindow	access:public	signature:() const
PacketWindow::head	comm_window.hpp	/^	std::size_t head;	\/\/ ¶ÓÁÐÍ·£¬ÓÉconfirmµ÷Õû$/;"	m	class:PacketWindow	access:protected
PacketWindow::name	comm_window.hpp	/^	std::string name;$/;"	m	class:PacketWindow	access:protected
PacketWindow::next	comm_window.hpp	/^	static std::size_t next(std::size_t p) { return (p + 1) % (N + 1); }$/;"	f	class:PacketWindow	access:protected	signature:(std::size_t p)
PacketWindow::num_elements	comm_window.hpp	/^	virtual std::size_t num_elements() const$/;"	f	class:PacketWindow	access:public	signature:() const
PacketWindow::put	comm_window.hpp	/^	void put()$/;"	f	class:PacketWindow	access:public	signature:()
PacketWindow::reset	comm_window.hpp	/^	void reset()$/;"	f	class:PacketWindow	access:public	signature:()
PacketWindow::tail	comm_window.hpp	/^	std::size_t tail;	\/\/ ¶ÓÁÐÎ²£¬Ö¸ÏòÒ»¸ö¿Õ°ü£¬ÓÉacquire()·µ»Ø$/;"	m	class:PacketWindow	access:protected
PointAuxer	point_manager.cpp	/^PointAuxer::PointAuxer (Server * s)$/;"	f	class:PointAuxer	signature:(Server * s)
PointAuxer	point_manager.hpp	/^class PointAuxer$/;"	c
PointAuxer::PointAuxer	point_manager.cpp	/^PointAuxer::PointAuxer (Server * s)$/;"	f	class:PointAuxer	signature:(Server * s)
PointAuxer::end_image	point_manager.cpp	/^void PointAuxer::end_image(int frame)$/;"	f	class:PointAuxer	signature:(int frame)
PointAuxer::handle_packet	point_manager.cpp	/^void PointAuxer::handle_packet( Packet & pkt )$/;"	f	class:PointAuxer	signature:( Packet & pkt )
PointAuxer::image	point_manager.hpp	/^	typedef match_image image;$/;"	t	class:PointAuxer	access:public
PointAuxer::img_	point_manager.hpp	/^	image * img_;$/;"	m	class:PointAuxer	access:private
PointAuxer::server_	point_manager.hpp	/^	Server * server_;$/;"	m	class:PointAuxer	access:private
PutResponse	surf.cpp	/^void SubWins<N, HN>::PutResponse(int rx, int ry, float gauss) {$/;"	f	class:__anon1::SubWins	signature:(int rx, int ry, float gauss)
RANDOM_LOOP	match_stream.hpp	/^	enum GEN_MODE { SEQUENCE, RANDOM_LOOP };$/;"	e	enum:GrayImageGenerator::GEN_MODE
RAW_HEAD_SIZE	packet.hpp	/^	RAW_HEAD_SIZE = 14,$/;"	e	enum:__anon6
RAW_MAX_DATA_LEN	packet.hpp	/^	RAW_MAX_DATA_LEN     = RAW_MAX_LOAD_LEN - 2,		\/\/ 1498$/;"	e	enum:__anon6
RAW_MAX_LOAD_LEN	packet.hpp	/^	RAW_MAX_LOAD_LEN     = ETH_MAX_LEN - RAW_HEAD_SIZE,		\/\/ 1500$/;"	e	enum:__anon6
RAW_MIN_DATA_LEN	packet.hpp	/^	RAW_MIN_DATA_LEN     = RAW_MIN_LOAD_LEN - 2,		\/\/ 44$/;"	e	enum:__anon6
RAW_MIN_LOAD_LEN	packet.hpp	/^	RAW_MIN_LOAD_LEN     = ETH_MIN_LEN - RAW_HEAD_SIZE,		\/\/ 46$/;"	e	enum:__anon6
RBBorder	fasthessian.h	/^	static const int TLBorder = 5, RBBorder = 4, BorderAdj = 2;		\/\/ border & adjustment for layer 3$/;"	m	class:Octave	access:private
READY	matcher_manager.hpp	/^		READY,							\/\/<! ready waiting data$/;"	e	enum:Matcher::MATCHER_STATE
RECEIVING	matcher_manager.hpp	/^		RECEIVING,						\/\/<! receiving data$/;"	e	enum:Matcher::MATCHER_STATE
RESPONSED	matcher_manager.hpp	/^		RESPONSED,						\/\/<! last packet responsed $/;"	e	enum:Matcher::COMM_STATE
RPos	fasthessian.h	/^	struct RPos { int i, r, c; };$/;"	s	class:Octave	access:public
RandomGetBox	comm_box.hpp	/^	RandomGetBox()$/;"	f	class:RandomGetBox	access:public	signature:()
RandomGetBox	comm_box.hpp	/^class RandomGetBox : public Basebox$/;"	c	inherits:Basebox
RandomGetBox::RandomGetBox	comm_box.hpp	/^	RandomGetBox()$/;"	f	class:RandomGetBox	access:public	signature:()
RandomGetBox::acquire	comm_box.hpp	/^	T * acquire()$/;"	f	class:RandomGetBox	access:public	signature:()
RandomGetBox::buff	comm_box.hpp	/^	std::vector< T > buff;$/;"	m	class:RandomGetBox	access:protected
RandomGetBox::capacity	comm_box.hpp	/^	virtual std::size_t capacity()     const { return N; }$/;"	f	class:RandomGetBox	access:public	signature:() const
RandomGetBox::curr	comm_box.hpp	/^	int curr;$/;"	m	class:RandomGetBox	access:protected
RandomGetBox::get	comm_box.hpp	/^	bool get(std::vector< T > & snk)$/;"	f	class:RandomGetBox	access:public	signature:(std::vector< T > & snk)
RandomGetBox::indexes_type	comm_box.hpp	/^	typedef std::vector<std::size_t> indexes_type;$/;"	t	class:RandomGetBox	access:public
RandomGetBox::num_elements	comm_box.hpp	/^	virtual std::size_t num_elements() const { return curr; }$/;"	f	class:RandomGetBox	access:public	signature:() const
RandomGetBox::put	comm_box.hpp	/^	void put()$/;"	f	class:RandomGetBox	access:public	signature:()
RandomGetBox::tail	comm_box.hpp	/^	int tail;$/;"	m	class:RandomGetBox	access:protected
Range	fdutils.h	/^	Range(int b, int e) : begin(b), end(e) {}$/;"	f	struct:Range	access:public	signature:(int b, int e)
Range	fdutils.h	/^	Range(int e) : begin(0), end(e) {}$/;"	f	struct:Range	access:public	signature:(int e)
Range	fdutils.h	/^struct Range {$/;"	s
Range::Range	fdutils.h	/^	Range(int b, int e) : begin(b), end(e) {}$/;"	f	struct:Range	access:public	signature:(int b, int e)
Range::Range	fdutils.h	/^	Range(int e) : begin(0), end(e) {}$/;"	f	struct:Range	access:public	signature:(int e)
Range::begin	fdutils.h	/^	int begin, end;$/;"	m	struct:Range	access:public
Range::end	fdutils.h	/^	int begin, end;$/;"	m	struct:Range	access:public
RawPacket	packet.hpp	/^	RawPacket (int len = RAW_MAX_DATA_LEN)$/;"	f	class:RawPacket	access:public	signature:(int len = RAW_MAX_DATA_LEN)
RawPacket	packet.hpp	/^	RawPacket (int len, u_char type, u_char idx)$/;"	f	class:RawPacket	access:public	signature:(int len, u_char type, u_char idx)
RawPacket	packet.hpp	/^	RawPacket (int len, u_char type, u_char idx, const eth::address& src, const eth::address& snk)$/;"	f	class:RawPacket	access:public	signature:(int len, u_char type, u_char idx, const eth::address& src, const eth::address& snk)
RawPacket	packet.hpp	/^class RawPacket : public raw_packet_base__$/;"	c	inherits:raw_packet_base__
RawPacket::RawPacket	packet.hpp	/^	RawPacket (int len = RAW_MAX_DATA_LEN)$/;"	f	class:RawPacket	access:public	signature:(int len = RAW_MAX_DATA_LEN)
RawPacket::RawPacket	packet.hpp	/^	RawPacket (int len, u_char type, u_char idx)$/;"	f	class:RawPacket	access:public	signature:(int len, u_char type, u_char idx)
RawPacket::RawPacket	packet.hpp	/^	RawPacket (int len, u_char type, u_char idx, const eth::address& src, const eth::address& snk)$/;"	f	class:RawPacket	access:public	signature:(int len, u_char type, u_char idx, const eth::address& src, const eth::address& snk)
RawResponPacket	packet.hpp	/^	RawResponPacket()$/;"	f	class:RawResponPacket	access:public	signature:()
RawResponPacket	packet.hpp	/^	RawResponPacket(u_char type, u_char idx, const eth::address& src, const eth::address& snk, u_char ctrl = 0x00)$/;"	f	class:RawResponPacket	access:public	signature:(u_char type, u_char idx, const eth::address& src, const eth::address& snk, u_char ctrl = 0x00)
RawResponPacket	packet.hpp	/^	RawResponPacket(u_char type, u_char idx, u_char ctrl = 0x00)$/;"	f	class:RawResponPacket	access:public	signature:(u_char type, u_char idx, u_char ctrl = 0x00)
RawResponPacket	packet.hpp	/^class RawResponPacket : public raw_response_packet_base__$/;"	c	inherits:raw_response_packet_base__
RawResponPacket::RawResponPacket	packet.hpp	/^	RawResponPacket()$/;"	f	class:RawResponPacket	access:public	signature:()
RawResponPacket::RawResponPacket	packet.hpp	/^	RawResponPacket(u_char type, u_char idx, const eth::address& src, const eth::address& snk, u_char ctrl = 0x00)$/;"	f	class:RawResponPacket	access:public	signature:(u_char type, u_char idx, const eth::address& src, const eth::address& snk, u_char ctrl = 0x00)
RawResponPacket::RawResponPacket	packet.hpp	/^	RawResponPacket(u_char type, u_char idx, u_char ctrl = 0x00)$/;"	f	class:RawResponPacket	access:public	signature:(u_char type, u_char idx, u_char ctrl = 0x00)
ResponPacket	packet.hpp	/^typedef CfaUdpResponPacket ResponPacket;$/;"	t
ResponseLayer	fasthessian.h	/^	ResponseLayer() {}$/;"	f	class:ResponseLayer	access:public	signature:()
ResponseLayer	fasthessian.h	/^class ResponseLayer {$/;"	c
ResponseLayer::ResponseLayer	fasthessian.h	/^	ResponseLayer() {}$/;"	f	class:ResponseLayer	access:public	signature:()
ResponseLayer::build	fasthessian.cpp	/^void ResponseLayer::build(const Octave* oct, int fb, bool mt) {$/;"	f	class:ResponseLayer	signature:(const Octave* oct, int fb, bool mt)
ResponseLayer::buildThread	fasthessian.cpp	/^void ResponseLayer::buildThread(const Octave* oct, int tid) {$/;"	f	class:ResponseLayer	signature:(const Octave* oct, int tid)
ResponseLayer::filterBase	fasthessian.h	/^	int filterBase() const { return filter_base_; }		\/\/ filter size \/ 3$/;"	f	class:ResponseLayer	access:public	signature:() const
ResponseLayer::filter_base_	fasthessian.h	/^	int filter_base_;$/;"	m	class:ResponseLayer	access:private
ResponseLayer::laplacian	fasthessian.h	/^	float laplacian(int row, int column) const { return laplacian_(row, column); }$/;"	f	class:ResponseLayer	access:public	signature:(int row, int column) const
ResponseLayer::laplacian_	fasthessian.h	/^	Image<unsigned char> laplacian_;$/;"	m	class:ResponseLayer	access:private
ResponseLayer::response	fasthessian.h	/^	float response(int row, int column)  const { return responses_(row, column); }$/;"	f	class:ResponseLayer	access:public	signature:(int row, int column) const
ResponseLayer::responses_	fasthessian.h	/^	Image<float> responses_;$/;"	m	class:ResponseLayer	access:private
Run	ipoint.cpp	/^void Matches<D, I>::Run(bool mt) {$/;"	f	class:Matches	signature:(bool mt)
Run	surf.cpp	/^void Surf::Run(bool mt, int oe) {$/;"	f	class:Surf	signature:(bool mt, int oe)
SENDING	matcher_manager.hpp	/^		SENDING							\/\/<! sending match result$/;"	e	enum:Matcher::MATCHER_STATE
SEND_LIB_PKT_SIZE	comm_para.hpp	/^	const int         SEND_LIB_PKT_SIZE   = 1472;$/;"	m	namespace:__anon2
SEQUENCE	match_stream.hpp	/^	enum GEN_MODE { SEQUENCE, RANDOM_LOOP };$/;"	e	enum:GrayImageGenerator::GEN_MODE
SERVER_HPP	server.hpp	2;"	d
SHIFT	bits.hpp	/^	static const unsigned char SHIFT = 3;$/;"	m	struct:bits	access:public
SURFLIB_H	surflib.h	2;"	d
SURF_H	surf.h	13;"	d
SYNCWORD	comm_para.hpp	/^	const int         SYNCWORD            = 0xFADCCAFD;$/;"	m	namespace:__anon2
SYNCWORD	newlib.h	9;"	d
SYNCWORD	surflib.cpp	13;"	d	file:
SYNCWORD_END	comm_para.hpp	/^	const int         SYNCWORD_END        = 0xAFCDACDF;$/;"	m	namespace:__anon2
SectionManager	match_utils.h	/^class SectionManager {$/;"	c
SectionManager::add_section	match_utils.cpp	/^void SectionManager::add_section(const MatchSection& sec) {$/;"	f	class:SectionManager	signature:(const MatchSection& sec)
SectionManager::chain	match_utils.h	/^	typedef std::list<MatchSection> chain;		\/\/ Ã¿Â·ÊÓÆµµÄÖÐ¼ä½á¹û·ÅÔÚÒ»¸öchainÖÐ$/;"	t	class:SectionManager	access:public
SectionManager::chains_	match_utils.h	/^	std::map<int, chain> chains_;			\/\/ Í¬Ê±´¦Àí¶àÂ·ÊÓÆµ$/;"	m	class:SectionManager	access:private
SectionManager::clear	match_utils.h	/^	void clear() { chains_.clear(); }$/;"	f	class:SectionManager	access:public	signature:()
SectionManager::delete_chain	match_utils.h	/^	void delete_chain(int id) { chains_.erase(id); }$/;"	f	class:SectionManager	access:public	signature:(int id)
SectionManager::output_chain	match_utils.cpp	/^void SectionManager::output_chain(ostream& out, int id) {$/;"	f	class:SectionManager	signature:(ostream& out, int id)
Server	server.hpp	/^	Server (CommArg * arg)$/;"	f	class:Server	access:public	signature:(CommArg * arg)
Server	server.hpp	/^class Server : public boost::noncopyable$/;"	c	inherits:boost::noncopyable
Server::Server	server.hpp	/^	Server (CommArg * arg)$/;"	f	class:Server	access:public	signature:(CommArg * arg)
Server::addr	server.hpp	/^	const boost::asio::ip::address addr() const { return local_point_.address(); }$/;"	f	class:Server	access:public	signature:() const
Server::all_comm_end	server.cpp	/^bool Server::all_comm_end() const$/;"	f	class:Server	signature:() const
Server::all_comm_end_	server.hpp	/^	bool all_comm_end_;									\/\/ all communicatioin end flag$/;"	m	class:Server	access:private
Server::arg	server.hpp	/^	CommArg * arg() { return arg_; }$/;"	f	class:Server	access:public	signature:()
Server::arg_	server.hpp	/^	CommArg * arg_;									   	\/\/ arg$/;"	m	class:Server	access:private
Server::broad_points_all_sent	server.hpp	/^	bool broad_points_all_sent() const { return broad_points_all_sent_; }$/;"	f	class:Server	access:public	signature:() const
Server::broad_points_all_sent_	server.hpp	/^	bool broad_points_all_sent_;$/;"	m	class:Server	access:private
Server::construct_server	server.hpp	/^	static void construct_server( CommArg * arg )$/;"	f	class:Server	access:public	signature:( CommArg * arg )
Server::deadline_	server.hpp	/^	boost::asio::deadline_timer deadline_;              \/\/ timer for getting mac$/;"	m	class:Server	access:private
Server::end_point_	server.hpp	/^	boost::asio::ip::udp::endpoint end_point_;			\/\/ receive endpoint$/;"	m	class:Server	access:private
Server::extract_mac_got_	server.hpp	/^	bool extract_mac_got_;								\/\/ used in getting mac$/;"	m	class:Server	access:private
Server::extracter_busy	server.cpp	/^bool Server::extracter_busy() const$/;"	f	class:Server	signature:() const
Server::extracter_busy_	server.hpp	/^	bool extracter_busy_;$/;"	m	class:Server	access:private
Server::gray_image_window	server.hpp	/^	GrayImageWindow    * gray_image_window()   { return &gray_image_window_; }	$/;"	f	class:Server	access:public	signature:()
Server::gray_image_window_	server.hpp	/^	GrayImageWindow       gray_image_window_;			\/\/ window for sending gray image$/;"	m	class:Server	access:private
Server::gray_img_all_sent	server.hpp	/^	bool gray_img_all_sent() const { return gray_img_all_sent_; }$/;"	f	class:Server	access:public	signature:() const
Server::gray_img_all_sent_	server.hpp	/^	bool gray_img_all_sent_;$/;"	m	class:Server	access:private
Server::gray_img_generator	server.hpp	/^	GrayImageGenerator * gray_img_generator()  const { return gray_img_generator_; }$/;"	f	class:Server	access:public	signature:() const
Server::gray_img_generator_	server.hpp	/^	GrayImageGenerator * gray_img_generator_;$/;"	m	class:Server	access:private
Server::gray_img_loader	server.hpp	/^	GrayImageLoader    * gray_img_loader()     const { return gray_img_loader_; }$/;"	f	class:Server	access:public	signature:() const
Server::gray_img_loader_	server.hpp	/^	GrayImageLoader    * gray_img_loader_;$/;"	m	class:Server	access:private
Server::gray_img_sender	server.hpp	/^	GrayImageSender    * gray_img_sender()     const { return gray_img_sender_; }$/;"	f	class:Server	access:public	signature:() const
Server::gray_img_sender_	server.hpp	/^	GrayImageSender    * gray_img_sender_;$/;"	m	class:Server	access:private
Server::image_gen_box	server.hpp	/^	ImageGenBox        * image_gen_box()       { return &image_gen_box_; }$/;"	f	class:Server	access:public	signature:()
Server::image_gen_box_	server.hpp	/^	ImageGenBox           image_gen_box_;				\/\/ gray image gen box$/;"	m	class:Server	access:private
Server::image_points_all_sent	server.hpp	/^	bool image_points_all_sent() const { return image_points_all_sent_; }$/;"	f	class:Server	access:public	signature:() const
Server::image_points_all_sent_	server.hpp	/^	bool image_points_all_sent_;$/;"	m	class:Server	access:private
Server::image_points_loader	server.hpp	/^	ImagePointsLoader  * image_points_loader() const { return image_points_loader_; }$/;"	f	class:Server	access:public	signature:() const
Server::image_points_loader_	server.hpp	/^	ImagePointsLoader  * image_points_loader_;$/;"	m	class:Server	access:private
Server::image_points_sender	server.hpp	/^	ImagePointsSender  * image_points_sender() const { return image_points_sender_; }$/;"	f	class:Server	access:public	signature:() const
Server::image_points_sender_	server.hpp	/^	ImagePointsSender  * image_points_sender_;$/;"	m	class:Server	access:private
Server::image_points_window	server.hpp	/^	ImagePointsWindow  * image_points_window() { return &image_points_window_; }	$/;"	f	class:Server	access:public	signature:()
Server::image_points_window_	server.hpp	/^	ImagePointsWindow     image_points_window_;			\/\/ window for sending image points$/;"	m	class:Server	access:private
Server::instance	server.hpp	/^	static Server & instance()$/;"	f	class:Server	access:public	signature:()
Server::io	server.hpp	/^	boost::asio::io_service & io() { return io_; }$/;"	f	class:Server	access:public	signature:()
Server::io_	server.hpp	/^	boost::asio::io_service io_;                        \/\/ io service$/;"	m	class:Server	access:private
Server::local_endpoint	server.hpp	/^	const udp::endpoint  local_endpoint() const { return local_point_; }$/;"	f	class:Server	access:public	signature:() const
Server::local_point_	server.hpp	/^	boost::asio::ip::udp::endpoint local_point_;				$/;"	m	class:Server	access:private
Server::mark_all_comm_end	server.cpp	/^void Server::mark_all_comm_end()$/;"	f	class:Server	signature:()
Server::mark_broad_points_all_sent	server.hpp	/^	void mark_broad_points_all_sent() { broad_points_all_sent_ = true; }$/;"	f	class:Server	access:public	signature:()
Server::mark_gray_image_all_sent	server.hpp	/^	void mark_gray_image_all_sent() { gray_img_all_sent_ = true; }$/;"	f	class:Server	access:public	signature:()
Server::mark_image_points_all_sent	server.hpp	/^	void mark_image_points_all_sent() { image_points_all_sent_ = true; }$/;"	f	class:Server	access:public	signature:()
Server::match_image_box	server.hpp	/^	MatchImageBox      * match_image_box()     { return &match_image_box_; }$/;"	f	class:Server	access:public	signature:()
Server::match_image_box_	server.hpp	/^	MatchImageBox         match_image_box_;				\/\/ match image box$/;"	m	class:Server	access:private
Server::matcher_busy_	server.hpp	/^	bool matcher_busy_;$/;"	m	class:Server	access:private
Server::open_services	server.cpp	/^void Server::open_services()$/;"	f	class:Server	signature:()
Server::packet_queue	server.hpp	/^	PacketQueue        * packet_queue()        { return &pkt_queue_; }$/;"	f	class:Server	access:public	signature:()
Server::pkt_queue_	server.hpp	/^	PacketQueue           pkt_queue_;$/;"	m	class:Server	access:private
Server::point_man	server.hpp	/^	point_manager      * point_man() { return &point_man_; }$/;"	f	class:Server	access:public	signature:()
Server::point_man_	server.hpp	/^    point_manager point_man_;							  \/\/ point manager$/;"	m	class:Server	access:private
Server::port	server.hpp	/^	unsigned short                 port() const { return local_point_.port(); }$/;"	f	class:Server	access:public	signature:() const
Server::quit_wanted_	server.hpp	/^	bool quit_wanted_;$/;"	m	class:Server	access:private
Server::recv_buffer_	server.hpp	/^	boost::asio::mutable_buffers_1 recv_buffer_;        \/\/ receive asio buffer$/;"	m	class:Server	access:private
Server::recv_diverse_handler	server.cpp	/^void Server::recv_diverse_handler(const error_code& ec, size_t length)$/;"	f	class:Server	signature:(const error_code& ec, size_t length)
Server::recv_pkt_	server.hpp	/^	Packet recv_pkt_;                                   \/\/ receive packet buffer$/;"	m	class:Server	access:private
Server::send	server.cpp	/^void Server::send( const boost::asio::mutable_buffers_1 & buffer, const udp::endpoint & dest )$/;"	f	class:Server	signature:( const boost::asio::mutable_buffers_1 & buffer, const udp::endpoint & dest )
Server::send_handler	server.cpp	/^void Server::send_handler(const error_code& ec, size_t length)$/;"	f	class:Server	signature:(const error_code& ec, size_t length)
Server::send_sock_	server.hpp	/^	boost::asio::ip::udp::socket send_sock_;            \/\/ main thread socket$/;"	m	class:Server	access:private
Server::server_	server.hpp	/^	static Server * server_;$/;"	m	class:Server	access:private
Server::set_extracter_busy	server.cpp	/^void Server::set_extracter_busy( bool b )$/;"	f	class:Server	signature:( bool b )
Server::socket_	server.hpp	/^	boost::asio::ip::udp::socket socket_;               \/\/ main thread socket$/;"	m	class:Server	access:private
Server::start_main	server.cpp	/^void Server::start_main()$/;"	f	class:Server	signature:()
Server::start_match_stream	server.cpp	/^void Server::start_match_stream()$/;"	f	class:Server	signature:()
Server::surf_lib_loader	server.hpp	/^	SurfLibLoader      * surf_lib_loader()     const { return surf_lib_loader_; }$/;"	f	class:Server	access:public	signature:() const
Server::surf_lib_loader_	server.hpp	/^	SurfLibLoader      * surf_lib_loader_;$/;"	m	class:Server	access:private
Server::surf_lib_sender	server.hpp	/^	SurfLibSender      * surf_lib_sender()     const { return surf_lib_sender_; }$/;"	f	class:Server	access:public	signature:() const
Server::surf_lib_sender_	server.hpp	/^	SurfLibSender      * surf_lib_sender_;$/;"	m	class:Server	access:private
Server::surf_lib_window	server.hpp	/^	SurfLibWindow      * surf_lib_window()     { return &surf_lib_window_; }	$/;"	f	class:Server	access:public	signature:()
Server::surf_lib_window_	server.hpp	/^	SurfLibWindow         surf_lib_window_;				\/\/ window for sending surf lib points$/;"	m	class:Server	access:private
Server::wanna_quit	server.hpp	/^	bool wanna_quit() const { return quit_wanted_; }$/;"	f	class:Server	access:public	signature:() const
StepWindow	comm_window.hpp	/^typedef PacketWindow<1> StepWindow;$/;"	t
StreamLine	match_stream.hpp	/^class StreamLine$/;"	c
StreamLine::add_node	match_stream.hpp	/^	void add_node(StreamNode * node)$/;"	f	class:StreamLine	access:public	signature:(StreamNode * node)
StreamLine::nodes_	match_stream.hpp	/^	std::vector< StreamNode * > nodes_;$/;"	m	class:StreamLine	access:private
StreamLine::start_running_stream	match_stream.hpp	/^	void start_running_stream()$/;"	f	class:StreamLine	access:public	signature:()
StreamLine::tg	match_stream.hpp	/^	boost::thread_group tg;$/;"	m	class:StreamLine	access:private
StreamLine::wait_stream_end	match_stream.hpp	/^	void wait_stream_end()$/;"	f	class:StreamLine	access:public	signature:()
StreamLine::~StreamLine	match_stream.hpp	/^	~StreamLine()$/;"	f	class:StreamLine	access:public	signature:()
StreamNode	match_stream.hpp	/^	StreamNode()$/;"	f	class:StreamNode	access:public	signature:()
StreamNode	match_stream.hpp	/^class StreamNode$/;"	c
StreamNode::StreamNode	match_stream.hpp	/^	StreamNode()$/;"	f	class:StreamNode	access:public	signature:()
StreamNode::run	match_stream.hpp	/^	void run()$/;"	f	class:StreamNode	access:public	signature:()
StreamNode::~StreamNode	match_stream.hpp	/^	virtual ~StreamNode() {}$/;"	f	class:StreamNode	access:public	signature:()
SubWins	surf.cpp	/^SubWins<N, HN>::SubWins() {		\/\/ initialize the tangent table$/;"	f	class:__anon1::SubWins	signature:()
SubWins	surf.cpp	/^class SubWins {$/;"	c	namespace:__anon1	file:
Surf	surf.h	/^	Surf(const GrayImage& img, float thres = THRES, int pipts = 0)$/;"	f	class:Surf	access:public	signature:(const GrayImage& img, float thres = THRES, int pipts = 0)
Surf	surf.h	/^	Surf(const IplImage* img, float thres = THRES, int pipts = 0)$/;"	f	class:Surf	access:public	signature:(const IplImage* img, float thres = THRES, int pipts = 0)
Surf	surf.h	/^	Surf(float thres = THRES) : thres_(thres) {}$/;"	f	class:Surf	access:public	signature:(float thres = THRES)
Surf	surf.h	/^class Surf {$/;"	c
Surf::Run	surf.cpp	/^void Surf::Run(bool mt, int oe) {$/;"	f	class:Surf	signature:(bool mt, int oe)
Surf::Surf	surf.h	/^	Surf(const GrayImage& img, float thres = THRES, int pipts = 0)$/;"	f	class:Surf	access:public	signature:(const GrayImage& img, float thres = THRES, int pipts = 0)
Surf::Surf	surf.h	/^	Surf(const IplImage* img, float thres = THRES, int pipts = 0)$/;"	f	class:Surf	access:public	signature:(const IplImage* img, float thres = THRES, int pipts = 0)
Surf::Surf	surf.h	/^	Surf(float thres = THRES) : thres_(thres) {}$/;"	f	class:Surf	access:public	signature:(float thres = THRES)
Surf::addIpoint	surf.cpp	/^void Surf::addIpoint(float x, float y, float s, int l) {$/;"	f	class:Surf	signature:(float x, float y, float s, int l)
Surf::descriptorThread	surf.cpp	/^void Surf::descriptorThread(int tid) {$/;"	f	class:Surf	signature:(int tid)
Surf::done	surf.h	/^	bool   done() const { return pipts_ > 0 && size() > pipts_; }$/;"	f	class:Surf	access:public	signature:() const
Surf::getDescriptor	surf.cpp	/^void Surf::getDescriptor(Ipoint& ipt) {$/;"	f	class:Surf	signature:(Ipoint& ipt)
Surf::getOrientation	surf.cpp	/^void Surf::getOrientation(Ipoint& ipt) {$/;"	f	class:Surf	signature:(Ipoint& ipt)
Surf::haarX	surf.cpp	/^inline int Surf::haarX(int row, int col, int s) {$/;"	f	class:Surf	signature:(int row, int col, int s)
Surf::haarY	surf.cpp	/^inline int Surf::haarY(int row, int col, int s) {$/;"	f	class:Surf	signature:(int row, int col, int s)
Surf::img	surf.h	/^	const IntImage& img() const { return img_;   }$/;"	f	class:Surf	access:public	signature:() const
Surf::img_	surf.h	/^	IntImage img_;	\/\/! Integral image where Ipoints have been detected$/;"	m	class:Surf	access:private
Surf::init	surf.h	/^	void init(const GrayImage& img) { img_.init(img);            ipts_.clear(); }$/;"	f	class:Surf	access:public	signature:(const GrayImage& img)
Surf::init	surf.h	/^	void init(const IplImage* img)  { img_.init(GrayImage(img)); ipts_.clear(); }$/;"	f	class:Surf	access:public	signature:(const IplImage* img)
Surf::ipts	surf.h	/^	IpVec& ipts()               { return ipts_;  }	\/\/! Get the Ipoints vector$/;"	f	class:Surf	access:public	signature:()
Surf::ipts_	surf.h	/^	IpVec ipts_;	\/\/! Ipoints vector$/;"	m	class:Surf	access:private
Surf::pipts	surf.h	/^	int    pipts()        const { return pipts_; }$/;"	f	class:Surf	access:public	signature:() const
Surf::pipts_	surf.h	/^	int   pipts_;	\/\/! preferred Ipoints number$/;"	m	class:Surf	access:private
Surf::size	surf.h	/^	int    size()         const { return ipts_.size(); }$/;"	f	class:Surf	access:public	signature:() const
Surf::thres_	surf.h	/^	float thres_;	\/\/! blob response threshold$/;"	m	class:Surf	access:private
Surf::threshold	surf.h	/^	float  threshold()    const { return thres_; }$/;"	f	class:Surf	access:public	signature:() const
SurfLib	surflib.h	/^typedef std::deque<SurfLibRec> SurfLib;$/;"	t
SurfLibLoader	match_stream.hpp	/^class SurfLibLoader : public StreamNode$/;"	c	inherits:StreamNode
SurfLibLoader::big_file	match_stream.hpp	/^	BigLibFile big_file;$/;"	m	class:SurfLibLoader	access:private
SurfLibRec	surflib.h	/^struct SurfLibRec {$/;"	s
SurfLibRec::iptsVec	surflib.h	/^	LibIpVec iptsVec;$/;"	m	struct:SurfLibRec	access:public
SurfLibRec::num	surflib.h	/^	int num;$/;"	m	struct:SurfLibRec	access:public
SurfLibSender	match_stream.hpp	/^class SurfLibSender : public StreamNode$/;"	c	inherits:StreamNode
SurfLibSender::dest_	match_stream.hpp	/^	const endpoint dest_;$/;"	m	class:SurfLibSender	access:private
SurfLibWindow	comm_window.hpp	/^	explicit SurfLibWindow(int timeout = 20)$/;"	f	class:SurfLibWindow	access:public	signature:(int timeout = 20)
SurfLibWindow	comm_window.hpp	/^class SurfLibWindow : public surf_lib_window_base__$/;"	c	inherits:surf_lib_window_base__
SurfLibWindow::SurfLibWindow	comm_window.hpp	/^	explicit SurfLibWindow(int timeout = 20)$/;"	f	class:SurfLibWindow	access:public	signature:(int timeout = 20)
SwapOp	comm_box.hpp	/^struct SwapOp : public std::binary_function< T, T, void >$/;"	s	inherits:std::binary_function
SwapOp::operator ()	comm_box.hpp	/^	void operator () (T & lhs, T & rhs)$/;"	f	struct:SwapOp	access:public	signature:(T & lhs, T & rhs)
THRES	surf.h	/^static const float THRES = 0.0004f;$/;"	v
TIMEOUT	comm_window.hpp	/^	const int TIMEOUT;$/;"	m	class:PacketWindow	access:protected
TLBorder	fasthessian.h	/^	static const int TLBorder = 5, RBBorder = 4, BorderAdj = 2;		\/\/ border & adjustment for layer 3$/;"	m	class:Octave	access:private
UDP_HEAD_SIZE	packet.hpp	/^	UDP_HEAD_SIZE = 42,$/;"	e	enum:__anon6
UDP_MAX_DATA_LEN	packet.hpp	/^	UDP_MAX_DATA_LEN     = UDP_MAX_LOAD_LEN - 2,		\/\/ 1470$/;"	e	enum:__anon6
UDP_MAX_LOAD_LEN	packet.hpp	/^	UDP_MAX_LOAD_LEN     = ETH_MAX_LEN - UDP_HEAD_SIZE,		\/\/ 1472$/;"	e	enum:__anon6
UDP_MIN_DATA_LEN	packet.hpp	/^	UDP_MIN_DATA_LEN     = UDP_MIN_LOAD_LEN - 2,		\/\/ 16$/;"	e	enum:__anon6
UDP_MIN_LOAD_LEN	packet.hpp	/^	UDP_MIN_LOAD_LEN     = ETH_MIN_LEN - UDP_HEAD_SIZE,		\/\/ 18$/;"	e	enum:__anon6
UNCONNECTED	matcher_manager.hpp	/^		UNCONNECTED,					\/\/<! unconnected default state$/;"	e	enum:Matcher::MATCHER_STATE
UNRESPONSED	matcher_manager.hpp	/^		UNRESPONSED						\/\/<! last packet not responsed$/;"	e	enum:Matcher::COMM_STATE
UTILS	utils.h	/^namespace UTILS$/;"	n
UTILS::image	utils.h	/^	struct image$/;"	s	namespace:UTILS
UTILS::image::add_descriptor	utils.h	/^		void add_descriptor(descriptor_type v)$/;"	f	struct:UTILS::image	access:public	signature:(descriptor_type v)
UTILS::image::buff	utils.h	/^		point buff;$/;"	m	struct:UTILS::image	access:private
UTILS::image::check_end_image	utils.h	/^		void check_end_image()$/;"	f	struct:UTILS::image	access:public	signature:()
UTILS::image::frame_index	utils.h	/^		frame_type frame_index;$/;"	m	struct:UTILS::image	access:public
UTILS::image::frame_pos	utils.h	/^		unsigned frame_pos() const { return frame_index & 0x00FFFFFF; }$/;"	f	struct:UTILS::image	access:public	signature:() const
UTILS::image::idx	utils.h	/^		int idx;$/;"	m	struct:UTILS::image	access:private
UTILS::image::image	utils.h	/^		image() : idx(0) {}$/;"	f	struct:UTILS::image	access:public	signature:()
UTILS::image::point	utils.h	/^		struct point$/;"	s	struct:UTILS::image	access:public
UTILS::image::point::descriptor	utils.h	/^			descriptor_type descriptor[64];$/;"	m	struct:UTILS::image::point	access:public
UTILS::image::points	utils.h	/^		std::vector<point> points;$/;"	m	struct:UTILS::image	access:public
UTILS::image::swap	utils.h	/^		void swap(image & other)$/;"	f	struct:UTILS::image	access:public	signature:(image & other)
UTILS::image::video_id	utils.h	/^		unsigned video_id () const { return frame_index >> 24; }$/;"	f	struct:UTILS::image	access:public	signature:() const
UTILS_H	utils.h	13;"	d
VERBOSE	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
VideoCapcture	match_utils.cpp	/^VideoCapcture::VideoCapcture(const string& videoFileName, int capBegin, int capEnd, double capFps)$/;"	f	class:VideoCapcture	signature:(const string& videoFileName, int capBegin, int capEnd, double capFps)
VideoCapcture	match_utils.h	/^struct VideoCapcture {$/;"	s
VideoCapcture::VideoCapcture	match_utils.cpp	/^VideoCapcture::VideoCapcture(const string& videoFileName, int capBegin, int capEnd, double capFps)$/;"	f	class:VideoCapcture	signature:(const string& videoFileName, int capBegin, int capEnd, double capFps)
VideoCapcture::cap_end	match_utils.h	/^	int cap_end;$/;"	m	struct:VideoCapcture	access:private
VideoCapcture::cap_step	match_utils.h	/^	double cap_step;$/;"	m	struct:VideoCapcture	access:private
VideoCapcture::capture	match_utils.h	/^	CvCapture* capture;$/;"	m	struct:VideoCapcture	access:private
VideoCapcture::fps	match_utils.h	/^	double fps;$/;"	m	struct:VideoCapcture	access:public
VideoCapcture::frame_count	match_utils.h	/^	double frame_count;$/;"	m	struct:VideoCapcture	access:public
VideoCapcture::frame_pos	match_utils.h	/^	int frame_pos;$/;"	m	struct:VideoCapcture	access:public
VideoCapcture::get_frame	match_utils.cpp	/^IplImage* VideoCapcture::get_frame() {$/;"	f	class:VideoCapcture	signature:()
VideoCapcture::next_frame	match_utils.h	/^	double next_frame;$/;"	m	struct:VideoCapcture	access:private
VideoCapcture::time_stamp	match_utils.h	/^	double time_stamp;$/;"	m	struct:VideoCapcture	access:public
VideoCapcture::~VideoCapcture	match_utils.cpp	/^VideoCapcture::~VideoCapcture() { cvReleaseCapture(&capture); }$/;"	f	class:VideoCapcture	signature:()
VideoLibRec	newlib.h	/^struct VideoLibRec {$/;"	s
VideoLibRec::num_of_frames	newlib.h	/^	short num_of_frames;$/;"	m	struct:VideoLibRec	access:public
VideoLibRec::point_vec	newlib.h	/^	LibPointVec point_vec;$/;"	m	struct:VideoLibRec	access:public
VideoLibRec::video_num	newlib.h	/^	short video_num;$/;"	m	struct:VideoLibRec	access:public
VideoLibVec	newlib.h	/^typedef std::vector<VideoLibRec> VideoLibVec;$/;"	t
VideoMatchAnalyser	match_analyser.hpp	/^	VideoMatchAnalyser ( unsigned index, const std::string & path , double fps)$/;"	f	class:VideoMatchAnalyser	access:public	signature:( unsigned index, const std::string & path , double fps)
VideoMatchAnalyser	match_analyser.hpp	/^class VideoMatchAnalyser$/;"	c
VideoMatchAnalyser::VideoMatchAnalyser	match_analyser.hpp	/^	VideoMatchAnalyser ( unsigned index, const std::string & path , double fps)$/;"	f	class:VideoMatchAnalyser	access:public	signature:( unsigned index, const std::string & path , double fps)
VideoMatchAnalyser::add_match	match_analyser.cpp	/^void VideoMatchAnalyser::add_match( frame_type matched_frame, frame_type to_match_frame )$/;"	f	class:VideoMatchAnalyser	signature:( frame_type matched_frame, frame_type to_match_frame )
VideoMatchAnalyser::calc_all_pair_ranges	match_analyser.cpp	/^void VideoMatchAnalyser::calc_all_pair_ranges()$/;"	f	class:VideoMatchAnalyser	signature:()
VideoMatchAnalyser::calc_match_result	match_analyser.cpp	/^void VideoMatchAnalyser::calc_match_result()$/;"	f	class:VideoMatchAnalyser	signature:()
VideoMatchAnalyser::calc_match_sections	match_analyser.cpp	/^void VideoMatchAnalyser::calc_match_sections()$/;"	f	class:VideoMatchAnalyser	signature:()
VideoMatchAnalyser::calc_pair_ranges	match_analyser.cpp	/^void VideoMatchAnalyser::calc_pair_ranges(MatchPairs & p, MatchAnalyser::frames_type & frames)$/;"	f	class:VideoMatchAnalyser	signature:(MatchPairs & p, MatchAnalyser::frames_type & frames)
VideoMatchAnalyser::detail_report	match_analyser.hpp	/^	std::ofstream & detail_report()$/;"	f	class:VideoMatchAnalyser	access:private	signature:()
VideoMatchAnalyser::detail_report_	match_analyser.hpp	/^	std::ofstream *           detail_report_;$/;"	m	class:VideoMatchAnalyser	access:private
VideoMatchAnalyser::fps_	match_analyser.hpp	/^	const double fps_;$/;"	m	class:VideoMatchAnalyser	access:private
VideoMatchAnalyser::frames_buffer_type	match_analyser.hpp	/^	typedef std::vector< frames_type >                   frames_buffer_type;$/;"	t	class:VideoMatchAnalyser	access:public
VideoMatchAnalyser::frames_type	match_analyser.hpp	/^	typedef std::vector< frame_type >                    frames_type;$/;"	t	class:VideoMatchAnalyser	access:public
VideoMatchAnalyser::index_	match_analyser.hpp	/^	const unsigned index_;$/;"	m	class:VideoMatchAnalyser	access:private
VideoMatchAnalyser::match_pairs_vec_	match_analyser.hpp	/^	std::vector<MatchPairs>   match_pairs_vec_;$/;"	m	class:VideoMatchAnalyser	access:private
VideoMatchAnalyser::match_sections_	match_analyser.hpp	/^	std::vector<MatchSection> match_sections_;$/;"	m	class:VideoMatchAnalyser	access:private
VideoMatchAnalyser::matchs_map_	match_analyser.hpp	/^	matchs_map_type           matchs_map_;$/;"	m	class:VideoMatchAnalyser	access:private
VideoMatchAnalyser::matchs_map_type	match_analyser.hpp	/^	typedef std::map< frame_type, frames_type >          matchs_map_type;$/;"	t	class:VideoMatchAnalyser	access:public
VideoMatchAnalyser::path_	match_analyser.hpp	/^	const std::string path_;$/;"	m	class:VideoMatchAnalyser	access:private
VideoMatchAnalyser::print_ranges	match_analyser.cpp	/^void VideoMatchAnalyser::print_ranges(std::ostream & out)$/;"	f	class:VideoMatchAnalyser	signature:(std::ostream & out)
VideoMatchAnalyser::print_sections	match_analyser.cpp	/^void VideoMatchAnalyser::print_sections(std::ostream & out)$/;"	f	class:VideoMatchAnalyser	signature:(std::ostream & out)
VideoMatchAnalyser::record_to_match_frame	match_analyser.cpp	/^void VideoMatchAnalyser::record_to_match_frame( frame_type to_match_frame )$/;"	f	class:VideoMatchAnalyser	signature:( frame_type to_match_frame )
VideoMatchAnalyser::try_merge_sections	match_analyser.cpp	/^bool VideoMatchAnalyser::try_merge_sections(MatchSection & lhs, MatchSection & rhs)$/;"	f	class:VideoMatchAnalyser	signature:(MatchSection & lhs, MatchSection & rhs)
VideoMatchAnalyser::write_match_result	match_analyser.cpp	/^void VideoMatchAnalyser::write_match_result( std::ostream & out )$/;"	f	class:VideoMatchAnalyser	signature:( std::ostream & out )
VideoMatchAnalyser::xml_begin_video	match_analyser.cpp	/^void VideoMatchAnalyser::xml_begin_video( std::ostream & out )$/;"	f	class:VideoMatchAnalyser	signature:( std::ostream & out )
VideoMatchAnalyser::xml_end_video	match_analyser.cpp	/^void VideoMatchAnalyser::xml_end_video( std::ostream & out )$/;"	f	class:VideoMatchAnalyser	signature:( std::ostream & out )
VideoMatchAnalyser::xml_match_section	match_analyser.cpp	/^void VideoMatchAnalyser::xml_match_section( std::ostream & out, unsigned index, const MatchSection & sec )$/;"	f	class:VideoMatchAnalyser	signature:( std::ostream & out, unsigned index, const MatchSection & sec )
VideoMatcher	match_utils.h	/^class VideoMatcher {$/;"	c
VideoMatcher::gather_section	match_utils.cpp	/^void VideoMatcher::gather_section(const MatchResult& res) {$/;"	f	class:VideoMatcher	signature:(const MatchResult& res)
VideoMatcher::match_frames	match_utils.cpp	/^void VideoMatcher::match_frames(const VideoLibVec<N>& lib, const LibPointVec<N>& frames, int frame_begin) {$/;"	f	class:VideoMatcher	signature:(const VideoLibVec<N>& lib, const LibPointVec<N>& frames, int frame_begin)
VideoMatcher::match_video	match_utils.cpp	/^void VideoMatcher::match_video(const VideoLibVec<N>& lib, const VideoLibVec<N>& video_to_match) {$/;"	f	class:VideoMatcher	signature:(const VideoLibVec<N>& lib, const VideoLibVec<N>& video_to_match)
VideoMatcher::match_video	match_utils.cpp	/^void VideoMatcher::match_video(const VideoLibVec<N>& lib, const std::string& video_file, int frame_start, int frame_end) {$/;"	f	class:VideoMatcher	signature:(const VideoLibVec<N>& lib, const std::string& video_file, int frame_start, int frame_end)
VideoMatcher::sec_man_	match_utils.h	/^	SectionManager sec_man_;$/;"	m	class:VideoMatcher	access:private
VideoMatcher::vs_	match_utils.h	/^	std::vector<MatchSection> vs_;$/;"	m	class:VideoMatcher	access:private
WAIT_LIB_LOAD	matcher_manager.hpp	/^		WAIT_LIB_LOAD,					\/\/<! connected but lib not loaded$/;"	e	enum:Matcher::MATCHER_STATE
WARN	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	e	enum:LOG::severity_level
Word	bit_feature.h	/^	typedef unsigned int  Word;			\/\/ 32 bit$/;"	t	class:BitFeature	access:public
__anon1::Gaussian	surf.cpp	/^class Gaussian {$/;"	c	namespace:__anon1	file:
__anon1::Gaussian::Gaussian	surf.cpp	/^	Gaussian(float sig) {$/;"	f	class:__anon1::Gaussian	access:public	signature:(float sig)
__anon1::Gaussian::data	surf.cpp	/^	float data[N+1][N+1];$/;"	m	class:__anon1::Gaussian	file:	access:private
__anon1::Gaussian::operator ()	surf.cpp	/^	float operator()(int x, int y) const { return data[abs_(x)][abs_(y)]; }$/;"	f	class:__anon1::Gaussian	access:public	signature:(int x, int y) const
__anon1::SubWins	surf.cpp	/^class SubWins {$/;"	c	namespace:__anon1	file:
__anon1::SubWins::PutResponse	surf.cpp	/^void SubWins<N, HN>::PutResponse(int rx, int ry, float gauss) {$/;"	f	class:__anon1::SubWins	signature:(int rx, int ry, float gauss)
__anon1::SubWins::SubWins	surf.cpp	/^SubWins<N, HN>::SubWins() {		\/\/ initialize the tangent table$/;"	f	class:__anon1::SubWins	signature:()
__anon1::SubWins::reset	surf.cpp	/^	void reset() { for (int i = 0; i < N; ++i) sx[i] = sy[i] = 0.f; }$/;"	f	class:__anon1::SubWins	access:public	signature:()
__anon1::SubWins::sumx	surf.cpp	/^	float sumx(int i) const { return sx[i < N ? i : i - N]; }$/;"	f	class:__anon1::SubWins	access:public	signature:(int i) const
__anon1::SubWins::sumy	surf.cpp	/^	float sumy(int i) const { return sy[i < N ? i : i - N]; }$/;"	f	class:__anon1::SubWins	access:public	signature:(int i) const
__anon1::SubWins::sx	surf.cpp	/^	 float tg[HN-1], sx[N], sy[N];$/;"	m	class:__anon1::SubWins	file:	access:private
__anon1::SubWins::sy	surf.cpp	/^	 float tg[HN-1], sx[N], sy[N];$/;"	m	class:__anon1::SubWins	file:	access:private
__anon1::SubWins::tg	surf.cpp	/^	 float tg[HN-1], sx[N], sy[N];$/;"	m	class:__anon1::SubWins	file:	access:private
__anon1::pi	surf.cpp	/^const float pi = 3.14159265;$/;"	m	namespace:__anon1	file:
__anon2::CONN_BUILD	comm_para.hpp	/^	const u_char      CONN_BUILD          = 0x70;$/;"	m	namespace:__anon2
__anon2::CTRL_PAUSE	comm_para.hpp	/^	const u_char      CTRL_PAUSE          = 0xFF;$/;"	m	namespace:__anon2
__anon2::CTRL_RECOVER	comm_para.hpp	/^	const u_char      CTRL_RECOVER        = 0x00;$/;"	m	namespace:__anon2
__anon2::EXTRACT_END	comm_para.hpp	/^	const u_char      EXTRACT_END         = 0x2C;$/;"	m	namespace:__anon2
__anon2::EXTRACT_RECVING	comm_para.hpp	/^	const u_char      EXTRACT_RECVING     = 0x0C;$/;"	m	namespace:__anon2
__anon2::IMG_ALL_END	comm_para.hpp	/^	const u_char      IMG_ALL_END         = 0x66;$/;"	m	namespace:__anon2
__anon2::IMG_END	comm_para.hpp	/^	const u_char      IMG_END             = 0x26;$/;"	m	namespace:__anon2
__anon2::IMG_SENDING	comm_para.hpp	/^	const u_char      IMG_SENDING         = 0x06;$/;"	m	namespace:__anon2
__anon2::IMG_START	comm_para.hpp	/^	const u_char      IMG_START           = 0x16;$/;"	m	namespace:__anon2
__anon2::LIB_END	comm_para.hpp	/^	const u_char      LIB_END             = 0x22;$/;"	m	namespace:__anon2
__anon2::LIB_SENDING	comm_para.hpp	/^	const u_char      LIB_SENDING         = 0x02;$/;"	m	namespace:__anon2
__anon2::LIB_START	comm_para.hpp	/^	const u_char      LIB_START           = 0x12;$/;"	m	namespace:__anon2
__anon2::MATCH_END	comm_para.hpp	/^	const u_char      MATCH_END           = 0x28;$/;"	m	namespace:__anon2
__anon2::MATCH_RECVING	comm_para.hpp	/^	const u_char      MATCH_RECVING       = 0x08;$/;"	m	namespace:__anon2
__anon2::MATCH_WIDTH	comm_para.hpp	/^	const int         MATCH_WIDTH         = 128;$/;"	m	namespace:__anon2
__anon2::POINT_ALL_END	comm_para.hpp	/^	const u_char      POINT_ALL_END       = 0x64;$/;"	m	namespace:__anon2
__anon2::POINT_END	comm_para.hpp	/^	const u_char      POINT_END           = 0x24;$/;"	m	namespace:__anon2
__anon2::POINT_SENDING	comm_para.hpp	/^	const u_char      POINT_SENDING       = 0x04;$/;"	m	namespace:__anon2
__anon2::POINT_START	comm_para.hpp	/^	const u_char      POINT_START         = 0x14;$/;"	m	namespace:__anon2
__anon2::SEND_LIB_PKT_SIZE	comm_para.hpp	/^	const int         SEND_LIB_PKT_SIZE   = 1472;$/;"	m	namespace:__anon2
__anon2::SYNCWORD	comm_para.hpp	/^	const int         SYNCWORD            = 0xFADCCAFD;$/;"	m	namespace:__anon2
__anon2::SYNCWORD_END	comm_para.hpp	/^	const int         SYNCWORD_END        = 0xAFCDACDF;$/;"	m	namespace:__anon2
__anon4::dist_table	bit_feature.cpp	/^	char dist_table[256] = {$/;"	m	namespace:__anon4	file:
__anon4::order_pairs128	bit_feature.cpp	/^	const int order_pairs128[128][2] = {$/;"	m	namespace:__anon4	file:
__anon4::order_pairs32	bit_feature.cpp	/^	const int order_pairs32[32][2] = {$/;"	m	namespace:__anon4	file:
_def	fdutils.h	/^	const E   _def;$/;"	m	class:EnumStringMap	access:private
_size	fdutils.h	/^	const int _size;$/;"	m	class:EnumStringMap	access:private
_str_table	fdutils.h	/^	const char * const * _str_table;$/;"	m	class:EnumStringMap	access:private
abs_	fdutils.h	/^template<typename T> inline T abs_(T x) { return x >= 0 ? x : -x; }$/;"	f	signature:(T x)
acquire	comm_box.cpp	/^match_image * MatchImageBox::acquire()$/;"	f	class:MatchImageBox	signature:()
acquire	comm_box.hpp	/^	T * acquire()$/;"	f	class:RandomGetBox	access:public	signature:()
acquire	comm_window.hpp	/^	Packet * acquire()$/;"	f	class:PacketWindow	access:public	signature:()
addIpoint	surf.cpp	/^void Surf::addIpoint(float x, float y, float s, int l) {$/;"	f	class:Surf	signature:(float x, float y, float s, int l)
add_descriptor	utils.h	/^		void add_descriptor(descriptor_type v)$/;"	f	struct:UTILS::image	access:public	signature:(descriptor_type v)
add_image	match_analyser.cpp	/^void MatchAnalyser::add_image( frame_type frame, const std::string & path )$/;"	f	class:MatchAnalyser	signature:( frame_type frame, const std::string & path )
add_match	match_analyser.cpp	/^void ImageMatchAnalyser::add_match( frame_type frame )$/;"	f	class:ImageMatchAnalyser	signature:( frame_type frame )
add_match	match_analyser.cpp	/^void MatchAnalyser::add_match( frame_type matched_frame, frame_type frame )$/;"	f	class:MatchAnalyser	signature:( frame_type matched_frame, frame_type frame )
add_match	match_analyser.cpp	/^void VideoMatchAnalyser::add_match( frame_type matched_frame, frame_type to_match_frame )$/;"	f	class:VideoMatchAnalyser	signature:( frame_type matched_frame, frame_type to_match_frame )
add_matcher	matcher_manager.cpp	/^void MatcherManager::add_matcher( MatcherPtr m )$/;"	f	class:MatcherManager	signature:( MatcherPtr m )
add_matcher	matcher_manager.cpp	/^void MatcherManager::add_matcher( MatcherPtr m, Matchers & ms )$/;"	f	class:MatcherManager	signature:( MatcherPtr m, Matchers & ms )
add_node	match_stream.hpp	/^	void add_node(StreamNode * node)$/;"	f	class:StreamLine	access:public	signature:(StreamNode * node)
add_section	match_utils.cpp	/^void SectionManager::add_section(const MatchSection& sec) {$/;"	f	class:SectionManager	signature:(const MatchSection& sec)
add_video	match_analyser.cpp	/^void MatchAnalyser::add_video( unsigned index, const std::string & path, double fps )$/;"	f	class:MatchAnalyser	signature:( unsigned index, const std::string & path, double fps )
addr	server.hpp	/^	const boost::asio::ip::address addr() const { return local_point_.address(); }$/;"	f	class:Server	access:public	signature:() const
addr_type	server.hpp	/^typedef boost::asio::ip::address addr_type;$/;"	t
address	matcher_manager.hpp	/^	const ip_address    address() const { return endpoint_.address(); }$/;"	f	class:Matcher	access:public	signature:() const
all_comm_end	server.cpp	/^bool Server::all_comm_end() const$/;"	f	class:Server	signature:() const
all_comm_end_	server.hpp	/^	bool all_comm_end_;									\/\/ all communicatioin end flag$/;"	m	class:Server	access:private
all_put	comm_box.cpp	/^bool Basebox::all_put() const { return all_put_; }$/;"	f	class:Basebox	signature:() const
all_put_	comm_box.hpp	/^	bool all_put_;$/;"	m	class:Basebox	access:protected
angle	surf.cpp	/^	float angle() const {$/;"	f	class:MaxDirection	access:public	signature:() const
arg	server.hpp	/^	CommArg * arg() { return arg_; }$/;"	f	class:Server	access:public	signature:()
arg_	server.hpp	/^	CommArg * arg_;									   	\/\/ arg$/;"	m	class:Server	access:private
at	integral.h	/^	int at(int r, int c) const {	\/\/ get the pixel with bound check$/;"	f	struct:IntImage	access:public	signature:(int r, int c) const
batch_len	match_utils.h	/^	int batch_len;		\/\/ Ã¿×éÆ¥ÅäÖ¡Êý$/;"	m	struct:MatchArgs	access:public
begin	fdutils.h	/^	int begin, end;$/;"	m	struct:Range	access:public
big_file	match_stream.hpp	/^	BigLibFile big_file;$/;"	m	class:NewLibLoader	access:private
big_file	match_stream.hpp	/^	BigLibFile big_file;$/;"	m	class:SurfLibLoader	access:private
bind_ip	comm_arg.hpp	/^	std::string    bind_ip;$/;"	m	struct:CommArg	access:public
bits	bits.hpp	/^	bits(int n) { set_size(n); clr(); }$/;"	f	struct:bits	access:public	signature:(int n)
bits	bits.hpp	/^	bits(unsigned char * p, int len) { set_size(len << SHIFT); memcpy(byte_ptr(), p, len); }$/;"	f	struct:bits	access:public	signature:(unsigned char * p, int len)
bits	bits.hpp	/^struct bits$/;"	s
bits::MASK	bits.hpp	/^	static const unsigned char MASK = 0x07;$/;"	m	struct:bits	access:public
bits::N	bits.hpp	/^	int N;$/;"	m	struct:bits	access:public
bits::SHIFT	bits.hpp	/^	static const unsigned char SHIFT = 3;$/;"	m	struct:bits	access:public
bits::bits	bits.hpp	/^	bits(int n) { set_size(n); clr(); }$/;"	f	struct:bits	access:public	signature:(int n)
bits::bits	bits.hpp	/^	bits(unsigned char * p, int len) { set_size(len << SHIFT); memcpy(byte_ptr(), p, len); }$/;"	f	struct:bits	access:public	signature:(unsigned char * p, int len)
bits::byte_ptr	bits.hpp	/^	unsigned char * byte_ptr() { return &bytes[0]; }$/;"	f	struct:bits	access:public	signature:()
bits::bytes	bits.hpp	/^	std::vector< unsigned char > bytes;$/;"	m	struct:bits	access:private
bits::clr	bits.hpp	/^	void clr (int i) { ASSERTS(i < N);        bytes[i >> SHIFT] &= ~(0x80 >> (i & MASK)); }$/;"	f	struct:bits	access:public	signature:(int i)
bits::clr	bits.hpp	/^	void clr()       { memset(byte_ptr(), 0x00, N >> SHIFT); }$/;"	f	struct:bits	access:public	signature:()
bits::set	bits.hpp	/^	void set (int i) { ASSERTS(i < N);        bytes[i >> SHIFT] |=  (0x80 >> (i & MASK)); }$/;"	f	struct:bits	access:public	signature:(int i)
bits::set	bits.hpp	/^	void set()       { memset(byte_ptr(), 0xFF, N >> SHIFT); }$/;"	f	struct:bits	access:public	signature:()
bits::set_size	bits.hpp	/^	void set_size(int n)$/;"	f	struct:bits	access:public	signature:(int n)
bits::test	bits.hpp	/^	bool test(int i) { ASSERTS(i < N); return bytes[i >> SHIFT] &   (0x80 >> (i & MASK)); }$/;"	f	struct:bits	access:public	signature:(int i)
bits::to_int	bits.hpp	/^	int to_int() {$/;"	f	struct:bits	access:public	signature:()
bits::to_string	bits.hpp	/^	std::string to_string() {$/;"	f	struct:bits	access:public	signature:()
box_empty	comm_box.hpp	/^	bool box_empty() const { return num_elements() == 0; }$/;"	f	class:Basebox	access:public	signature:() const
box_full	comm_box.hpp	/^	bool box_full()  const { return num_elements() == capacity(); }$/;"	f	class:Basebox	access:public	signature:() const
broad_points_all_sent	server.hpp	/^	bool broad_points_all_sent() const { return broad_points_all_sent_; }$/;"	f	class:Server	access:public	signature:() const
broad_points_all_sent_	server.hpp	/^	bool broad_points_all_sent_;$/;"	m	class:Server	access:private
buff	comm_box.hpp	/^	std::vector< T > buff;$/;"	m	class:RandomGetBox	access:protected
buff	match_stream.hpp	/^	int buff;$/;"	m	struct:BigLibFile	access:private
buff	utils.h	/^		point buff;$/;"	m	struct:UTILS::image	access:private
build	fasthessian.cpp	/^void ResponseLayer::build(const Octave* oct, int fb, bool mt) {$/;"	f	class:ResponseLayer	signature:(const Octave* oct, int fb, bool mt)
buildHessian	fasthessian.cpp	/^void Octave::buildHessian(bool mt) {$/;"	f	class:Octave	signature:(bool mt)
buildThread	fasthessian.cpp	/^void ResponseLayer::buildThread(const Octave* oct, int tid) {$/;"	f	class:ResponseLayer	signature:(const Octave* oct, int tid)
built_	match_stream.hpp	/^	bool built_;$/;"	m	class:ConnectionBuilder	access:private
byte_ptr	bits.hpp	/^	unsigned char * byte_ptr() { return &bytes[0]; }$/;"	f	struct:bits	access:public	signature:()
bytes	bit_feature.h	/^		Byte   bytes[MAX_FEATURE_BITS\/ 8];$/;"	m	union:BitFeature::__anon5	access:public
bytes	bits.hpp	/^	std::vector< unsigned char > bytes;$/;"	m	struct:bits	access:private
bytes_	packet.hpp	/^	u_char bytes_[HEAD_SIZE + N];$/;"	m	class:BasicPacket	access:protected
c	fasthessian.h	/^	struct RPos { int i, r, c; };$/;"	m	struct:Octave::RPos	access:public
c_get	comm_box.hpp	/^	boost::condition c_put, c_get;$/;"	m	class:Basebox	access:protected
c_put	comm_box.hpp	/^	boost::condition c_put, c_get;$/;"	m	class:Basebox	access:protected
c_wait_	connection_build_service.hpp	/^	boost::condition c_wait_;$/;"	m	class:ConnectionBuilderService	access:private
c_wait_	lib_load_service.hpp	/^	boost::condition c_wait_;$/;"	m	class:LibLoadService	access:private
c_wait_	match_stream.hpp	/^	boost::condition c_wait_;$/;"	m	class:ConnectionBuilder	access:private
calc_all_pair_ranges	match_analyser.cpp	/^void VideoMatchAnalyser::calc_all_pair_ranges()$/;"	f	class:VideoMatchAnalyser	signature:()
calc_match_result	match_analyser.cpp	/^void VideoMatchAnalyser::calc_match_result()$/;"	f	class:VideoMatchAnalyser	signature:()
calc_match_sections	match_analyser.cpp	/^void VideoMatchAnalyser::calc_match_sections()$/;"	f	class:VideoMatchAnalyser	signature:()
calc_pair_ranges	match_analyser.cpp	/^void VideoMatchAnalyser::calc_pair_ranges(MatchPairs & p, MatchAnalyser::frames_type & frames)$/;"	f	class:VideoMatchAnalyser	signature:(MatchPairs & p, MatchAnalyser::frames_type & frames)
cap_end	match_utils.h	/^	int cap_end;$/;"	m	struct:VideoCapcture	access:private
cap_step	match_utils.h	/^	double cap_step;$/;"	m	struct:VideoCapcture	access:private
capacity	comm_box.hpp	/^	virtual std::size_t capacity()     const { return 1; }$/;"	f	class:CommBox	access:public	signature:() const
capacity	comm_box.hpp	/^	virtual std::size_t capacity()     const { return N; }$/;"	f	class:RandomGetBox	access:public	signature:() const
capacity	comm_box.hpp	/^	virtual std::size_t capacity()     const$/;"	f	class:PacketQueue	access:public	signature:() const
capacity	comm_window.hpp	/^	virtual std::size_t capacity() const { return N; }$/;"	f	class:PacketWindow	access:public	signature:() const
capture	match_utils.h	/^	CvCapture* capture;$/;"	m	struct:VideoCapcture	access:private
cast	utils.h	/^T & cast(void * p)$/;"	f	signature:(void * p)
cfa_udp_packet_base__	packet.hpp	/^typedef BasicPacket< CFA_UDP_HEAD_SIZE, CFA_UDP_MAX_LOAD_LEN > cfa_udp_packet_base__;$/;"	t
cfa_udp_response_packet_base__	packet.hpp	/^typedef BasicPacket< CFA_UDP_HEAD_SIZE, CFA_UDP_MIN_LOAD_LEN > cfa_udp_response_packet_base__;$/;"	t
chain	match_utils.h	/^	typedef std::list<MatchSection> chain;		\/\/ Ã¿Â·ÊÓÆµµÄÖÐ¼ä½á¹û·ÅÔÚÒ»¸öchainÖÐ$/;"	t	class:SectionManager	access:public
chains_	match_utils.h	/^	std::map<int, chain> chains_;			\/\/ Í¬Ê±´¦Àí¶àÂ·ÊÓÆµ$/;"	m	class:SectionManager	access:private
check_and_put	match_stream.cpp	474;"	d	file:
check_end_image	utils.h	/^		void check_end_image()$/;"	f	struct:UTILS::image	access:public	signature:()
check_load_len	packet.hpp	/^	void check_load_len( unsigned n )$/;"	f	class:BasicPacket	access:protected	signature:( unsigned n )
choose_next_matcher	matcher_manager.hpp	/^	MatcherPtr choose_next_matcher()$/;"	f	class:MatcherManager	access:public	signature:()
choose_targets	comm_box.cpp	/^MatchImageBox::indexes_type MatchImageBox::choose_targets()$/;"	f	class:MatchImageBox	signature:()
circular_buf	comm_window.hpp	/^	std::vector<Packet> circular_buf;$/;"	m	class:PacketWindow	access:protected
clear	bit_feature.h	/^	void clear() {$/;"	f	class:BitFeature	access:public	signature:()
clear	match_utils.h	/^	void clear() { chains_.clear(); }$/;"	f	class:SectionManager	access:public	signature:()
clear_load	matcher_manager.hpp	/^	void clear_load() { num_load_imgs_ = 0; }$/;"	f	class:Matcher	access:public	signature:()
client_addrs	comm_arg.hpp	/^	std::vector<std::string> client_addrs;$/;"	m	struct:CommArg	access:public
clr	bits.hpp	/^	void clr (int i) { ASSERTS(i < N);        bytes[i >> SHIFT] &= ~(0x80 >> (i & MASK)); }$/;"	f	struct:bits	access:public	signature:(int i)
clr	bits.hpp	/^	void clr()       { memset(byte_ptr(), 0x00, N >> SHIFT); }$/;"	f	struct:bits	access:public	signature:()
clusterIndex	ipoint.h	/^	int clusterIndex;		\/\/! Used to store cluster index$/;"	m	struct:Ipoint	access:public
cnt	match_stream.hpp	/^	std::size_t cnt;$/;"	m	class:GrayImageSender	access:private
comm_arg	comm_arg.hpp	/^	static CommArg & comm_arg()$/;"	f	struct:CommArg	access:public	signature:()
comm_state	matcher_manager.hpp	/^	COMM_STATE comm_state() const { return comm_state_; }$/;"	f	class:Matcher	access:public	signature:() const
comm_state_	matcher_manager.hpp	/^	COMM_STATE comm_state_;		\/\/ currently not used$/;"	m	class:Matcher	access:private
con_sink	log.h	/^		sp_stream_sink con_sink()  { return sink_con_;  }$/;"	f	class:LOG::Log	access:public	signature:()
confirm	comm_window.hpp	/^	bool confirm(unsigned char index)$/;"	f	class:PacketWindow	access:public	signature:(unsigned char index)
conn_build_wait_time	comm_arg.hpp	/^	int conn_build_wait_time;$/;"	m	struct:CommArg	access:public
conn_matchers	matcher_manager.hpp	/^	const Matchers & conn_matchers() const { return conn_matchers_; }$/;"	f	class:MatcherManager	access:public	signature:() const
conn_matchers_	matcher_manager.hpp	/^	Matchers conn_matchers_;$/;"	m	class:MatcherManager	access:private
conn_task_	match_stream.hpp	/^	static std::map<endpoint, ConnectionBuilder *> conn_task_;$/;"	m	class:ConnectionBuilder	access:private
connect_matcher	connection_build_service.cpp	/^void ConnectionBuilderService::connect_matcher( MatcherPtr m )$/;"	f	class:ConnectionBuilderService	signature:( MatcherPtr m )
connect_matcher	matcher_manager.cpp	/^void MatcherManager::connect_matcher( const Matcher & m )$/;"	f	class:MatcherManager	signature:( const Matcher & m )
consider_extract_mac	comm_arg.hpp	/^	int consider_extract_mac;$/;"	m	struct:CommArg	access:public
consider_timeout	comm_window.hpp	/^	bool consider_timeout;$/;"	m	class:PacketWindow	access:protected
construct_server	server.hpp	/^	static void construct_server( CommArg * arg )$/;"	f	class:Server	access:public	signature:( CommArg * arg )
core_	log.h	/^		sp_log_core    core_;$/;"	m	class:LOG::Log	access:private
cos	surf.cpp	/^	float cos() const { return x \/ sqrt(l); }$/;"	f	class:MaxDirection	access:public	signature:() const
cos_ori	ipoint.h	/^	float sin_ori, cos_ori;	\/\/! sin(orientation) and cos(orientation)$/;"	m	struct:Ipoint	access:public
ctrl	packet.hpp	/^	u_char          ctrl() const   { return bytes_[HEAD_SIZE + 2]; }$/;"	f	class:BasicPacket	access:public	signature:() const
curr	comm_box.hpp	/^	int curr;$/;"	m	class:RandomGetBox	access:protected
curr	comm_window.hpp	/^	std::size_t curr;	\/\/ Ö¸Ïòµ±Ç°·¢ËÍµÄ°ü£¬ÓÉget()·µ»Ø$/;"	m	class:PacketWindow	access:protected
curr_file	match_stream.hpp	/^	std::ifstream * curr_file;$/;"	m	struct:BigLibFile	access:private
curr_stream	match_stream.hpp	/^	std::ifstream & curr_stream()$/;"	f	struct:BigLibFile	access:public	signature:()
data	comm_box.hpp	/^	T data;$/;"	m	class:CommBox	access:protected
data	surf.cpp	/^	float data[N+1][N+1];$/;"	m	class:__anon1::Gaussian	file:	access:private
data_	integral.h	/^	T*  data_;              \/\/ Pointer to image data$/;"	m	class:Image	access:protected
data_len	packet.hpp	/^	int      data_len() const { return data_len_; }$/;"	f	class:BasicPacket	access:public	signature:() const
data_len_	packet.hpp	/^	int data_len_;$/;"	m	class:BasicPacket	access:protected
data_ptr	packet.hpp	/^    u_char * data_ptr()  { return bytes_ + HEAD_SIZE + 2; }$/;"	f	class:BasicPacket	access:public	signature:()
data_valid	comm_box.hpp	/^	bool data_valid;$/;"	m	class:CommBox	access:protected
deadline_	server.hpp	/^	boost::asio::deadline_timer deadline_;              \/\/ timer for getting mac$/;"	m	class:Server	access:private
delete_chain	match_utils.h	/^	void delete_chain(int id) { chains_.erase(id); }$/;"	f	class:SectionManager	access:public	signature:(int id)
descriptor	ipoint.h	/^	float descriptor[64];	\/\/! Vector of descriptor components$/;"	m	struct:Ipoint	access:public
descriptor	ipoint.h	/^	float descriptor[64];	\/\/! Vector of descriptor components$/;"	m	struct:LibIpt	access:public
descriptor	utils.h	/^			descriptor_type descriptor[64];$/;"	m	struct:UTILS::image::point	access:public
descriptorThread	surf.cpp	/^void Surf::descriptorThread(int tid) {$/;"	f	class:Surf	signature:(int tid)
dest_	match_stream.hpp	/^	const endpoint dest_;$/;"	m	class:ConnectionBuilder	access:private
dest_	match_stream.hpp	/^	const endpoint dest_;$/;"	m	class:NewLibSender	access:private
dest_	match_stream.hpp	/^	const endpoint dest_;$/;"	m	class:SurfLibSender	access:private
dest_addr	match_stream.cpp	/^const endpoint ImagePointsSender::dest_addr() const $/;"	f	class:ImagePointsSender	signature:() const
dest_addr_	match_stream.hpp	/^	endpoint dest_addr_;$/;"	m	class:ImagePointsSender	access:private
detail_report	match_analyser.hpp	/^	std::ofstream & detail_report()$/;"	f	class:VideoMatchAnalyser	access:private	signature:()
detail_report_	match_analyser.hpp	/^	std::ofstream *           detail_report_;$/;"	m	class:VideoMatchAnalyser	access:private
device	comm_arg.hpp	/^	std::string    device;$/;"	m	struct:CommArg	access:public
diag_test_bits	match_utils.h	/^	int diag_test_bits;		\/\/ Ã¿×éÆ¥Åä½á¹û£¨¶Ô½ÇÏß£©ÅÐ¶ÏÎ»Êý$/;"	m	struct:MatchArgs	access:public
diag_test_thres	match_utils.h	/^	int diag_test_thres;	\/\/ Ã¿×éÆ¥Åä½á¹ûÅÐ¶ÏãÐÖµ$/;"	m	struct:MatchArgs	access:public
dist	ipoint.h	/^	D dist;$/;"	m	class:Matches	access:private
dist_table	bit_feature.cpp	/^	char dist_table[256] = {$/;"	m	namespace:__anon4	file:
do_end_task	match_stream.cpp	/^void GrayImageGenerator::do_end_task()$/;"	f	class:GrayImageGenerator	signature:()
do_end_task	match_stream.cpp	/^void GrayImageLoader::do_end_task()$/;"	f	class:GrayImageLoader	signature:()
do_end_task	match_stream.cpp	/^void GrayImageSender::do_end_task()$/;"	f	class:GrayImageSender	signature:()
do_end_task	match_stream.cpp	/^void ImagePointsLoader::do_end_task()$/;"	f	class:ImagePointsLoader	signature:()
do_end_task	match_stream.cpp	/^void ImagePointsSender::do_end_task()$/;"	f	class:ImagePointsSender	signature:()
do_load_image_points	match_stream.cpp	/^void ImagePointsLoader::do_load_image_points( const vector<match_image> & images, MatcherPtr matcher )$/;"	f	class:ImagePointsLoader	signature:( const vector<match_image> & images, MatcherPtr matcher )
do_post_calculations	match_analyser.cpp	/^void MatchAnalyser::do_post_calculations()$/;"	f	class:MatchAnalyser	signature:()
do_run_task	match_stream.cpp	/^void GrayImageGenerator::do_run_task()$/;"	f	class:GrayImageGenerator	signature:()
do_run_task	match_stream.cpp	/^void GrayImageLoader::do_run_task()$/;"	f	class:GrayImageLoader	signature:()
do_run_task	match_stream.cpp	/^void GrayImageSender::do_run_task()$/;"	f	class:GrayImageSender	signature:()
do_run_task	match_stream.cpp	/^void ImagePointsLoader::do_run_task()$/;"	f	class:ImagePointsLoader	signature:()
do_run_task	match_stream.cpp	/^void ImagePointsSender::do_run_task()$/;"	f	class:ImagePointsSender	signature:()
do_send_lib	comm_arg.hpp	/^	int do_send_lib;$/;"	m	struct:CommArg	access:public
do_surf	comm_arg.hpp	/^	int do_surf;$/;"	m	struct:CommArg	access:public
done	surf.h	/^	bool   done() const { return pipts_ > 0 && size() > pipts_; }$/;"	f	class:Surf	access:public	signature:() const
drawFPS	utils.cpp	/^void drawFPS(IplImage *img)$/;"	f	signature:(IplImage *img)
drawIpoint	utils.cpp	/^void drawIpoint(IplImage *img, const Ipoint &ipt, int tailSize)$/;"	f	signature:(IplImage *img, const Ipoint &ipt, int tailSize)
drawIpoints	utils.cpp	/^void drawIpoints(IplImage *img, vector<Ipoint> &ipts, int tailSize)$/;"	f	signature:(IplImage *img, vector<Ipoint> &ipts, int tailSize)
drawPoint	utils.cpp	/^void drawPoint(IplImage *img, const Ipoint &ipt)$/;"	f	signature:(IplImage *img, const Ipoint &ipt)
drawPoints	utils.cpp	/^void drawPoints(IplImage *img, vector<Ipoint> &ipts)$/;"	f	signature:(IplImage *img, vector<Ipoint> &ipts)
drawWindows	utils.cpp	/^void drawWindows(IplImage *img, vector<Ipoint> &ipts)$/;"	f	signature:(IplImage *img, vector<Ipoint> &ipts)
dummy_handler	server.cpp	/^void dummy_handler(const error_code& ) {}$/;"	f	signature:(const error_code& )
dump_matched_lib	comm_arg.hpp	/^	int dump_matched_lib;$/;"	m	struct:CommArg	access:public
dwords	bit_feature.h	/^		DWord dwords[MAX_FEATURE_BITS\/64];$/;"	m	union:BitFeature::__anon5	access:public
dx	ipoint.h	/^	float dx, dy;			\/\/! Placeholders for point motion$/;"	m	struct:Ipoint	access:public
dy	ipoint.h	/^	float dx, dy;			\/\/! Placeholders for point motion$/;"	m	struct:Ipoint	access:public
end	connection_build_service.cpp	/^bool ConnectionBuilderService::end()$/;"	f	class:ConnectionBuilderService	signature:()
end	fdutils.h	/^	int begin, end;$/;"	m	struct:Range	access:public
end	lib_load_service.cpp	/^bool LibLoadService::end()$/;"	f	class:LibLoadService	signature:()
endSurfLib	surflib.cpp	/^int endSurfLib(const char* filename) {$/;"	f	signature:(const char* filename)
endSurfLib	surflib.cpp	/^int endSurfLib(std::ostream& outfile) {$/;"	f	signature:(std::ostream& outfile)
end_condition_not_satisfied	comm_box.hpp	/^	virtual bool end_condition_not_satisfied() const { return !(all_put() && box_empty()); }$/;"	f	class:Basebox	access:public	signature:() const
end_condition_satisfied	comm_box.hpp	/^	bool end_condition_satisfied() const { return !end_condition_not_satisfied(); }$/;"	f	class:Basebox	access:public	signature:() const
end_image	point_manager.cpp	/^void PointAuxer::end_image(int frame)$/;"	f	class:PointAuxer	signature:(int frame)
end_point_	server.hpp	/^	boost::asio::ip::udp::endpoint end_point_;			\/\/ receive endpoint$/;"	m	class:Server	access:private
endpoint	match_analyser.hpp	/^	typedef boost::asio::ip::udp::endpoint 			   endpoint;$/;"	t	class:MatchAnalyser	access:public
endpoint	match_stream.hpp	/^typedef boost::asio::ip::udp::endpoint endpoint;$/;"	t
endpoint_	matcher_manager.hpp	/^	endpoint_type endpoint_;$/;"	m	class:Matcher	access:private
endpoint_type	matcher_manager.hpp	/^	typedef boost::asio::ip::udp::endpoint endpoint_type;$/;"	t	class:Matcher	access:public
exists	matcher_manager.hpp	/^	bool exists( const Matcher & m ) { return find(m); }$/;"	f	class:MatcherManager	access:public	signature:( const Matcher & m )
extract_addr	comm_arg.hpp	/^	std::string    extract_addr;$/;"	m	struct:CommArg	access:public
extract_mac_got_	server.hpp	/^	bool extract_mac_got_;								\/\/ used in getting mac$/;"	m	class:Server	access:private
extracter_busy	server.cpp	/^bool Server::extracter_busy() const$/;"	f	class:Server	signature:() const
extracter_busy_	server.hpp	/^	bool extracter_busy_;$/;"	m	class:Server	access:private
fRound	fdutils.h	/^inline int fRound(float flt) { return (int) floor(flt+0.5f); }$/;"	f	signature:(float flt)
feature_bits	match_utils.h	/^	int feature_bits;		\/\/ ÌØÕ÷¾«¶È$/;"	m	struct:MatchArgs	access:public
file_sink	log.h	/^		sp_file_sink   file_sink() { return sink_file_; }$/;"	f	class:LOG::Log	access:public	signature:()
filterBase	fasthessian.h	/^	int filterBase() const { return filter_base_; }		\/\/ filter size \/ 3$/;"	f	class:ResponseLayer	access:public	signature:() const
filterBase	fasthessian.h	/^	int filterBase(int i) const { return layers_[i].filterBase(); }$/;"	f	class:Octave	access:private	signature:(int i) const
filter_base_	fasthessian.h	/^	int filter_base_;$/;"	m	class:ResponseLayer	access:private
find	matcher_manager.hpp	/^	MatcherPtr find( const Matcher & m ) const$/;"	f	class:MatcherManager	access:public	signature:( const Matcher & m ) const
find_in	matcher_manager.hpp	/^	static MatcherPtr find_in( const Matcher & m, const Matchers & ms )$/;"	f	class:MatcherManager	access:public	signature:( const Matcher & m, const Matchers & ms )
find_matchers_at_state	matcher_manager.hpp	/^	Matchers find_matchers_at_state( const Matcher::MATCHER_STATE s )$/;"	f	class:MatcherManager	access:public	signature:( const Matcher::MATCHER_STATE s )
find_one_matcher_at_state	matcher_manager.hpp	/^	MatcherPtr find_one_matcher_at_state( const Matcher::MATCHER_STATE s )$/;"	f	class:MatcherManager	access:public	signature:( const Matcher::MATCHER_STATE s )
foreach	utils.h	21;"	d
fpga_port	comm_arg.hpp	/^	unsigned short fpga_port;$/;"	m	struct:CommArg	access:public
fps	match_utils.h	/^	double fps;$/;"	m	struct:VideoCapcture	access:public
fps_	match_analyser.hpp	/^	const double fps_;$/;"	m	class:VideoMatchAnalyser	access:private
frame	comm_box.hpp	/^	int        frame;$/;"	m	struct:BoxImage	access:public
frame_	match_analyser.hpp	/^	const frame_type frame_;$/;"	m	class:ImageMatchAnalyser	access:private
frame_count	match_utils.h	/^	double frame_count;$/;"	m	struct:VideoCapcture	access:public
frame_index	utils.h	/^		frame_type frame_index;$/;"	m	struct:UTILS::image	access:public
frame_pos	match_utils.h	/^	int frame_pos;$/;"	m	struct:VideoCapcture	access:public
frame_pos	utils.h	/^		unsigned frame_pos() const { return frame_index & 0x00FFFFFF; }$/;"	f	struct:UTILS::image	access:public	signature:() const
frame_thres	match_utils.h	/^	int frame_thres;		\/\/ µ¥Ö¡Æ¥ÅäãÐÖµ$/;"	m	struct:MatchArgs	access:public
frame_type	match_analyser.hpp	/^typedef unsigned frame_type;$/;"	t
frame_type	utils.h	/^typedef unsigned frame_type;$/;"	t
frames_buffer_type	match_analyser.hpp	/^	typedef std::vector< frames_type >                   frames_buffer_type;$/;"	t	class:VideoMatchAnalyser	access:public
frames_buffer_type	match_analyser.hpp	/^	typedef std::vector<frames_type>                   frames_buffer_type;$/;"	t	class:MatchAnalyser	access:public
frames_map_	match_analyser.hpp	/^	frames_map_type frames_map_;$/;"	m	class:MatchAnalyser	access:private
frames_map_type	match_analyser.hpp	/^    typedef std::map<endpoint, frames_type>            frames_map_type;$/;"	t	class:MatchAnalyser	access:public
frames_type	match_analyser.hpp	/^	typedef std::vector< frame_type >                    frames_type;$/;"	t	class:ImageMatchAnalyser	access:private
frames_type	match_analyser.hpp	/^	typedef std::vector< frame_type >                    frames_type;$/;"	t	class:VideoMatchAnalyser	access:public
frames_type	match_analyser.hpp	/^	typedef std::vector<frame_type>                    frames_type;$/;"	t	class:MatchAnalyser	access:public
free_curr_file	match_stream.hpp	/^	void free_curr_file()$/;"	f	struct:BigLibFile	access:public	signature:()
free_matcher	matcher_manager.cpp	/^void MatcherManager::free_matcher(const Matcher & m)$/;"	f	class:MatcherManager	signature:(const Matcher & m)
from_point	packet.hpp	/^	const udp::endpoint from_point() { return src_endpoint_; }$/;"	f	class:CfaUdpPacket	access:public	signature:()
gather_section	match_utils.cpp	/^void VideoMatcher::gather_section(const MatchResult& res) {$/;"	f	class:VideoMatcher	signature:(const MatchResult& res)
gen_image_frame	match_stream.cpp	/^void GrayImageGenerator::gen_image_frame(const string & image, unsigned idx)$/;"	f	class:GrayImageGenerator	signature:(const string & image, unsigned idx)
gen_video_frame	match_stream.cpp	/^void GrayImageGenerator::gen_video_frame(const string & video, unsigned idx)$/;"	f	class:GrayImageGenerator	signature:(const string & video, unsigned idx)
get	comm_box.cpp	/^bool MatchImageBox::get(std::vector< match_image > & snk)$/;"	f	class:MatchImageBox	signature:(std::vector< match_image > & snk)
get	comm_box.hpp	/^	PacketPtr get()$/;"	f	class:PacketQueue	access:public	signature:()
get	comm_box.hpp	/^	bool get(T & t)$/;"	f	class:CommBox	access:public	signature:(T & t)
get	comm_box.hpp	/^	bool get(std::vector< T > & snk)$/;"	f	class:RandomGetBox	access:public	signature:(std::vector< T > & snk)
get	comm_window.hpp	/^	Packet * get()$/;"	f	class:PacketWindow	access:public	signature:()
get	log.cpp	/^Log& Log::get() {$/;"	f	class:LOG::Log	signature:()
getDescriptor	surf.cpp	/^void Surf::getDescriptor(Ipoint& ipt) {$/;"	f	class:Surf	signature:(Ipoint& ipt)
getEnum	fdutils.h	/^	E getEnum(const string& str) const {$/;"	f	class:EnumStringMap	access:public	signature:(const string& str) const
getIpoints	fasthessian.cpp	/^void Octave::getIpoints(bool mt) {$/;"	f	class:Octave	signature:(bool mt)
getOrientation	surf.cpp	/^void Surf::getOrientation(Ipoint& ipt) {$/;"	f	class:Surf	signature:(Ipoint& ipt)
getString	fdutils.h	/^	const char* getString(E val) const {$/;"	f	class:EnumStringMap	access:public	signature:(E val) const
get_build_task	match_stream.hpp	/^	static ConnectionBuilder * get_build_task(const endpoint & e )$/;"	f	class:ConnectionBuilder	access:public	signature:(const endpoint & e )
get_comm_state	matcher_manager.hpp	/^	Matcher::COMM_STATE get_comm_state( const Matcher & m ) const$/;"	f	class:MatcherManager	access:public	signature:( const Matcher & m ) const
get_condition_not_satisfied	comm_box.cpp	/^bool ImageGenBox::get_condition_not_satisfied() const$/;"	f	class:ImageGenBox	signature:() const
get_condition_not_satisfied	comm_box.cpp	/^bool MatchImageBox::get_condition_not_satisfied() const$/;"	f	class:MatchImageBox	signature:() const
get_condition_not_satisfied	comm_box.hpp	/^	virtual bool get_condition_not_satisfied() const { return box_empty(); }$/;"	f	class:Basebox	access:public	signature:() const
get_condition_not_satisfied	comm_window.hpp	/^	virtual bool get_condition_not_satisfied() const$/;"	f	class:PacketWindow	access:public	signature:() const
get_frame	match_utils.cpp	/^IplImage* VideoCapcture::get_frame() {$/;"	f	class:VideoCapcture	signature:()
get_logger	log.h	/^	inline sev_logger& get_logger() { return Log::get().logger(); }$/;"	f	namespace:LOG	signature:()
get_match_frame_video_index	match_analyser.hpp	/^	static unsigned get_match_frame_video_index( frame_type frame ) { return frame >> 24; }$/;"	f	class:MatchAnalyser	access:public	signature:( frame_type frame )
get_matcher_state	matcher_manager.hpp	/^	Matcher::MATCHER_STATE get_matcher_state( const Matcher & m ) const$/;"	f	class:MatcherManager	access:public	signature:( const Matcher & m ) const
get_num_points_of_frame	match_analyser.cpp	/^unsigned MatchAnalyser::get_num_points_of_frame( frame_type frame )$/;"	f	class:MatchAnalyser	signature:( frame_type frame )
get_video_match_frame_pos	match_analyser.hpp	/^	static unsigned get_video_match_frame_pos  ( frame_type frame ) { return frame & 0x00FFFFFF; }$/;"	f	class:MatchAnalyser	access:public	signature:( frame_type frame )
gray_image_send_thread	match_stream.cpp	/^void GrayImageSender::gray_image_send_thread(const endpoint & dest)$/;"	f	class:GrayImageSender	signature:(const endpoint & dest)
gray_image_window	server.hpp	/^	GrayImageWindow    * gray_image_window()   { return &gray_image_window_; }	$/;"	f	class:Server	access:public	signature:()
gray_image_window_	server.hpp	/^	GrayImageWindow       gray_image_window_;			\/\/ window for sending gray image$/;"	m	class:Server	access:private
gray_img_all_sent	server.hpp	/^	bool gray_img_all_sent() const { return gray_img_all_sent_; }$/;"	f	class:Server	access:public	signature:() const
gray_img_all_sent_	server.hpp	/^	bool gray_img_all_sent_;$/;"	m	class:Server	access:private
gray_img_generator	server.hpp	/^	GrayImageGenerator * gray_img_generator()  const { return gray_img_generator_; }$/;"	f	class:Server	access:public	signature:() const
gray_img_generator_	server.hpp	/^	GrayImageGenerator * gray_img_generator_;$/;"	m	class:Server	access:private
gray_img_loader	server.hpp	/^	GrayImageLoader    * gray_img_loader()     const { return gray_img_loader_; }$/;"	f	class:Server	access:public	signature:() const
gray_img_loader_	server.hpp	/^	GrayImageLoader    * gray_img_loader_;$/;"	m	class:Server	access:private
gray_img_sender	server.hpp	/^	GrayImageSender    * gray_img_sender()     const { return gray_img_sender_; }$/;"	f	class:Server	access:public	signature:() const
gray_img_sender_	server.hpp	/^	GrayImageSender    * gray_img_sender_;$/;"	m	class:Server	access:private
haarX	surf.cpp	/^inline int Surf::haarX(int row, int col, int s) {$/;"	f	class:Surf	signature:(int row, int col, int s)
haarY	surf.cpp	/^inline int Surf::haarY(int row, int col, int s) {$/;"	f	class:Surf	signature:(int row, int col, int s)
half2single	fdutils.h	/^static float half2single(halfp h) {$/;"	f	signature:(halfp h)
halfp	fdutils.h	/^typedef unsigned short halfp;		\/\/ 16 bit$/;"	t
hamming_distance	bit_feature.cpp	/^int hamming_distance(const BitFeature& f1, const BitFeature& f2) {$/;"	f	signature:(const BitFeature& f1, const BitFeature& f2)
handle_image	match_stream.cpp	/^void GrayImageLoader::handle_image(IplImage * img, int frame_idx)$/;"	f	class:GrayImageLoader	signature:(IplImage * img, int frame_idx)
handle_packet	match_analyser.cpp	/^void MatchAnalyser::handle_packet( Packet & pkt, const MatchAnalyser::endpoint & from_addr )$/;"	f	class:MatchAnalyser	signature:( Packet & pkt, const MatchAnalyser::endpoint & from_addr )
handle_packet	packet_handle_center.cpp	/^void PacketHandleCenter::handle_packet( PacketPtr p, const udp::endpoint & end_point )$/;"	f	class:PacketHandleCenter	signature:( PacketPtr p, const udp::endpoint & end_point )
handle_packet	point_manager.cpp	/^void PointAuxer::handle_packet( Packet & pkt )$/;"	f	class:PointAuxer	signature:( Packet & pkt )
head	comm_window.hpp	/^	std::size_t head;	\/\/ ¶ÓÁÐÍ·£¬ÓÉconfirmµ÷Õû$/;"	m	class:PacketWindow	access:protected
height	integral.h	/^	int height() const { return height_; }$/;"	f	class:Image	access:public	signature:() const
height_	integral.h	/^	int height_;            \/\/ Image height in pixels$/;"	m	class:Image	access:private
i	fasthessian.h	/^	struct RPos { int i, r, c; };$/;"	m	struct:Octave::RPos	access:public
idx	utils.h	/^		int idx;$/;"	m	struct:UTILS::image	access:private
image	comm_box.hpp	/^	IplImage * image;$/;"	m	struct:BoxImage	access:public
image	match_stream.hpp	/^	typedef match_image image;$/;"	t	class:ImagePointsLoader	access:public
image	point_manager.hpp	/^	typedef match_image image;$/;"	t	class:PointAuxer	access:public
image	utils.h	/^		image() : idx(0) {}$/;"	f	struct:UTILS::image	access:public	signature:()
image	utils.h	/^	struct image$/;"	s	namespace:UTILS
image_cnt_	match_stream.hpp	/^	std::size_t image_cnt_;$/;"	m	class:ImagePointsLoader	access:private
image_gen_box	server.hpp	/^	ImageGenBox        * image_gen_box()       { return &image_gen_box_; }$/;"	f	class:Server	access:public	signature:()
image_gen_box_	server.hpp	/^	ImageGenBox           image_gen_box_;				\/\/ gray image gen box$/;"	m	class:Server	access:private
image_gen_box_base__	comm_box.hpp	/^typedef CommBox< BoxImage > image_gen_box_base__;$/;"	t
image_generate_thread	match_stream.cpp	/^void GrayImageGenerator::image_generate_thread(GrayImageGenerator::GEN_MODE mode)$/;"	f	class:GrayImageGenerator	signature:(GrayImageGenerator::GEN_MODE mode)
image_libs	comm_arg.hpp	/^	std::vector<std::string> image_libs;$/;"	m	struct:CommArg	access:public
image_load_thread	match_stream.cpp	/^void GrayImageLoader::image_load_thread()$/;"	f	class:GrayImageLoader	signature:()
image_matcher_ptr	match_analyser.hpp	/^typedef boost::shared_ptr<ImageMatchAnalyser> image_matcher_ptr;$/;"	t
image_pause	comm_arg.hpp	/^	int image_pause;$/;"	m	struct:CommArg	access:public
image_pause	match_stream.hpp	/^	int image_pause;$/;"	m	class:GrayImageGenerator	access:private
image_points_all_sent	server.hpp	/^	bool image_points_all_sent() const { return image_points_all_sent_; }$/;"	f	class:Server	access:public	signature:() const
image_points_all_sent_	server.hpp	/^	bool image_points_all_sent_;$/;"	m	class:Server	access:private
image_points_loader	server.hpp	/^	ImagePointsLoader  * image_points_loader() const { return image_points_loader_; }$/;"	f	class:Server	access:public	signature:() const
image_points_loader_	server.hpp	/^	ImagePointsLoader  * image_points_loader_;$/;"	m	class:Server	access:private
image_points_sender	server.hpp	/^	ImagePointsSender  * image_points_sender() const { return image_points_sender_; }$/;"	f	class:Server	access:public	signature:() const
image_points_sender_	server.hpp	/^	ImagePointsSender  * image_points_sender_;$/;"	m	class:Server	access:private
image_points_window	server.hpp	/^	ImagePointsWindow  * image_points_window() { return &image_points_window_; }	$/;"	f	class:Server	access:public	signature:()
image_points_window_	server.hpp	/^	ImagePointsWindow     image_points_window_;			\/\/ window for sending image points$/;"	m	class:Server	access:private
image_ratio	comm_arg.hpp	/^	int image_ratio;$/;"	m	struct:CommArg	access:public
images	comm_arg.hpp	/^	std::vector<std::string> images;$/;"	m	struct:CommArg	access:public
images_map_	match_analyser.hpp	/^	images_map_type images_map_;$/;"	m	class:MatchAnalyser	access:private
images_map_type	match_analyser.hpp	/^	typedef std::map<frame_type, image_matcher_ptr>    images_map_type;$/;"	t	class:MatchAnalyser	access:public
img	fasthessian.cpp	/^inline const IntImage& Octave::img() const { return surf_->img(); }$/;"	f	class:Octave	signature:() const
img	surf.h	/^	const IntImage& img() const { return img_;   }$/;"	f	class:Surf	access:public	signature:() const
img_	point_manager.hpp	/^	image * img_;$/;"	m	class:PointAuxer	access:private
img_	surf.h	/^	IntImage img_;	\/\/! Integral image where Ipoints have been detected$/;"	m	class:Surf	access:private
increase_load	matcher_manager.hpp	/^	void increase_load() { ++num_load_imgs_; }$/;"	f	class:Matcher	access:public	signature:()
index	packet.hpp	/^	u_char         index() const   { return bytes_[HEAD_SIZE + 1]; }$/;"	f	class:BasicPacket	access:public	signature:() const
index_	match_analyser.hpp	/^	const unsigned index_;$/;"	m	class:VideoMatchAnalyser	access:private
indexes_type	comm_box.hpp	/^	typedef std::vector<std::size_t> indexes_type;$/;"	t	class:RandomGetBox	access:public
init	integral.cpp	/^void GrayImage::init(const IplImage* img) {$/;"	f	class:GrayImage	signature:(const IplImage* img)
init	integral.cpp	/^void IntImage::init(const GrayImage& img) {$/;"	f	class:IntImage	signature:(const GrayImage& img)
init	surf.h	/^	void init(const GrayImage& img) { img_.init(img);            ipts_.clear(); }$/;"	f	class:Surf	access:public	signature:(const GrayImage& img)
init	surf.h	/^	void init(const IplImage* img)  { img_.init(GrayImage(img)); ipts_.clear(); }$/;"	f	class:Surf	access:public	signature:(const IplImage* img)
init_log_file	log.cpp	/^void Log::init_log_file(const std::string& log_file, const std::string& prog_name) {$/;"	f	class:LOG::Log	signature:(const std::string& log_file, const std::string& prog_name)
init_log_file	log.h	/^	inline void init_log_file(const std::string& log_file, const std::string& prog_name = "")$/;"	f	namespace:LOG	signature:(const std::string& log_file, const std::string& prog_name = Ó)
instance	connection_build_service.hpp	/^	static ConnectionBuilderService & instance()$/;"	f	class:ConnectionBuilderService	access:public	signature:()
instance	lib_load_service.hpp	/^	static LibLoadService & instance()$/;"	f	class:LibLoadService	access:public	signature:()
instance	match_analyser.hpp	/^	static MatchAnalyser & instance()$/;"	f	class:MatchAnalyser	access:public	signature:()
instance	matcher_manager.hpp	/^	static MatcherManager & instance()$/;"	f	class:MatcherManager	access:public	signature:()
instance	packet_handle_center.hpp	/^	static PacketHandleCenter & instance()$/;"	f	class:PacketHandleCenter	access:public	signature:()
instance	server.hpp	/^	static Server & instance()$/;"	f	class:Server	access:public	signature:()
instance_	matcher_manager.hpp	/^	static MatcherManager * instance_;$/;"	m	class:MatcherManager	access:private
interpolateExtremum	fasthessian.cpp	/^void Octave::interpolateExtremum(RPos p) {$/;"	f	class:Octave	signature:(RPos p)
io	server.hpp	/^	boost::asio::io_service & io() { return io_; }$/;"	f	class:Server	access:public	signature:()
io_	server.hpp	/^	boost::asio::io_service io_;                        \/\/ io service$/;"	m	class:Server	access:private
ip_address	matcher_manager.hpp	/^typedef boost::asio::ip::address ip_address;$/;"	t
ipointsThread1	fasthessian.cpp	/^void Octave::ipointsThread1(int tid) {$/;"	f	class:Octave	signature:(int tid)
ipointsThread2	fasthessian.cpp	/^void Octave::ipointsThread2(int tid) {$/;"	f	class:Octave	signature:(int tid)
ipt1	ipoint.h	/^	const Ipoint& ipt1(int i) const { return *matches_[i].first;  }$/;"	f	class:Matches	access:public	signature:(int i) const
ipt2	ipoint.h	/^	const I& ipt2(int i) const { return *matches_[i].second; }$/;"	f	class:Matches	access:public	signature:(int i) const
ipts	surf.h	/^	IpVec& ipts()               { return ipts_;  }	\/\/! Get the Ipoints vector$/;"	f	class:Surf	access:public	signature:()
ipts1_	ipoint.h	/^	IpVec*  ipts1_;$/;"	m	class:Matches	access:private
ipts2_	ipoint.h	/^	IpVec2* ipts2_;$/;"	m	class:Matches	access:private
iptsVec	surflib.h	/^	LibIpVec iptsVec;$/;"	m	struct:SurfLibRec	access:public
ipts_	surf.h	/^	IpVec ipts_;	\/\/! Ipoints vector$/;"	m	class:Surf	access:private
isExtremum	fasthessian.cpp	/^bool Octave::isExtremum(RPos p) {$/;"	f	class:Octave	signature:(RPos p)
is_first_get_	comm_box.hpp	/^	bool        is_first_get_;$/;"	m	class:MatchImageBox	access:private
l	surf.cpp	/^	float x, y, l;$/;"	m	class:MaxDirection	file:	access:private
laplacian	fasthessian.h	/^	float laplacian(int i, int r, int c) const { return layers_[i].laplacian(r, c); }$/;"	f	class:Octave	access:private	signature:(int i, int r, int c) const
laplacian	fasthessian.h	/^	float laplacian(int row, int column) const { return laplacian_(row, column); }$/;"	f	class:ResponseLayer	access:public	signature:(int row, int column) const
laplacian	ipoint.h	/^	int laplacian;			\/\/! Sign of laplacian for fast matching purposes$/;"	m	struct:Ipoint	access:public
laplacian_	fasthessian.h	/^	Image<unsigned char> laplacian_;$/;"	m	class:ResponseLayer	access:private
layers_	fasthessian.h	/^	ResponseLayer layers_[INTERVALS];$/;"	m	class:Octave	access:private
len	match_utils.h	/^	int len;$/;"	m	struct:MatchSection	access:public
lib_begin	match_utils.h	/^	int test_begin, lib_begin;$/;"	m	struct:MatchResult	access:public
lib_begin	match_utils.h	/^	int test_begin, lib_begin;$/;"	m	struct:MatchSection	access:public
lib_descriptor_type	comm_para.hpp	/^typedef unsigned int   lib_descriptor_type;$/;"	t
lib_id	match_utils.h	/^	int lib_id()  const { return lib_begin  >> 16; }$/;"	f	struct:MatchSection	access:public	signature:() const
lib_id_to_read	match_stream.hpp	/^	std::size_t lib_id_to_read;$/;"	m	struct:BigLibFile	access:private
lib_image	utils.h	/^typedef UTILS::image< lib_descriptor_type >   lib_image;$/;"	t
lib_pos	match_utils.h	/^	int lib_pos()  const { return lib_begin  & 0xffff; }$/;"	f	struct:MatchSection	access:public	signature:() const
lib_to_lib_second_frame	match_analyser.cpp	/^static unsigned lib_to_lib_second_frame( frame_type lib_frame )$/;"	f	file:	signature:( frame_type lib_frame )
lib_valid_	lib_load_service.hpp	/^	bool lib_valid_;$/;"	m	class:LibLoadService	access:private
libs	comm_arg.hpp	/^	std::vector<std::string> libs;$/;"	m	struct:CommArg	access:public
libs	match_stream.hpp	/^	vec_str libs;$/;"	m	struct:BigLibFile	access:private
load	integral.cpp	/^void GrayImage::load(const char* file_name) {$/;"	f	class:GrayImage	signature:(const char* file_name)
load	match_utils.cpp	/^void MatchArgs::load(const string& arg_file) {$/;"	f	class:MatchArgs	signature:(const string& arg_file)
loadLibNew	newlib.cpp	/^int loadLibNew( int nbits, VideoLibVec& video_lib, const string& lib_file )$/;"	f	signature:( int nbits, VideoLibVec& video_lib, const string& lib_file )
loadSurf	utils.cpp	/^void loadSurf(char *filename, vector<Ipoint> &ipts)$/;"	f	signature:(char *filename, vector<Ipoint> &ipts)
loadSurfLib	surflib.cpp	/^long loadSurfLib(const char* filename, SurfLib& lib) {$/;"	f	signature:(const char* filename, SurfLib& lib)
load_image_points_loop	match_stream.cpp	/^void ImagePointsLoader::load_image_points_loop()$/;"	f	class:ImagePointsLoader	signature:()
load_len	packet.hpp	/^	int      load_len() const { return data_len_ + 2; }$/;"	f	class:BasicPacket	access:public	signature:() const
load_lib_to_matcher	lib_load_service.cpp	/^void LibLoadService::load_lib_to_matcher( MatcherPtr m )$/;"	f	class:LibLoadService	signature:( MatcherPtr m )
load_lib_to_mem	lib_load_service.cpp	/^void LibLoadService::load_lib_to_mem(const std::string & path)$/;"	f	class:LibLoadService	signature:(const std::string & path)
load_ptr	packet.hpp	/^    u_char * load_ptr()  { return bytes_ + HEAD_SIZE;     }	\/\/ from type$/;"	f	class:BasicPacket	access:public	signature:()
local_endpoint	server.hpp	/^	const udp::endpoint  local_endpoint() const { return local_point_; }$/;"	f	class:Server	access:public	signature:() const
local_point_	server.hpp	/^	boost::asio::ip::udp::endpoint local_point_;				$/;"	m	class:Server	access:private
lock	comm_box.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:Basebox	access:public
lock	connection_build_service.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:ConnectionBuilderService	access:public
lock	lib_load_service.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:LibLoadService	access:public
lock	match_stream.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:ConnectionBuilder	access:public
lock	matcher_manager.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:Matcher	access:public
lock	matcher_manager.hpp	/^	typedef boost::mutex::scoped_lock lock;$/;"	t	class:MatcherManager	access:public
log_file	comm_arg.hpp	/^	std::string    log_file;$/;"	m	struct:CommArg	access:public
logger	log.h	/^		sev_logger&    logger()    { return slg_;       }$/;"	f	class:LOG::Log	access:public	signature:()
main	main.cpp	/^int main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
make_frame	match_stream.hpp	/^	static unsigned make_frame(unsigned frame_idx)$/;"	f	class:GrayImageGenerator	access:public	signature:(unsigned frame_idx)
make_frame	match_stream.hpp	/^	static unsigned make_frame(unsigned video_idx, unsigned frame_idx)$/;"	f	class:GrayImageGenerator	access:public	signature:(unsigned video_idx, unsigned frame_idx)
make_matcher	matcher_manager.hpp	/^	static MatcherPtr make_matcher( const Matcher::endpoint_type & e )$/;"	f	class:MatcherManager	access:public	signature:( const Matcher::endpoint_type & e )
make_shared_packet	packet.hpp	/^	static PacketPtr make_shared_packet(const Packet & pkt)$/;"	f	class:CfaUdpPacket	access:public	signature:(const Packet & pkt)
manually_broadcast_points	comm_arg.hpp	/^	int manually_broadcast_points;$/;"	m	struct:CommArg	access:public
mark_all_comm_end	server.cpp	/^void Server::mark_all_comm_end()$/;"	f	class:Server	signature:()
mark_broad_points_all_sent	server.hpp	/^	void mark_broad_points_all_sent() { broad_points_all_sent_ = true; }$/;"	f	class:Server	access:public	signature:()
mark_gray_image_all_sent	server.hpp	/^	void mark_gray_image_all_sent() { gray_img_all_sent_ = true; }$/;"	f	class:Server	access:public	signature:()
mark_image_points_all_sent	server.hpp	/^	void mark_image_points_all_sent() { image_points_all_sent_ = true; }$/;"	f	class:Server	access:public	signature:()
match	ipoint.h	/^	const void* match;		\/\/! matched ipoint$/;"	m	struct:Ipoint	access:public
matchThread	ipoint.cpp	/^void Matches<D, I>::matchThread(int tid) {$/;"	f	class:Matches	signature:(int tid)
match_bits	match_utils.h	/^	unsigned int match_bits;$/;"	m	struct:MatchResult	access:public
match_descriptor_type	comm_para.hpp	/^typedef unsigned short match_descriptor_type;$/;"	t
match_frame_is_image	match_analyser.hpp	/^	static bool     match_frame_is_image( frame_type frame )        { return get_match_frame_video_index( frame ) == 0; }$/;"	f	class:MatchAnalyser	access:public	signature:( frame_type frame )
match_frames	match_utils.cpp	/^void VideoMatcher::match_frames(const VideoLibVec<N>& lib, const LibPointVec<N>& frames, int frame_begin) {$/;"	f	class:VideoMatcher	signature:(const VideoLibVec<N>& lib, const LibPointVec<N>& frames, int frame_begin)
match_image	utils.h	/^typedef UTILS::image< match_descriptor_type > match_image;$/;"	t
match_image_box	server.hpp	/^	MatchImageBox      * match_image_box()     { return &match_image_box_; }$/;"	f	class:Server	access:public	signature:()
match_image_box_	server.hpp	/^	MatchImageBox         match_image_box_;				\/\/ match image box$/;"	m	class:Server	access:private
match_image_box_base__	comm_box.hpp	/^typedef RandomGetBox< 10,  match_image, SwapOp<match_image> > match_image_box_base__;$/;"	t
match_len	match_utils.h	/^	int match_len;$/;"	m	struct:MatchResult	access:public
match_pairs_vec_	match_analyser.hpp	/^	std::vector<MatchPairs>   match_pairs_vec_;$/;"	m	class:VideoMatchAnalyser	access:private
match_sections_	match_analyser.hpp	/^	std::vector<MatchSection> match_sections_;$/;"	m	class:VideoMatchAnalyser	access:private
match_timeout	comm_arg.hpp	/^	int match_timeout;$/;"	m	struct:CommArg	access:public
match_video	match_utils.cpp	/^void VideoMatcher::match_video(const VideoLibVec<N>& lib, const VideoLibVec<N>& video_to_match) {$/;"	f	class:VideoMatcher	signature:(const VideoLibVec<N>& lib, const VideoLibVec<N>& video_to_match)
match_video	match_utils.cpp	/^void VideoMatcher::match_video(const VideoLibVec<N>& lib, const std::string& video_file, int frame_start, int frame_end) {$/;"	f	class:VideoMatcher	signature:(const VideoLibVec<N>& lib, const std::string& video_file, int frame_start, int frame_end)
match_width	comm_arg.hpp	/^	int match_width;$/;"	m	struct:CommArg	access:public
matched_frames_	match_analyser.hpp	/^	frames_type matched_frames_;$/;"	m	class:ImageMatchAnalyser	access:private
matcher_busy_	server.hpp	/^	bool matcher_busy_;$/;"	m	class:Server	access:private
matchers	matcher_manager.hpp	/^	const Matchers & matchers() const { return matchers_; }$/;"	f	class:MatcherManager	access:public	signature:() const
matchers_	matcher_manager.hpp	/^	Matchers matchers_;$/;"	m	class:MatcherManager	access:private
matches_	ipoint.h	/^	std::vector<std::pair<const Ipoint*, const I*> > matches_;$/;"	m	class:Matches	access:private
matchs_map_	match_analyser.hpp	/^	matchs_map_type           matchs_map_;$/;"	m	class:VideoMatchAnalyser	access:private
matchs_map_type	match_analyser.hpp	/^	typedef std::map< frame_type, frames_type >          matchs_map_type;$/;"	t	class:VideoMatchAnalyser	access:public
max	integral.h	24;"	d
max_conn_times_allowed	comm_arg.hpp	/^	int max_conn_times_allowed;$/;"	m	struct:CommArg	access:public
max_skip	match_analyser.cpp	/^static const int max_skip = 1;				\/\/ å¯è·³è¿çè¿ç»­ä¸å¹éå¸§æ°$/;"	v	file:
max_skip	match_utils.h	/^	int max_skip;			\/\/ ¿ÉÌø¹ýµÄÁ¬Ðø²»Æ¥ÅäÖ¡Êý$/;"	m	struct:MatchArgs	access:public
merge	match_utils.cpp	/^void MatchSection::merge(const MatchSection& rhs) {$/;"	f	class:MatchSection	signature:(const MatchSection& rhs)
min	integral.h	20;"	d
min_ipts	match_analyser.cpp	/^static const int min_ipts = 8; 				\/\/ æ¯å¸§æå°å´è¶£ç¹æ°$/;"	v	file:
min_match_len	match_analyser.cpp	/^static const int min_match_len = 4;			\/\/ æå°è¿ç»­å¹éå¸§æ°éå¼$/;"	v	file:
min_match_len	match_utils.h	/^	int min_match_len;		\/\/ ×îÐ¡Á¬ÐøÆ¥ÅäÖ¡ÊýãÐÖµ$/;"	m	struct:MatchArgs	access:public
mode_	match_stream.hpp	/^	GEN_MODE mode_;$/;"	m	class:GrayImageGenerator	access:private
monitor	comm_box.hpp	/^	boost::mutex monitor;$/;"	m	class:Basebox	access:protected
monitor_	connection_build_service.hpp	/^	boost::mutex monitor_;$/;"	m	class:ConnectionBuilderService	access:private
monitor_	lib_load_service.hpp	/^	boost::mutex monitor_;$/;"	m	class:LibLoadService	access:private
monitor_	match_stream.hpp	/^	boost::mutex monitor_;$/;"	m	class:ConnectionBuilder	access:private
monitor_	matcher_manager.hpp	/^	boost::mutex monitor_;$/;"	m	class:Matcher	access:private
monitor_	matcher_manager.hpp	/^	boost::mutex monitor_;$/;"	m	class:MatcherManager	access:private
name	comm_window.hpp	/^	std::string name;$/;"	m	class:PacketWindow	access:protected
nbytes	bit_feature.h	/^	int nbytes() const { return nwords_ * 4; }$/;"	f	class:BitFeature	access:public	signature:() const
next	comm_window.hpp	/^	static std::size_t next(std::size_t p) { return (p + 1) % (N + 1); }$/;"	f	class:PacketWindow	access:protected	signature:(std::size_t p)
next_frame	match_utils.h	/^	double next_frame;$/;"	m	struct:VideoCapcture	access:private
no_available_matcher	matcher_manager.cpp	/^bool MatcherManager::no_available_matcher() $/;"	f	class:MatcherManager	signature:()
nodes_	match_stream.hpp	/^	std::vector< StreamNode * > nodes_;$/;"	m	class:StreamLine	access:private
notify_all_put	comm_box.cpp	/^void Basebox::notify_all_put()$/;"	f	class:Basebox	signature:()
notify_wait_get	comm_box.cpp	/^void Basebox::notify_wait_get()$/;"	f	class:Basebox	signature:()
notify_wait_matcher	connection_build_service.cpp	/^void ConnectionBuilderService::notify_wait_matcher()$/;"	f	class:ConnectionBuilderService	signature:()
notify_wait_matcher	lib_load_service.cpp	/^void LibLoadService::notify_wait_matcher()$/;"	f	class:LibLoadService	signature:()
notify_wait_put	comm_box.cpp	/^void Basebox::notify_wait_put()$/;"	f	class:Basebox	signature:()
num	surflib.h	/^	int num;$/;"	m	struct:SurfLibRec	access:public
num_clients	comm_arg.hpp	/^	int num_clients;$/;"	m	struct:CommArg	access:public
num_elements	comm_box.hpp	/^	virtual std::size_t num_elements() const { return curr; }$/;"	f	class:RandomGetBox	access:public	signature:() const
num_elements	comm_box.hpp	/^	virtual std::size_t num_elements() const { return data_valid ? 1 : 0; }$/;"	f	class:CommBox	access:public	signature:() const
num_elements	comm_box.hpp	/^	virtual std::size_t num_elements() const$/;"	f	class:PacketQueue	access:public	signature:() const
num_elements	comm_window.hpp	/^	virtual std::size_t num_elements() const$/;"	f	class:PacketWindow	access:public	signature:() const
num_first_get_required_	comm_box.hpp	/^	std::size_t num_first_get_required_;$/;"	m	class:MatchImageBox	access:private
num_load_imgs	matcher_manager.hpp	/^	unsigned num_load_imgs() const { return num_load_imgs_; }$/;"	f	class:Matcher	access:public	signature:() const
num_load_imgs_	matcher_manager.hpp	/^	unsigned num_load_imgs_;$/;"	m	class:Matcher	access:private
num_of_frames	newlib.h	/^	short num_of_frames;$/;"	m	struct:VideoLibRec	access:public
num_points_map_	match_analyser.hpp	/^	num_points_map_type num_points_map_;$/;"	m	class:MatchAnalyser	access:private
num_points_map_type	match_analyser.hpp	/^	typedef std::map<frame_type, unsigned>             num_points_map_type;$/;"	t	class:MatchAnalyser	access:public
num_skip_	match_stream.hpp	/^	int num_skip_;			\/\/ num image skipped$/;"	m	class:GrayImageLoader	access:private
num_timeout_	match_stream.hpp	/^	int num_timeout_;$/;"	m	class:ConnectionBuilder	access:private
nwords	bit_feature.h	/^	int nwords() const { return nwords_; }$/;"	f	class:BitFeature	access:public	signature:() const
nwords_	bit_feature.h	/^	int nwords_;$/;"	m	class:BitFeature	access:private
octaveThread	surf.cpp	/^inline void octaveThread(Octave& octave, bool mt = false) {$/;"	f	signature:(Octave& octave, bool mt = false)
offset	match_utils.h	/^	int offset()  const { return lib_begin - test_begin; }$/;"	f	struct:MatchSection	access:public	signature:() const
only_send_image	comm_arg.hpp	/^	int only_send_image;$/;"	m	struct:CommArg	access:public
only_send_lib	comm_arg.hpp	/^	int only_send_lib;$/;"	m	struct:CommArg	access:public
only_transform_lib	comm_arg.hpp	/^	int only_transform_lib;$/;"	m	struct:CommArg	access:public
open_services	server.cpp	/^void Server::open_services()$/;"	f	class:Server	signature:()
operator !	integral.h	/^	bool operator!() const { return size() == 0;  }		\/\/ test image validation$/;"	f	class:Image	access:public	signature:() const
operator ()	comm_box.hpp	/^	void operator () (T & lhs, T & rhs)$/;"	f	struct:SwapOp	access:public	signature:(T & lhs, T & rhs)
operator ()	comm_box.hpp	/^	void operator () (T & lhs, const T & rhs)$/;"	f	struct:AssignOp	access:public	signature:(T & lhs, const T & rhs)
operator ()	integral.h	/^	T  operator()(int row, int col) const { return pixel(row, col); }	\/\/ get the pixel$/;"	f	class:Image	access:public	signature:(int row, int col) const
operator ()	integral.h	/^	T& operator()(int row, int col)       { return pixel(row, col); }	\/\/ get\/set the pixel$/;"	f	class:Image	access:public	signature:(int row, int col)
operator ()	ipoint.h	/^	float operator () (const Ipoint& lhs, const I& rhs) const {$/;"	f	struct:EDist	access:public	signature:(const Ipoint& lhs, const I& rhs) const
operator ()	ipoint.h	/^	float operator () (const Ipoint& lhs, const I& rhs) const {$/;"	f	struct:MDist	access:public	signature:(const Ipoint& lhs, const I& rhs) const
operator ()	surf.cpp	/^	float operator()(int x, int y) const { return data[abs_(x)][abs_(y)]; }$/;"	f	class:__anon1::Gaussian	access:public	signature:(int x, int y) const
operator <	match_utils.h	/^inline bool operator < (const MatchSection& lhs, const MatchSection& rhs)$/;"	f	signature:(const MatchSection& lhs, const MatchSection& rhs)
operator <<	bit_feature.h	/^inline std::ostream& operator << (std::ostream& os, const BitFeature& f) {$/;"	f	signature:(std::ostream& os, const BitFeature& f)
operator <<	log.cpp	/^std::ostream& operator << (std::ostream& s, severity_level level) { return levelmap.writeEnum(s, level); }$/;"	f	namespace:LOG	signature:(std::ostream& s, severity_level level)
operator <<	match_utils.cpp	/^ostream& operator << (ostream& os, const MatchSection& sec) {$/;"	f	signature:(ostream& os, const MatchSection& sec)
operator ^	bit_feature.h	/^inline BitFeature operator ^ (const BitFeature& lhs, const BitFeature& rhs) {$/;"	f	signature:(const BitFeature& lhs, const BitFeature& rhs)
order_feature	bit_feature.cpp	/^BitFeature order_feature(int nbits, const GrayImage& gimg) {$/;"	f	signature:(int nbits, const GrayImage& gimg)
order_feature	bit_feature.cpp	/^BitFeature order_feature(int nbits, const IplImage* img) {$/;"	f	signature:(int nbits, const IplImage* img)
order_pairs128	bit_feature.cpp	/^	const int order_pairs128[128][2] = {$/;"	m	namespace:__anon4	file:
order_pairs32	bit_feature.cpp	/^	const int order_pairs32[32][2] = {$/;"	m	namespace:__anon4	file:
orientation	ipoint.h	/^	float orientation;		\/\/! Orientation measured anti-clockwise from +ve x-axis$/;"	m	struct:Ipoint	access:public
out_file	comm_arg.hpp	/^	std::string    out_file;$/;"	m	struct:CommArg	access:public
output_chain	match_utils.cpp	/^void SectionManager::output_chain(ostream& out, int id) {$/;"	f	class:SectionManager	signature:(ostream& out, int id)
packet_handle_loop	packet_handle_center.cpp	/^void PacketHandleCenter::packet_handle_loop()$/;"	f	class:PacketHandleCenter	signature:()
packet_queue	server.hpp	/^	PacketQueue        * packet_queue()        { return &pkt_queue_; }$/;"	f	class:Server	access:public	signature:()
parse_host_file	comm_arg.cpp	/^bool CommArg::parse_host_file( const char * file )$/;"	f	class:CommArg	signature:( const char * file )
parse_info_file	comm_arg.cpp	/^bool CommArg::parse_info_file( const char * file )$/;"	f	class:CommArg	signature:( const char * file )
path_	match_analyser.hpp	/^	const std::string path_;$/;"	m	class:ImageMatchAnalyser	access:private
path_	match_analyser.hpp	/^	const std::string path_;$/;"	m	class:VideoMatchAnalyser	access:private
pi	surf.cpp	/^const float pi = 3.14159265;$/;"	m	namespace:__anon1	file:
pipts	match_analyser.cpp	/^static const int pipts = 30;				\/\/ SURFé¢æå´è¶£ç¹æ°$/;"	v	file:
pipts	surf.h	/^	int    pipts()        const { return pipts_; }$/;"	f	class:Surf	access:public	signature:() const
pipts_	surf.h	/^	int   pipts_;	\/\/! preferred Ipoints number$/;"	m	class:Surf	access:private
pixel	integral.h	/^	T  pixel(int row, int col) const { return data_[row * width_ + col]; }	\/\/ get the pixel$/;"	f	class:Image	access:protected	signature:(int row, int col) const
pixel	integral.h	/^	T& pixel(int row, int col)       { return data_[row * width_ + col]; }	\/\/ get\/set the pixel$/;"	f	class:Image	access:protected	signature:(int row, int col)
pkt_	match_stream.hpp	/^	Packet pkt_;$/;"	m	class:ConnectionBuilder	access:private
pkt_queue_	server.hpp	/^	PacketQueue           pkt_queue_;$/;"	m	class:Server	access:private
point	utils.h	/^		struct point$/;"	s	struct:UTILS::image	access:public
point_man	server.hpp	/^	point_manager      * point_man() { return &point_man_; }$/;"	f	class:Server	access:public	signature:()
point_man_	server.hpp	/^    point_manager point_man_;							  \/\/ point manager$/;"	m	class:Server	access:private
point_manager	point_manager.hpp	/^typedef PointAuxer point_manager;$/;"	t
point_vec	newlib.h	/^	LibPointVec point_vec;$/;"	m	struct:VideoLibRec	access:public
points	utils.h	/^		std::vector<point> points;$/;"	m	struct:UTILS::image	access:public
port	matcher_manager.hpp	/^	unsigned            port   () const { return endpoint_.port(); }$/;"	f	class:Matcher	access:public	signature:() const
port	server.hpp	/^	unsigned short                 port() const { return local_point_.port(); }$/;"	f	class:Server	access:public	signature:() const
print_conn_matchers	matcher_manager.hpp	/^	void print_conn_matchers(std::ostream & out) const$/;"	f	class:MatcherManager	access:public	signature:(std::ostream & out) const
print_matcher_util	matcher_manager.cpp	/^void MatcherManager::print_matcher_util( ostream & out, const Matchers & ms ) const$/;"	f	class:MatcherManager	signature:( ostream & out, const Matchers & ms ) const
print_matchers	matcher_manager.hpp	/^	void print_matchers     (std::ostream & out) const$/;"	f	class:MatcherManager	access:public	signature:(std::ostream & out) const
print_ranges	match_analyser.cpp	/^void VideoMatchAnalyser::print_ranges(std::ostream & out)$/;"	f	class:VideoMatchAnalyser	signature:(std::ostream & out)
print_sections	match_analyser.cpp	/^void VideoMatchAnalyser::print_sections(std::ostream & out)$/;"	f	class:VideoMatchAnalyser	signature:(std::ostream & out)
put	comm_box.cpp	/^void MatchImageBox::put()$/;"	f	class:MatchImageBox	signature:()
put	comm_box.hpp	/^	void put()$/;"	f	class:RandomGetBox	access:public	signature:()
put	comm_box.hpp	/^	void put(PacketPtr p)$/;"	f	class:PacketQueue	access:public	signature:(PacketPtr p)
put	comm_box.hpp	/^	void put(const T & t)$/;"	f	class:CommBox	access:public	signature:(const T & t)
put	comm_window.hpp	/^	void put()$/;"	f	class:PacketWindow	access:public	signature:()
put_condition_not_satisfied	comm_box.hpp	/^	virtual bool put_condition_not_satisfied() const { return box_full(); }$/;"	f	class:Basebox	access:public	signature:() const
queue_	comm_box.hpp	/^	std::queue< PacketPtr > queue_;$/;"	m	class:PacketQueue	access:private
quit_	packet_handle_center.hpp	/^	bool quit_;$/;"	m	class:PacketHandleCenter	access:private
quit_wanted_	server.hpp	/^	bool quit_wanted_;$/;"	m	class:Server	access:private
r	fasthessian.h	/^	struct RPos { int i, r, c; };$/;"	m	struct:Octave::RPos	access:public
rHeight	fasthessian.h	/^	int rWidth, rHeight;		\/\/ response size$/;"	m	class:Octave	access:private
rOffset	fasthessian.h	/^	int rOffset;				\/\/ TLBorder * step$/;"	m	class:Octave	access:private
rWidth	fasthessian.h	/^	int rWidth, rHeight;		\/\/ response size$/;"	m	class:Octave	access:private
random_loop	comm_arg.hpp	/^	int random_loop;$/;"	m	struct:CommArg	access:public
raw_packet_base__	packet.hpp	/^typedef BasicPacket<RAW_HEAD_SIZE, RAW_MAX_LOAD_LEN> raw_packet_base__;$/;"	t
raw_response_packet_base__	packet.hpp	/^typedef BasicPacket<RAW_HEAD_SIZE, RAW_MIN_LOAD_LEN> raw_response_packet_base__;$/;"	t
reach_file_end	match_stream.hpp	/^	bool reach_file_end;$/;"	m	struct:BigLibFile	access:private
readEnum	fdutils.h	/^	E readEnum(std::istream& s) const {$/;"	f	class:EnumStringMap	access:public	signature:(std::istream& s) const
read_word	match_stream.hpp	/^	bool read_word( int & word )$/;"	f	struct:BigLibFile	access:public	signature:( int & word )
ready_receive	matcher_manager.hpp	/^	bool ready_receive() const { return (state_ == READY) && comm_state_ == RESPONSED; }$/;"	f	class:Matcher	access:public	signature:() const
record_to_match_frame	match_analyser.cpp	/^void VideoMatchAnalyser::record_to_match_frame( frame_type to_match_frame )$/;"	f	class:VideoMatchAnalyser	signature:( frame_type to_match_frame )
recv_buffer_	server.hpp	/^	boost::asio::mutable_buffers_1 recv_buffer_;        \/\/ receive asio buffer$/;"	m	class:Server	access:private
recv_diverse_handler	server.cpp	/^void Server::recv_diverse_handler(const error_code& ec, size_t length)$/;"	f	class:Server	signature:(const error_code& ec, size_t length)
recv_pkt_	server.hpp	/^	Packet recv_pkt_;                                   \/\/ receive packet buffer$/;"	m	class:Server	access:private
reset	comm_window.hpp	/^	void reset()$/;"	f	class:PacketWindow	access:public	signature:()
reset	integral.h	/^	void reset(int w, int h) { width_ = w; height_ = h; delete[] data_; data_ = new T[w*h]; }$/;"	f	class:Image	access:public	signature:(int w, int h)
reset	surf.cpp	/^	void reset() { for (int i = 0; i < N; ++i) sx[i] = sy[i] = 0.f; }$/;"	f	class:__anon1::SubWins	access:public	signature:()
response	fasthessian.h	/^	float response(RPos p) const { return response(p.i, p.r, p.c); }$/;"	f	class:Octave	access:private	signature:(RPos p) const
response	fasthessian.h	/^	float response(int i, int r, int c)  const { return layers_[i].response(r, c); }$/;"	f	class:Octave	access:private	signature:(int i, int r, int c) const
response	fasthessian.h	/^	float response(int row, int column)  const { return responses_(row, column); }$/;"	f	class:ResponseLayer	access:public	signature:(int row, int column) const
responses_	fasthessian.h	/^	Image<float> responses_;$/;"	m	class:ResponseLayer	access:private
run	connection_build_service.cpp	/^void ConnectionBuilderService::run()$/;"	f	class:ConnectionBuilderService	signature:()
run	lib_load_service.cpp	/^void LibLoadService::run()$/;"	f	class:LibLoadService	signature:()
run	match_stream.hpp	/^	void run()$/;"	f	class:StreamNode	access:public	signature:()
run	packet_handle_center.cpp	/^void PacketHandleCenter::run()$/;"	f	class:PacketHandleCenter	signature:()
same_sequence	match_utils.h	/^inline bool same_sequence(const MatchSection& lhs, const MatchSection& rhs)$/;"	f	signature:(const MatchSection& lhs, const MatchSection& rhs)
saveLibNew	newlib.cpp	/^int saveLibNew( const VideoLibRec& video_rec, const std::string& file_name )$/;"	f	signature:( const VideoLibRec& video_rec, const std::string& file_name )
saveLibNew	newlib.cpp	/^int saveLibNew( const VideoLibRec& video_rec, std::ostream& of )$/;"	f	signature:( const VideoLibRec& video_rec, std::ostream& of )
saveNewVideoLib	match_utils.cpp	/^int saveNewVideoLib(const std::string& video_name, int video_num, LIB& lib) {$/;"	f	signature:(const std::string& video_name, int video_num, LIB& lib)
saveSurf	utils.cpp	/^void saveSurf(char *filename, vector<Ipoint> &ipts)$/;"	f	signature:(char *filename, vector<Ipoint> &ipts)
saveSurf	utils.cpp	/^void saveSurf(ostream& outfile, vector<Ipoint> &ipts)$/;"	f	signature:(ostream& outfile, vector<Ipoint> &ipts)
saveSurfLib	surflib.cpp	/^int saveSurfLib(const char* filename, const IPV& ipts, int num) {$/;"	f	signature:(const char* filename, const IPV& ipts, int num)
saveSurfLib	surflib.cpp	/^int saveSurfLib(std::ostream& outfile, const IPV& ipts, int num) {$/;"	f	signature:(std::ostream& outfile, const IPV& ipts, int num)
scale	ipoint.h	/^	float scale;			\/\/! Detected scale$/;"	m	struct:Ipoint	access:public
sec_dist	match_utils.h	/^inline int sec_dist(const MatchSection& lhs, const MatchSection& rhs) {$/;"	f	signature:(const MatchSection& lhs, const MatchSection& rhs)
sec_man_	match_utils.h	/^	SectionManager sec_man_;$/;"	m	class:VideoMatcher	access:private
send	server.cpp	/^void Server::send( const boost::asio::mutable_buffers_1 & buffer, const udp::endpoint & dest )$/;"	f	class:Server	signature:( const boost::asio::mutable_buffers_1 & buffer, const udp::endpoint & dest )
send_handler	server.cpp	/^void Server::send_handler(const error_code& ec, size_t length)$/;"	f	class:Server	signature:(const error_code& ec, size_t length)
send_packets_loop	match_stream.cpp	/^void ImagePointsSender::send_packets_loop()$/;"	f	class:ImagePointsSender	signature:()
send_port	comm_arg.hpp	/^	unsigned short send_port;$/;"	m	struct:CommArg	access:public
send_sock_	server.hpp	/^	boost::asio::ip::udp::socket send_sock_;            \/\/ main thread socket$/;"	m	class:Server	access:private
sequence_thres	match_utils.h	/^	int sequence_thres;		\/\/ ÓÃÓÚÆ¥Åä¶ÎµÄºÏ²¢$/;"	m	struct:MatchArgs	access:public
server_	comm_box.hpp	/^	Server *    server_;$/;"	m	class:MatchImageBox	access:private
server_	comm_box.hpp	/^	Server * server_;$/;"	m	class:ImageGenBox	access:private
server_	point_manager.hpp	/^	Server * server_;$/;"	m	class:PointAuxer	access:private
server_	server.hpp	/^	static Server * server_;$/;"	m	class:Server	access:private
server_port	comm_arg.hpp	/^	unsigned short server_port;$/;"	m	struct:CommArg	access:public
set	bits.hpp	/^	void set (int i) { ASSERTS(i < N);        bytes[i >> SHIFT] |=  (0x80 >> (i & MASK)); }$/;"	f	struct:bits	access:public	signature:(int i)
set	bits.hpp	/^	void set()       { memset(byte_ptr(), 0xFF, N >> SHIFT); }$/;"	f	struct:bits	access:public	signature:()
set	surf.cpp	/^	void set(float sx, float sy) {$/;"	f	class:MaxDirection	access:public	signature:(float sx, float sy)
set_comm_state	matcher_manager.hpp	/^	void set_comm_state(COMM_STATE s) { lock lk(monitor_); comm_state_ = s; }$/;"	f	class:Matcher	access:public	signature:(COMM_STATE s)
set_console_filter	log.h	/^	template<typename F> inline void set_console_filter(F const& flt)$/;"	f	namespace:LOG	signature:(F const& flt)
set_console_format	log.h	/^	template<typename F> inline void set_console_format(F const& fmt)$/;"	f	namespace:LOG	signature:(F const& fmt)
set_ctrl	packet.hpp	/^	void        set_ctrl(u_char c) { bytes_[HEAD_SIZE + 2] = c; }$/;"	f	class:BasicPacket	access:public	signature:(u_char c)
set_data_len	packet.hpp	/^	void set_data_len(unsigned l)$/;"	f	class:BasicPacket	access:public	signature:(unsigned l)
set_dest_addr	match_stream.cpp	/^void ImagePointsSender::set_dest_addr( const endpoint & addr )$/;"	f	class:ImagePointsSender	signature:( const endpoint & addr )
set_extracter_busy	server.cpp	/^void Server::set_extracter_busy( bool b )$/;"	f	class:Server	signature:( bool b )
set_file_filter	log.h	/^	template<typename F> inline void set_file_filter(F const& flt)$/;"	f	namespace:LOG	signature:(F const& flt)
set_file_format	log.h	/^	template<typename F> inline void set_file_format(F const& fmt)$/;"	f	namespace:LOG	signature:(F const& fmt)
set_filter	log.h	/^	template<typename SP, typename FLT> inline void set_filter(SP sink, FLT const& flt)$/;"	f	namespace:LOG	signature:(SP sink, FLT const& flt)
set_format	log.h	/^	template<typename SP, typename FMT> inline void set_format(SP sink, FMT const& fmt)$/;"	f	namespace:LOG	signature:(SP sink, FMT const& fmt)
set_from_point	packet.hpp	/^	void set_from_point(const udp::endpoint & e)$/;"	f	class:CfaUdpPacket	access:public	signature:(const udp::endpoint & e)
set_index	packet.hpp	/^	void       set_index(u_char c) { bytes_[HEAD_SIZE + 1] = c; }$/;"	f	class:BasicPacket	access:public	signature:(u_char c)
set_info	packet.hpp	/^	void       	set_info(u_char type, u_char idx) { set_type(type); set_index(idx); }$/;"	f	class:BasicPacket	access:public	signature:(u_char type, u_char idx)
set_info	packet.hpp	/^	void       	set_info(u_char type, u_char idx, int len) { set_type(type); set_index(idx); set_data_len(len); }$/;"	f	class:BasicPacket	access:public	signature:(u_char type, u_char idx, int len)
set_load_len	packet.hpp	/^	void set_load_len(unsigned l)  { set_data_len(l - 2); }$/;"	f	class:BasicPacket	access:public	signature:(unsigned l)
set_matcher_comm_state	matcher_manager.hpp	/^	void set_matcher_comm_state( MatcherPtr m , Matcher::COMM_STATE s ) { set_matcher_comm_state( *m, s ); }$/;"	f	class:MatcherManager	access:public	signature:( MatcherPtr m , Matcher::COMM_STATE s )
set_matcher_comm_state	matcher_manager.hpp	/^	void set_matcher_comm_state( const Matcher & m , Matcher::COMM_STATE s )$/;"	f	class:MatcherManager	access:public	signature:( const Matcher & m , Matcher::COMM_STATE s )
set_matcher_comm_state	matcher_manager.hpp	/^	void set_matcher_comm_state( const Matcher::endpoint_type & e, Matcher::COMM_STATE s ) { set_matcher_comm_state( Matcher(e), s ); }$/;"	f	class:MatcherManager	access:public	signature:( const Matcher::endpoint_type & e, Matcher::COMM_STATE s )
set_matcher_state	matcher_manager.hpp	/^	void set_matcher_state( MatcherPtr m , Matcher::MATCHER_STATE s ) { set_matcher_state( *m, s ); }$/;"	f	class:MatcherManager	access:public	signature:( MatcherPtr m , Matcher::MATCHER_STATE s )
set_matcher_state	matcher_manager.hpp	/^	void set_matcher_state( const Matcher & m , Matcher::MATCHER_STATE s )$/;"	f	class:MatcherManager	access:public	signature:( const Matcher & m , Matcher::MATCHER_STATE s )
set_matcher_state	matcher_manager.hpp	/^	void set_matcher_state( const Matcher::endpoint_type & e, Matcher::MATCHER_STATE s ) { set_matcher_state( Matcher(e), s ); }$/;"	f	class:MatcherManager	access:public	signature:( const Matcher::endpoint_type & e, Matcher::MATCHER_STATE s )
set_num_points_of_frame	match_analyser.cpp	/^void MatchAnalyser::set_num_points_of_frame( frame_type frame , unsigned num_points )$/;"	f	class:MatchAnalyser	signature:( frame_type frame , unsigned num_points )
set_pause	match_stream.hpp	/^	void set_pause(int img, int vdo)$/;"	f	class:GrayImageGenerator	access:public	signature:(int img, int vdo)
set_size	bits.hpp	/^	void set_size(int n)$/;"	f	struct:bits	access:public	signature:(int n)
set_snk_mac	packet.hpp	/^	void       set_snk_mac(const eth::address& addr) { memcpy(bytes_    , addr.to_bytes(), 6); }$/;"	f	class:BasicPacket	access:public	signature:(const eth::address& addr)
set_src_mac	packet.hpp	/^	void       set_src_mac(const eth::address& addr) { memcpy(bytes_ + 6, addr.to_bytes(), 6); }$/;"	f	class:BasicPacket	access:public	signature:(const eth::address& addr)
set_state	matcher_manager.hpp	/^	void set_state(MATCHER_STATE s) { lock lk(monitor_); state_ = s; }$/;"	f	class:Matcher	access:public	signature:(MATCHER_STATE s)
set_total_len	packet.hpp	/^	void set_total_len(unsigned l) {$/;"	f	class:BasicPacket	access:public	signature:(unsigned l)
set_type	packet.hpp	/^	void        set_type(u_char c) { bytes_[HEAD_SIZE + 0] = c; }$/;"	f	class:BasicPacket	access:public	signature:(u_char c)
sev_levels	log.cpp	/^static const char* sev_levels[] = { "DEBUG", "VERBOSE", "INFO ", "WARN ", "ERROR" };$/;"	m	namespace:LOG	file:
sev_logger	log.h	/^	typedef src::severity_logger<severity_level> sev_logger;$/;"	t	namespace:LOG
severity_level	log.h	/^	enum severity_level { DEBUG, VERBOSE, INFO, WARN, ERR };$/;"	g	namespace:LOG
showImage	utils.cpp	/^void showImage(char *title,const IplImage *img)$/;"	f	signature:(char *title,const IplImage *img)
showImage	utils.cpp	/^void showImage(const IplImage *img)$/;"	f	signature:(const IplImage *img)
sin	surf.cpp	/^	float sin() const { return y \/ sqrt(l); }$/;"	f	class:MaxDirection	access:public	signature:() const
sin_ori	ipoint.h	/^	float sin_ori, cos_ori;	\/\/! sin(orientation) and cos(orientation)$/;"	m	struct:Ipoint	access:public
single2half	fdutils.h	/^static halfp single2half(float f) {$/;"	f	signature:(float f)
sink_con_	log.h	/^		sp_stream_sink sink_con_;$/;"	m	class:LOG::Log	access:private
sink_file_	log.h	/^		sp_file_sink   sink_file_;$/;"	m	class:LOG::Log	access:private
size	integral.h	/^	int size()   const { return width_ * height_; }$/;"	f	class:Image	access:public	signature:() const
size	ipoint.h	/^	int size() const { return matches_.size(); }$/;"	f	class:Matches	access:public	signature:() const
size	surf.h	/^	int    size()         const { return ipts_.size(); }$/;"	f	class:Surf	access:public	signature:() const
sleep_time	comm_arg.hpp	/^  	int sleep_time;$/;"	m	struct:CommArg	access:public
slg_	log.h	/^		sev_logger     slg_;$/;"	m	class:LOG::Log	access:private
snk_addr	packet.hpp	/^	eth::address snk_addr() const { return eth::address(bytes_    , 6); }$/;"	f	class:BasicPacket	access:public	signature:() const
socket_	server.hpp	/^	boost::asio::ip::udp::socket socket_;               \/\/ main thread socket$/;"	m	class:Server	access:private
sp_file_sink	log.h	/^	typedef boost::shared_ptr<sinks::synchronous_sink<sinks::text_file_backend> >    sp_file_sink;$/;"	t	namespace:LOG
sp_log_core	log.h	/^	typedef boost::shared_ptr<logging::core>     sp_log_core;$/;"	t	namespace:LOG
sp_stream_sink	log.h	/^	typedef boost::shared_ptr<sinks::synchronous_sink<sinks::text_ostream_backend> > sp_stream_sink;$/;"	t	namespace:LOG
src_addr	packet.hpp	/^	eth::address src_addr() const { return eth::address(bytes_ + 6, 6); }$/;"	f	class:BasicPacket	access:public	signature:() const
src_endpoint_	packet.hpp	/^	udp::endpoint src_endpoint_;$/;"	m	class:CfaUdpPacket	access:private
start_main	server.cpp	/^void Server::start_main()$/;"	f	class:Server	signature:()
start_match_stream	server.cpp	/^void Server::start_match_stream()$/;"	f	class:Server	signature:()
start_running_stream	match_stream.hpp	/^	void start_running_stream()$/;"	f	class:StreamLine	access:public	signature:()
state	matcher_manager.hpp	/^	MATCHER_STATE state() const { return state_; }$/;"	f	class:Matcher	access:public	signature:() const
state_	matcher_manager.hpp	/^	MATCHER_STATE state_;$/;"	m	class:Matcher	access:private
step	fasthessian.h	/^	int step;$/;"	m	class:Octave	access:private
storeMatch	ipoint.cpp	/^void Matches<EDist, Ipoint>::storeMatch(Ipoint* ipt) {$/;"	f	class:Matches	signature:(Ipoint* ipt)
storeMatch	ipoint.cpp	/^void Matches<MDist, Ipoint>::storeMatch(Ipoint* ipt) {$/;"	f	class:Matches	signature:(Ipoint* ipt)
storeMatch	ipoint.h	/^	void storeMatch(Ipoint* ipt)$/;"	f	class:Matches	access:private	signature:(Ipoint* ipt)
store_match_group_info	match_analyser.cpp	/^void MatchAnalyser::store_match_group_info( const MatchAnalyser::endpoint & addr, const MatchAnalyser::frames_type & frame_group, const std::vector<unsigned> & num_points_vec )$/;"	f	class:MatchAnalyser	signature:( const MatchAnalyser::endpoint & addr, const MatchAnalyser::frames_type & frame_group, const std::vector<unsigned> & num_points_vec )
sumx	surf.cpp	/^	float sumx(int i) const { return sx[i < N ? i : i - N]; }$/;"	f	class:__anon1::SubWins	access:public	signature:(int i) const
sumy	surf.cpp	/^	float sumy(int i) const { return sy[i < N ? i : i - N]; }$/;"	f	class:__anon1::SubWins	access:public	signature:(int i) const
surf_	fasthessian.h	/^	Surf* surf_;$/;"	m	class:Octave	access:private
surf_lib_loader	server.hpp	/^	SurfLibLoader      * surf_lib_loader()     const { return surf_lib_loader_; }$/;"	f	class:Server	access:public	signature:() const
surf_lib_loader_	server.hpp	/^	SurfLibLoader      * surf_lib_loader_;$/;"	m	class:Server	access:private
surf_lib_sender	server.hpp	/^	SurfLibSender      * surf_lib_sender()     const { return surf_lib_sender_; }$/;"	f	class:Server	access:public	signature:() const
surf_lib_sender_	server.hpp	/^	SurfLibSender      * surf_lib_sender_;$/;"	m	class:Server	access:private
surf_lib_window	server.hpp	/^	SurfLibWindow      * surf_lib_window()     { return &surf_lib_window_; }	$/;"	f	class:Server	access:public	signature:()
surf_lib_window_	server.hpp	/^	SurfLibWindow         surf_lib_window_;				\/\/ window for sending surf lib points$/;"	m	class:Server	access:private
surf_lib_window_base__	comm_window.hpp	/^typedef PacketWindow<16> surf_lib_window_base__;$/;"	t
surf_thres	match_analyser.cpp	/^static const float surf_thres = 0.0004;		\/\/ SURFéå¼$/;"	v	file:
swap	utils.h	/^		void swap(image & other)$/;"	f	struct:UTILS::image	access:public	signature:(image & other)
sx	surf.cpp	/^	 float tg[HN-1], sx[N], sy[N];$/;"	m	class:__anon1::SubWins	file:	access:private
sy	surf.cpp	/^	 float tg[HN-1], sx[N], sy[N];$/;"	m	class:__anon1::SubWins	file:	access:private
tail	comm_box.hpp	/^	int tail;$/;"	m	class:RandomGetBox	access:protected
tail	comm_window.hpp	/^	std::size_t tail;	\/\/ ¶ÓÁÐÎ²£¬Ö¸ÏòÒ»¸ö¿Õ°ü£¬ÓÉacquire()·µ»Ø$/;"	m	class:PacketWindow	access:protected
test	bits.hpp	/^	bool test(int i) { ASSERTS(i < N); return bytes[i >> SHIFT] &   (0x80 >> (i & MASK)); }$/;"	f	struct:bits	access:public	signature:(int i)
test_begin	match_utils.h	/^	int test_begin, lib_begin;$/;"	m	struct:MatchResult	access:public
test_begin	match_utils.h	/^	int test_begin, lib_begin;$/;"	m	struct:MatchSection	access:public
test_id	match_utils.h	/^	int test_id() const { return test_begin >> 16; }$/;"	f	struct:MatchSection	access:public	signature:() const
test_pos	match_utils.h	/^	int test_pos() const { return test_begin & 0xffff; }$/;"	f	struct:MatchSection	access:public	signature:() const
tg	match_stream.hpp	/^	boost::thread_group tg;$/;"	m	class:StreamLine	access:private
tg	surf.cpp	/^	 float tg[HN-1], sx[N], sy[N];$/;"	m	class:__anon1::SubWins	file:	access:private
threadRange	fdutils.h	/^inline Range threadRange(Range drng, int tid) {$/;"	f	signature:(Range drng, int tid)
thres_	surf.h	/^	float thres_;	\/\/! blob response threshold$/;"	m	class:Surf	access:private
threshold	ipoint.h	/^	float threshold() const { return 0.42; }$/;"	f	struct:EDist	access:public	signature:() const
threshold	ipoint.h	/^	float threshold() const { return 0.6; }$/;"	f	struct:MDist	access:public	signature:() const
threshold	surf.h	/^	float  threshold()    const { return thres_; }$/;"	f	class:Surf	access:public	signature:() const
time_stamp	match_utils.h	/^	double time_stamp;$/;"	m	struct:VideoCapcture	access:public
to_endpoint	matcher_manager.hpp	/^	const endpoint_type to_endpoint() const { return endpoint_; }$/;"	f	class:Matcher	access:public	signature:() const
to_int	bits.hpp	/^	int to_int() {$/;"	f	struct:bits	access:public	signature:()
to_raw_buffer	packet.hpp	/^	boost::asio::mutable_buffers_1 to_raw_buffer() { return boost::asio::buffer(bytes_, total_len()); }$/;"	f	class:BasicPacket	access:public	signature:()
to_string	bits.hpp	/^	std::string to_string() {$/;"	f	struct:bits	access:public	signature:()
to_udp_buffer	packet.hpp	/^	boost::asio::mutable_buffers_1 to_udp_buffer() { return boost::asio::buffer(bytes_ + UDP_HEAD_SIZE, total_len() - UDP_HEAD_SIZE ); }$/;"	f	class:BasicPacket	access:public	signature:()
total_len	packet.hpp	/^	int     total_len() const { return load_len() + HEAD_SIZE; }$/;"	f	class:BasicPacket	access:public	signature:() const
transformImage	match_utils.cpp	/^IplImage* transformImage(IplImage* img) {$/;"	f	signature:(IplImage* img)
try_merge_sections	match_analyser.cpp	/^bool VideoMatchAnalyser::try_merge_sections(MatchSection & lhs, MatchSection & rhs)$/;"	f	class:VideoMatchAnalyser	signature:(MatchSection & lhs, MatchSection & rhs)
type	packet.hpp	/^	u_char          type() const   { return bytes_[HEAD_SIZE + 0]; }$/;"	f	class:BasicPacket	access:public	signature:() const
u_char	comm_para.hpp	/^typedef unsigned char  u_char;$/;"	t
uint32	fdutils.h	/^typedef unsigned int  uint32;		\/\/ 32 bit$/;"	t
update_len_bytes	packet.hpp	/^	virtual void update_len_bytes()$/;"	f	class:BasicPacket	access:public	signature:()
update_len_bytes	packet.hpp	/^	virtual void update_len_bytes()$/;"	f	class:CfaUdpPacket	access:public	signature:()
update_len_bytes	packet.hpp	/^	virtual void update_len_bytes()$/;"	f	class:CfaUdpResponPacket	access:public	signature:()
vec_str	match_stream.hpp	/^	typedef std::vector< std::string > vec_str;$/;"	t	struct:BigLibFile	access:public
video_beg	comm_arg.hpp	/^	int video_beg;$/;"	m	struct:CommArg	access:public
video_end	comm_arg.hpp	/^	int video_end;$/;"	m	struct:CommArg	access:public
video_id	utils.h	/^		unsigned video_id () const { return frame_index >> 24; }$/;"	f	struct:UTILS::image	access:public	signature:() const
video_lib	lib_load_service.hpp	/^	const VideoLibVec & video_lib()$/;"	f	class:LibLoadService	access:public	signature:()
video_lib_	lib_load_service.hpp	/^	VideoLibVec video_lib_;$/;"	m	class:LibLoadService	access:private
video_matcher_ptr	match_analyser.hpp	/^typedef boost::shared_ptr<VideoMatchAnalyser> video_matcher_ptr;$/;"	t
video_num	newlib.h	/^	short video_num;$/;"	m	struct:VideoLibRec	access:public
video_pause	comm_arg.hpp	/^	int video_pause;$/;"	m	struct:CommArg	access:public
video_pause	match_stream.hpp	/^	int video_pause;$/;"	m	class:GrayImageGenerator	access:private
video_ratio	comm_arg.hpp	/^	int video_ratio;$/;"	m	struct:CommArg	access:public
videos	comm_arg.hpp	/^	std::vector<std::string> videos;$/;"	m	struct:CommArg	access:public
videos_map_	match_analyser.hpp	/^	videos_map_type videos_map_;$/;"	m	class:MatchAnalyser	access:private
videos_map_type	match_analyser.hpp	/^    typedef std::map<frame_type, video_matcher_ptr>    videos_map_type;$/;"	t	class:MatchAnalyser	access:public
vs_	match_utils.h	/^	std::vector<MatchSection> vs_;$/;"	m	class:VideoMatcher	access:private
wait_get_condition	comm_box.cpp	/^void Basebox::wait_get_condition()$/;"	f	class:Basebox	signature:()
wait_put_condition	comm_box.cpp	/^void Basebox::wait_put_condition()$/;"	f	class:Basebox	signature:()
wait_stream_end	match_stream.hpp	/^	void wait_stream_end()$/;"	f	class:StreamLine	access:public	signature:()
wait_until_box_empty	comm_box.cpp	/^void Basebox::wait_until_box_empty()$/;"	f	class:Basebox	signature:()
wanna_quit	server.hpp	/^	bool wanna_quit() const { return quit_wanted_; }$/;"	f	class:Server	access:public	signature:() const
width	integral.h	/^	int width()  const { return width_;  }$/;"	f	class:Image	access:public	signature:() const
width_	integral.h	/^	int width_;             \/\/ Image width in pixels$/;"	m	class:Image	access:private
words	bit_feature.h	/^		Word   words[MAX_FEATURE_BITS\/32];$/;"	m	union:BitFeature::__anon5	access:public
writeEnum	fdutils.h	/^	std::ostream& writeEnum(std::ostream& s, E val) { return s << getString(val); }$/;"	f	class:EnumStringMap	access:public	signature:(std::ostream& s, E val)
write_match_result	match_analyser.cpp	/^void ImageMatchAnalyser::write_match_result( std::ostream & out )$/;"	f	class:ImageMatchAnalyser	signature:( std::ostream & out )
write_match_result	match_analyser.cpp	/^void MatchAnalyser::write_match_result( std::ostream & out )$/;"	f	class:MatchAnalyser	signature:( std::ostream & out )
write_match_result	match_analyser.cpp	/^void VideoMatchAnalyser::write_match_result( std::ostream & out )$/;"	f	class:VideoMatchAnalyser	signature:( std::ostream & out )
x	ipoint.h	/^	float x, y;				\/\/! Coordinates of the detected interest point$/;"	m	struct:Ipoint	access:public
x	surf.cpp	/^	float x, y, l;$/;"	m	class:MaxDirection	file:	access:private
xml_attribute	match_analyser.cpp	9;"	d	file:
xml_begin_image	match_analyser.cpp	/^void ImageMatchAnalyser::xml_begin_image( std::ostream & out )$/;"	f	class:ImageMatchAnalyser	signature:( std::ostream & out )
xml_begin_video	match_analyser.cpp	/^void VideoMatchAnalyser::xml_begin_video( std::ostream & out )$/;"	f	class:VideoMatchAnalyser	signature:( std::ostream & out )
xml_end_image	match_analyser.cpp	/^void ImageMatchAnalyser::xml_end_image( std::ostream & out )$/;"	f	class:ImageMatchAnalyser	signature:( std::ostream & out )
xml_end_video	match_analyser.cpp	/^void VideoMatchAnalyser::xml_end_video( std::ostream & out )$/;"	f	class:VideoMatchAnalyser	signature:( std::ostream & out )
xml_match_section	match_analyser.cpp	/^void VideoMatchAnalyser::xml_match_section( std::ostream & out, unsigned index, const MatchSection & sec )$/;"	f	class:VideoMatchAnalyser	signature:( std::ostream & out, unsigned index, const MatchSection & sec )
xml_matched_image	match_analyser.cpp	/^void ImageMatchAnalyser::xml_matched_image( std::ostream & out, unsigned index, frame_type matched_frame )$/;"	f	class:ImageMatchAnalyser	signature:( std::ostream & out, unsigned index, frame_type matched_frame )
y	ipoint.h	/^	float x, y;				\/\/! Coordinates of the detected interest point$/;"	m	struct:Ipoint	access:public
y	surf.cpp	/^	float x, y, l;$/;"	m	class:MaxDirection	file:	access:private
~BigLibFile	match_stream.hpp	/^	~BigLibFile()$/;"	f	struct:BigLibFile	access:public	signature:()
~Image	integral.h	/^	~Image() { delete[] data_; }$/;"	f	class:Image	access:public	signature:()
~StreamLine	match_stream.hpp	/^	~StreamLine()$/;"	f	class:StreamLine	access:public	signature:()
~StreamNode	match_stream.hpp	/^	virtual ~StreamNode() {}$/;"	f	class:StreamNode	access:public	signature:()
~VideoCapcture	match_utils.cpp	/^VideoCapcture::~VideoCapcture() { cvReleaseCapture(&capture); }$/;"	f	class:VideoCapcture	signature:()
